
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;18.&nbsp;Type Inference</title>
      <link rel="stylesheet" type="text/css" href="https://docs.oracle.com/javase/specs/javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-17.html" title="Chapter&nbsp;17.&nbsp;Threads and Locks">
      <link rel="next" href="jls-19.html" title="Chapter&nbsp;19.&nbsp;Syntax">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="https://docs.oracle.com/javase/webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="https://docs.oracle.com/javase/8/docs/">Java SE</a> &gt; <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;18.&nbsp;Type Inference</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-17.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-19.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;18.&nbsp;Type Inference">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-18"></a>Chapter&nbsp;18.&nbsp;Type Inference
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-18.html#jls-18.1">18.1. Concepts and Notation</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.1">18.1.1. Inference Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.2">18.1.2. Constraint Formulas</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.1.3">18.1.3. Bounds</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.2">18.2. Reduction</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.1">18.2.1. Expression Compatibility Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.2">18.2.2. Type Compatibility Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.3">18.2.3. Subtyping Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.4">18.2.4. Type Equality Constraints</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.2.5">18.2.5. Checked Exception Constraints</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.3">18.3. Incorporation</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.3.1">18.3.1. Complementary Pairs of Bounds</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.3.2">18.3.2. Bounds Involving Capture Conversion</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-18.html#jls-18.4">18.4. Resolution</a></span></dt>
               <dt><span class="section"><a href="jls-18.html#jls-18.5">18.5. Uses of Inference</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.1">18.5.1. Invocation Applicability Inference</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.2">18.5.2. Invocation Type Inference</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.3">18.5.3. Functional Interface Parameterization Inference</a></span></dt>
                     <dt><span class="section"><a href="jls-18.html#jls-18.5.4">18.5.4. More Specific Method Inference</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-18-100"></a>A variety of compile-time
            analyses require reasoning about types that are not yet
            known. Principal among these are generic method applicability testing
            (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>) and generic method invocation type
            inference (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>). In general, we refer to the
            process of reasoning about unknown types as <span class="emphasis"><em>type
                  inference</em></span>.
         </p>
         <p class="norm"><a name="jls-18-200"></a>At a high level, type inference
            can be decomposed into three processes:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-A"></a>
                           <span class="emphasis"><em>Reduction</em></span> takes a compatibility assertion
                           about an expression or type, called a <span class="emphasis"><em>constraint
                                 formula</em></span>, and reduces it to a set
                           of <span class="emphasis"><em>bounds</em></span> on <span class="emphasis"><em>inference
                                 variables</em></span>. Often, a constraint formula reduces
                           to <span class="emphasis"><em>other</em></span> constraint formulas, which must be
                           recursively reduced.  A procedure is followed to identify these
                           additional constraint formulas and, ultimately, to express via a
                           bound set the conditions under which the choices for inferred
                           types would render each constraint formula true.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-B"></a>
                           <span class="emphasis"><em>Incorporation</em></span> maintains a set of inference
                           variable bounds, ensuring that these are consistent as new
                           bounds are added.  Because the bounds on one variable can
                           sometimes impact the possible choices for another variable, this
                           process propagates bounds between such interdependent
                           variables.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-200-C"></a>
                           <span class="emphasis"><em>Resolution</em></span> examines the bounds on an
                           inference variable and determines
                           an <span class="emphasis"><em>instantiation</em></span> that is compatible with
                           those bounds. It also decides the order in which interdependent
                           inference variables are to be resolved.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-18-300"></a>These processes interact
            closely: reduction can trigger incorporation; incorporation may lead
            to further reduction; and resolution may cause further
            incorporation.
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-A"></a>
                           <a class="xref" href="jls-18.html#jls-18.1" title="18.1.&nbsp;Concepts and Notation">&sect;18.1</a> more precisely defines the concepts
                           used as intermediate results and the notation used to express
                           them.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-B"></a>
                           <a class="xref" href="jls-18.html#jls-18.2" title="18.2.&nbsp;Reduction">&sect;18.2</a> describes reduction in detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-C"></a>
                           <a class="xref" href="jls-18.html#jls-18.3" title="18.3.&nbsp;Incorporation">&sect;18.3</a> describes incorporation in
                           detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-D"></a>
                           <a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a> describes resolution in
                           detail.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-18-300-E"></a>
                           <a class="xref" href="jls-18.html#jls-18.5" title="18.5.&nbsp;Uses of Inference">&sect;18.5</a> defines how these inference tools are
                           used to solve certain compile-time analysis problems.
                  </p>
               </li>
            </ul>
         </div>
         <p class="note">In comparison to the Java SE 7 Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>,
            important changes to inference include:
         </p>
         <div class="note">
            <ul class="note" type="disc">
               <li class="listitem">
                  <p class="note">Adding support for lambda expressions and method
                           references as method invocation arguments.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Generalizing to define inference in terms of
                           poly expressions, which may not have well-defined types
                           until <span class="emphasis"><em>after</em></span> inference is complete.  This
                           has the notable effect of improving inference for nested generic
                           method and diamond constructor invocations.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Describing how inference is used to handle
                           wildcard-parameterized functional interface target types and
                           most specific method analysis.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Clarifying the distinction between invocation
                           applicability testing (which involves only the invocation
                           arguments) and invocation type inference (which incorporates a
                           target type).
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Delaying resolution of all inference variables,
                           even those with lower bounds, until invocation type inference,
                           in order to get better results.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Improving inference behavior for interdependent
                           (or self-dependent) variables.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Eliminating bugs and potential sources of
                           confusion.  This revision more carefully and precisely handles
                           the distinction between specific conversion contexts and
                           subtyping, and describes reduction by paralleling the
                           corresponding non-inference relations.  Where there are
                           intentional departures from the non-inference relations, these
                           are explicitly identified as such.
                  </p>
               </li>
               <li class="listitem">
                  <p class="note">Laying a foundation for future evolution:
                           enhancements to or new applications of inference will be easier
                           to integrate into the specification.
                  </p>
               </li>
            </ul>
         </div>
         <div class="section" title="18.1.&nbsp;Concepts and Notation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.1"></a>18.1.&nbsp;Concepts and Notation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-18.1-100"></a>This section
               defines <span class="emphasis"><em>inference variables</em></span>, <span class="emphasis"><em>constraint
                     formulas</em></span>, and <span class="emphasis"><em>bounds</em></span>, as the terms
               will be used throughout this chapter. It also presents
               notation.
            </p>
            <div class="section" title="18.1.1.&nbsp;Inference Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.1"></a>18.1.1.&nbsp;Inference Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-18.1.1-100"></a><span class="emphasis"><em>Inference
                        variables</em></span> are <span class="emphasis"><em>meta-variables</em></span> for types
                  - that is, they are special names that allow abstract reasoning about
                  types. To distinguish them from <span class="emphasis"><em>type variables</em></span>,
                  inference variables are represented with Greek letters, principally
                  <span class="symbol">&#945;</span>.
               </p>
               <p class="norm"><a name="jls-18.1.1-110"></a>The term "type" is used
                  loosely in this chapter to include type-like syntax that contains
                  inference variables. The term <span class="emphasis"><em>proper type</em></span>
                  excludes such "types" that mention inference variables. Assertions
                  that involve inference variables are assertions about every proper
                  type that can be produced by replacing each inference variable with a
                  proper type.
               </p>
            </div>
            <div class="section" title="18.1.2.&nbsp;Constraint Formulas">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.2"></a>18.1.2.&nbsp;Constraint Formulas
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.2-100"></a>
                  <span class="emphasis"><em>Constraint formulas</em></span> are assertions of
                  compatibility or subtyping that may involve inference variables. The
                  formulas may take one of the following forms:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-A"></a>
                                 &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;: An expression is
                                 compatible in a loose invocation context with type <span class="type">T</span>
                                 (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-B"></a>
                                 &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;: A type <span class="type">S</span> is compatible in a
                                 loose invocation context with type <span class="type">T</span>
                                 (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-C"></a>
                                 &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;: A reference type <span class="type">S</span> is a
                                 subtype of a reference type <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-D"></a>
                                 &#8249;<span class="type">S</span> <code class="literal">&lt;=</code> <span class="type">T</span>&#8250;: A type argument <span class="type">S</span> is
                                 contained by a type argument <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-E"></a>
                                 &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;: A  type <span class="type">S</span> is the same as a
                                  type <span class="type">T</span> (<a class="xref" href="jls-4.html#jls-4.3.4" title="4.3.4.&nbsp;When Reference Types Are the Same">&sect;4.3.4</a>), or a
                                 type argument <span class="type">S</span> is the same as type argument <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-F"></a>
                                 &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;: The checked
                                 exceptions thrown by the body of the <span class="emphasis"><em>LambdaExpression</em></span> are
                                 declared by the <code class="literal">throws</code> clause of the function type derived
                                 from <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.2-100-G"></a>
                                 &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;: The checked
                                 exceptions thrown by the referenced method are declared by the
                                 <code class="literal">throws</code> clause of the function type derived from <span class="type">T</span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">Examples of constraint formulas:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">From <code class="literal">Collections.singleton("hi")</code>,
                                    we have the constraint formula &#8249;<code class="literal">"hi"</code>
                                    <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;. Through reduction, this will become the
                                    constraint formula: &#8249;<code class="literal">String</code> <code class="literal">&lt;:</code>
                                    <span class="symbol">&#945;</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">From <code class="literal">Arrays.asList(1, 2.0)</code>,
                                    we have the constraint formulas &#8249;<code class="literal">1</code> <span class="symbol">&#8594;</span>
                                    <span class="symbol">&#945;</span>&#8250; and &#8249;<code class="literal">2.0</code> <span class="symbol">&#8594;</span>
                                    <span class="symbol">&#945;</span>&#8250;. Through reduction, these will become the
                                    constraint formulas &#8249;<code class="literal">int</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250; and
                                    &#8249;<code class="literal">double</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;, and then &#8249;<code class="literal">Integer</code>
                                    <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>&#8250; and &#8249;<code class="literal">Double</code> <code class="literal">&lt;:</code>
                                    <span class="symbol">&#945;</span>&#8250;.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">From the target type of the constructor
                                    invocation <code class="literal">List&lt;Thread&gt; lt = new
                                       ArrayList<code class="literal">&lt;&gt;</code>()</code>, we have the constraint formula
                                    &#8249;<code class="literal">ArrayList</code><code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code>
                                    <span class="symbol">&#8594;</span> <code class="literal">List</code><code class="literal">&lt;</code><code class="literal">Thread</code><code class="literal">&gt;</code>&#8250;. Through
                                    reduction, this will become the constraint formula
                                    &#8249;<span class="symbol">&#945;</span> <code class="literal">&lt;=</code> <code class="literal">Thread</code>&#8250;, and then
                                    &#8249;<span class="symbol">&#945;</span> = <code class="literal">Thread</code>&#8250;.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="section" title="18.1.3.&nbsp;Bounds">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.1.3"></a>18.1.3.&nbsp;Bounds
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-100"></a>During
                  the inference process, a set of <span class="emphasis"><em>bounds</em></span> on
                  inference variables is maintained. A bound has one of the following
                  forms:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-A"></a>
                                 <span class="type">S</span> = <span class="type">T</span>, where at least one of <span class="type">S</span> or <span class="type">T</span> is an inference
                                 variable: <span class="type">S</span> is the same as <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-B"></a>
                                 <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>, where at least one of <span class="type">S</span> or <span class="type">T</span> is an
                                 inference variable: <span class="type">S</span> is a subtype of <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-C"></a>
                                 <span class="emphasis"><em>false</em></span>: No valid choice of inference variables
                                 exists.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-D"></a>
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                                 capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>): The variables
                                 <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> represent the result of capture
                                 conversion (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) applied to
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code> (where <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> may be
                                 types or wildcards and may mention inference variables).
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-100-E"></a>
                                 <code class="literal">throws</code> <span class="symbol">&#945;</span>: The inference variable <span class="symbol">&#945;</span> appears in a
                                 <code class="literal">throws</code> clause.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-200"></a>A bound
                  is <span class="emphasis"><em>satisfied</em></span> by an inference variable
                  substitution if, after applying the substitution, the assertion is
                  true. The bound <span class="emphasis"><em>false</em></span> can never be satisfied.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-300"></a>Some
                  bounds relate an inference variable to a proper type. Let <span class="type">T</span> be a
                  proper type. Given a bound of the form <span class="symbol">&#945;</span> = <span class="type">T</span> or <span class="type">T</span> = <span class="symbol">&#945;</span>,
                  we say <span class="type">T</span> is an <span class="emphasis"><em>instantiation</em></span> of <span class="symbol">&#945;</span>.
                  Similarly, given a bound of the form <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>, we say <span class="type">T</span>
                  is a <span class="emphasis"><em>proper upper bound</em></span> of <span class="symbol">&#945;</span>, and given a
                  bound of the form <span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, we say <span class="type">T</span> is
                  a <span class="emphasis"><em>proper lower bound</em></span> of <span class="symbol">&#945;</span>.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-310"></a>Other
                  bounds relate two inference variables, or an inference variable to a
                  type that contains inference variables. Such bounds, of the form <span class="type">S</span> =
                  <span class="type">T</span> or <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>, are called 
                  <span class="emphasis"><em>dependencies</em></span>.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-320"></a>A bound
                  of the form <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                  capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>) indicates that <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>,
                  ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> are placeholders for the results of capture
                  conversion. This is necessary because capture conversion can only be
                  performed on a proper type, and the inference variables in <span class="type">A<sub>1</sub></span>, ...,
                  <span class="type">A<sub>n</sub></span> may not yet be resolved.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-330"></a>A bound
                  of the form <code class="literal">throws</code> <span class="symbol">&#945;</span> is purely informational: it directs
                  resolution to optimize the instantiation of <span class="symbol">&#945;</span> so that, if
                  possible, it is not a checked exception type.
               </p>
               <p class="norm-static"><a name="jls-18.1.3-400"></a>An
                  important intermediate result of inference is a <span class="emphasis"><em>bound
                        set</em></span>. It is sometimes convenient to refer to
                  an <span class="emphasis"><em>empty</em></span> bound set with the symbol <span class="emphasis"><em>true</em></span>;
                  this is merely out of convenience, and the two are
                  interchangeable.
               </p>
               <div class="informalexample">
                  <p class="note">Examples of bound sets:</p>
                  <div class="note">
                     <ul class="note" type="disc">
                        <li class="listitem">
                           <p class="note">{ <span class="symbol">&#945;</span> = <code class="literal">String</code> } contains a single bound,
                                    instantiating <span class="symbol">&#945;</span> as <code class="literal">String</code>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, <code class="literal">Double</code>
                                    <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> } describes two
                                    proper lower bounds and one proper upper bound for
                                    <span class="symbol">&#945;</span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <span class="symbol">&#945;</span>
                                    <code class="literal">&lt;:</code> <code class="literal">Iterable&lt;?&gt;</code>, <span class="symbol">&#946;</span> <code class="literal">&lt;:</code>
                                    <code class="literal">Object</code>, <span class="symbol">&#945;</span>
                                    <code class="literal">&lt;:</code> <code class="literal">List</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code> }
                                    describes a proper upper bound for each of <span class="symbol">&#945;</span> and <span class="symbol">&#946;</span>,
                                    along with a dependency between them.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ } contains no bounds nor dependencies, and can
                                    be referred to as <span class="emphasis"><em>true</em></span>.
                           </p>
                        </li>
                        <li class="listitem">
                           <p class="note">{ <span class="emphasis"><em>false</em></span> } expresses the fact that no
                                    satisfactory instantiation exists.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.1.3-410"></a>When
                  inference begins, a bound set is typically generated from a list of
                  type parameter declarations <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span> and associated inference
                  variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span>. Such a bound set is constructed as
                  follows. For each <span class="emphasis"><em>l</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>l</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.3-410-A"></a>If
                                 <span class="type">P<sub>l</sub></span> has no <span class="emphasis"><em>TypeBound</em></span>, the
                                 bound <span class="emphasis"><em><span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code> <code class="literal">Object</code></em></span> appears
                                 in the set.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.1.4-410-B"></a>
                                 Otherwise, for each type <span class="type">T</span> delimited by <code class="literal">&amp;</code> in
                                 the <span class="emphasis"><em>TypeBound</em></span>, the bound <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code>
                                 <span class="type">T</span><code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code> appears
                                 in the set; if this results in no proper upper bounds for
                                 <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> (only dependencies), then the bound <span class="symbol">&#945;</span><span class="type"><sub>l</sub></span> <code class="literal">&lt;:</code>
                                 <code class="literal">Object</code> also appears in the set.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="18.2.&nbsp;Reduction">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.2"></a>18.2.&nbsp;Reduction
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.2-100"></a>
               <span class="emphasis"><em>Reduction</em></span> is the process by which a set of
               constraint formulas (<a class="xref" href="jls-18.html#jls-18.1.2" title="18.1.2.&nbsp;Constraint Formulas">&sect;18.1.2</a>) is simplified to
               produce a bound set (<a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>).
            </p>
            <p class="norm-static"><a name="jls-18.2-200"></a>Each
               constraint formula is considered in turn. The rules in this section
               specify how the formula is reduced to one or both of:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.2-200-A"></a>
                              A bound or bound set, which is to be incorporated with the
                              "current" bound set. Initially, the current bound set is
                              empty.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.2-200-B"></a>
                              Further constraint formulas, which are to be reduced
                              recursively.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-18.2-210"></a>Reduction
               completes when no further constraint formulas remain to be
               reduced.
            </p>
            <p class="note">The results of a reduction step are
               always <span class="emphasis"><em>soundness-preserving</em></span>: if an inference
               variable instantiation satisfies the reduced constraints and bounds,
               it will also satisfy the original constraint.  On the other hand,
               reduction is not <span class="emphasis"><em>completeness-preserving</em></span>: there
               may exist inference variable instantiations that satisfy the original
               constraint but <span class="emphasis"><em>do not</em></span> satisfy a reduced
               constraint or bound. This is due to inherent limitations of the
               algorithm, along with a desire to avoid undue complexity. One effect
               is that there are expressions for which type argument inference fails
               to find a solution, but that can be well-typed if the programmer
               explicitly inserts appropriate types.
            </p>
            <div class="section" title="18.2.1.&nbsp;Expression Compatibility Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.1"></a>18.2.1.&nbsp;Expression Compatibility Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.1-100"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;
                  is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-A"></a>
                                 If <span class="type">T</span> is a proper type, the constraint reduces to <span class="emphasis"><em>true</em></span> if
                                 the expression is compatible in a loose invocation context with
                                 <span class="type">T</span> (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-B"></a>
                                 Otherwise, if the expression is a standalone expression
                                 (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) of type <span class="type">S</span>, the constraint reduces
                                 to &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-100-C"></a>
                                 Otherwise, the expression is a poly expression
                                 (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>). The result depends on the form of
                                 the expression:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-A"></a>
                                    	  If the expression is a parenthesized expression of the form
                                    	  <code class="literal">(</code> <span class="emphasis"><em>Expression</em></span>' <code class="literal">)</code>, the constraint reduces to
                                    	  &#8249;<span class="emphasis"><em>Expression</em></span>' <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-B"></a>
                                    	  If the expression is a class instance creation expression or
                                    	  a method invocation expression, the constraint reduces to
                                    	  the bound set <span class="type">B<sub>3</sub></span> which would be used to determine the
                                    	  expression's invocation type when targeting <span class="type">T</span>, as defined
                                    	  in <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>. (For a class instance
                                    	  creation expression, the corresponding "method" used for
                                    	  inference is defined in
                                    	  <a class="xref" href="jls-15.html#jls-15.9.3" title="15.9.3.&nbsp;Choosing the Constructor and its Arguments">&sect;15.9.3</a>).
                                 </p>
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-B.1"></a>
                                    	  This bound set may contain new inference variables, as well
                                    	  as dependencies between these new variables and the
                                    	  inference variables in <span class="type">T</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-C"></a>
                                    	  If the expression is a conditional expression of the form
                                    	  <code class="varname">e<sub>1</sub></code> <code class="literal">?</code> <code class="varname">e<sub>2</sub></code> <code class="literal">:</code> <code class="varname">e<sub>3</sub></code>, the constraint reduces to two
                                    	  constraint formulas, &#8249;<code class="varname">e<sub>2</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; and
                                    	  &#8249;<code class="varname">e<sub>3</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-100-C-D"></a>
                                    	  If the expression is a lambda expression or a method
                                    	  reference expression, the result is specified below.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">By treating nested generic method invocations as
                  poly expressions, we improve the behavior of inference for nested
                  invocations. For example, the following is illegal in Java SE 7 but
                  legal in Java SE 8:
               </p><pre class="screen">
ProcessBuilder b = new ProcessBuilder(Collections.emptyList());
  // ProcessBuilder's constructor expects a List&lt;String&gt;
</pre><p class="note">When <span class="emphasis"><em>both</em></span> the outer and the
                  nested invocation require inference, the problem is more difficult.
                  For example:
               </p><pre class="screen">List&lt;String&gt; ls = new ArrayList&lt;&gt;(Collections.emptyList());</pre><p class="note">Our approach is to "lift" the bounds inferred for
                  the nested invocation (simply { <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> } in the
                  case of <code class="literal">emptyList</code>) into the outer inference process
                  (in this case, trying to infer <span class="symbol">&#946;</span> where the constructor is for
                  type <code class="literal">ArrayList</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code>). We also
                  infer dependencies between the nested inference variables and the
                  outer inference variables (the constraint
                  &#8249;<code class="literal">List</code><code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code>
                  <span class="symbol">&#8594;</span> <code class="literal">Collection</code><code class="literal">&lt;</code><span class="symbol">&#946;</span><code class="literal">&gt;</code>&#8250;
                  would reduce to the dependency <span class="symbol">&#945;</span> = <span class="symbol">&#946;</span>). In this way,
                  resolution of the inference variables in the nested invocation can
                  wait until additional information can be inferred from the outer
                  invocation (based on the assignment target, <span class="symbol">&#946;</span> = <code class="literal">String</code>).
               </p>
               <p class="norm-static"><a name="jls-18.2.1-200"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span>
                  <span class="type">T</span>&#8250;, where <span class="type">T</span> mentions at least one inference variable, is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-200-A"></a>
                                 If <span class="type">T</span> is not a functional interface type
                                 (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-200-B"></a>
                                 Otherwise, let <span class="type">T'</span> be the ground target type derived from
                                 <span class="type">T</span>, as specified in <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>. If
                                 <a class="xref" href="jls-18.html#jls-18.5.3" title="18.5.3.&nbsp;Functional Interface Parameterization Inference">&sect;18.5.3</a> is used to derive a functional
                                 interface type which is parameterized, then the test that
                                 <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is a subtype of
                                 <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code> is not performed (instead, it
                                 is asserted with a constraint formula below). Let the target
                                 function type for the lambda expression be the function type of
                                 <span class="type">T'</span>. Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-200-B-A"></a>
                                    	  If no valid function type can be found, the constraint
                                    	  reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-200-B-B"></a>
                                    	  Otherwise, the congruence of <span class="emphasis"><em>LambdaExpression</em></span> with the
                                    	  target function type is asserted as follows:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-A"></a>
                                             	      If the number of lambda parameters differs from the
                                             	      number of parameter types of the function type, the
                                             	      constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-B"></a>
                                             	      If the lambda expression is implicitly typed and one or
                                             	      more of the function type's parameter types is not a
                                             	      proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                          <p class="note">
                                             	      This condition never arises in practice, due to the
                                             	      handling of implicitly typed lambda expressions in
                                             	      <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a> and the substitution
                                             	      applied to the target type in
                                             	      <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-C"></a>
                                             	      If the function type's result is <code class="literal">void</code> and the lambda
                                             	      body is neither a statement expression nor a
                                             	      void-compatible block, the constraint reduces to
                                             	      <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-D"></a>
                                             	      If the function type's result is not <code class="literal">void</code> and the
                                             	      lambda body is a block that is not value-compatible, the
                                             	      constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-200-B-B-E"></a>
                                             	      Otherwise, the constraint reduces to all of the following
                                             	      constraint formulas:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-A"></a>
                                                      		  If the lambda parameters have explicitly declared types
                                                      		  <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n</sub></span> and the function type has parameter types
                                                      		  <span class="type">G<sub>1</sub></span>, ..., <span class="type">G<sub>n</sub></span>, then i) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                                      		  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">F<sub>i</sub></span> = <span class="type">G<sub>i</sub></span>&#8250;, and ii)
                                                      		  &#8249;<span class="type">T'</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B"></a>
                                                      		  If the function type's return type is a (non-<code class="literal">void</code>) type
                                                      		  <span class="type">R</span>, assume the lambda's parameter types are the same as the
                                                      		  function type's parameter types. Then:
                                                   </p>
                                                   <div class="">
                                                      <ul class="" type="circle">
                                                         <li class="listitem">
                                                            <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B-A"></a>
                                                               		      If <span class="type">R</span> is a proper type, and if the lambda body or some
                                                               		      result expression in the lambda body is not compatible
                                                               		      in an assignment context with <span class="type">R</span>, then <span class="emphasis"><em>false</em></span>.
                                                            </p>
                                                         </li>
                                                         <li class="listitem">
                                                            <p class="norm-static"><a name="jls-18.2.1-200-B-B-E-B-B"></a>
                                                               		      Otherwise, if <span class="type">R</span> is not a proper type, then where the
                                                               		      lambda body has the form <span class="emphasis"><em>Expression</em></span>, the constraint
                                                               		      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;; or where the
                                                               		      lambda body is a block with result expressions <code class="varname">e<sub>1</sub></code>,
                                                               		      ..., <code class="varname">e<sub>m</sub></code>, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>),
                                                               		      &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;.
                                                            </p>
                                                         </li>
                                                      </ul>
                                                   </div>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">The key piece of information to derive from a
                  compatibility constraint involving a lambda expression is the set of
                  bounds on inference variables appearing in the target function type's
                  return type. This is crucial, because functional interfaces are often
                  generic, and many methods operating on these types are generic,
                  too.
               </p>
               <p class="note">In the simplest case, a lambda expression may simply
                  provide a lower bound for an inference variable:
               </p><pre class="screen">
&lt;T&gt; List&lt;T&gt; makeThree(Factory&lt;T&gt; factory) { ... }
String s = makeThree(() <code class="literal">-&gt;</code> "abc").get(2);
</pre><p class="note">In more complex cases, a result expression may be a
                  poly expression - perhaps even another lambda expression - and so the
                  inference variable might be passed through multiple constraint
                  formulas with different target types before a bound is
                  produced.
               </p>
               <p class="note">Most of the work described in this section precedes
                  assertions about the result expressions; its purpose is to derive the
                  lambda expression's function type, and to check for expressions that
                  are clearly disqualified from compatibility.
               </p>
               <p class="note">We do <span class="emphasis"><em>not</em></span> attempt to produce
                  bounds on inference variables that appear in the target function
                  type's <code class="literal">throws</code> clause. This is because exception containment is not
                  part of compatibility (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>) - in particular,
                  it must not influence method applicability
                  (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>). However, we <span class="emphasis"><em>do</em></span>
                  get bounds on these variables later, because invocation type inference
                  (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>) produces exception containment
                  constraint formulas (<a class="xref" href="jls-18.html#jls-18.2.5" title="18.2.5.&nbsp;Checked Exception Constraints">&sect;18.2.5</a>).
               </p>
               <p class="note">Note that if the target type is an inference
                  variable, or if the target type's parameter types contain inference
                  variables, we produce <span class="emphasis"><em>false</em></span>. During invocation type inference
                  (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>), extra substitutions are performed in
                  order to instantiate these inference variables, thus avoiding this
                  scenario. (In other words, reduction will, in practice, never be
                  "invoked" with a target type of one of these forms.)
               </p>
               <p class="note">Finally, note that the result expressions of a
                  lambda expression are required by <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a> to be
                  compatible in an assignment context with the target type's return
                  type, <span class="type">R</span>. If <span class="type">R</span> is a proper type, such as <code class="literal">Byte</code> derived
                  from <code class="literal">Function<code class="literal">&lt;</code><span class="symbol">&#945;</span>,<code class="literal">Byte</code><code class="literal">&gt;</code></code>, then
                  assignability is easy enough to test, and reduction does so above. If
                  <span class="type">R</span> is not a proper type, such as <span class="symbol">&#945;</span> derived from
                  <code class="literal">Function<code class="literal">&lt;</code>String,<span class="symbol">&#945;</span><code class="literal">&gt;</code></code>, then we
                  make the simplifying assumption above that loose invocation
                  compatibility will be sufficient. The difference between assignment
                  compatibility and loose invocation compatibility is that only
                  assignment allows narrowing of constant expressions, such
                  as <code class="literal">Byte b = 100;</code>. Consequently, our simplifying
                  assumption is not completeness-preserving: given target return type
                  <span class="symbol">&#945;</span> and an integer literal result expression
                  <code class="literal">100</code>, it is conceivable that <span class="symbol">&#945;</span> could be
                  instantiated to <code class="literal">Byte</code>, but reduction will not in fact produce such a
                  bound.
               </p>
               <p class="norm-static"><a name="jls-18.2.1-300"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span>
                  <span class="type">T</span>&#8250;, where <span class="type">T</span> mentions at least one inference variable, is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-A"></a>
                                 If <span class="type">T</span> is not a functional interface type, or if <span class="type">T</span> is a
                                 functional interface type that does not have a function type
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-B"></a>
                                 Otherwise, if there does not exist a potentially applicable
                                 method for the method reference when targeting <span class="type">T</span>, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-C"></a>
                                 Otherwise, if the method reference is exact
                                 (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), then let <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> be the
                                 parameter types of the function type of <span class="type">T</span>, and let <span class="type">F<sub>1</sub></span>, ...,
                                 <span class="type">F<sub>k</sub></span> be the parameter types of the potentially applicable
                                 method. The constraint reduces to a new set of constraints, as
                                 follows:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-A"></a>
                                    	  In the special case where <span class="emphasis"><em>n</em></span> = <span class="emphasis"><em>k</em></span>+1, the parameter
                                              of type <span class="type">P<sub>1</sub></span> is to act as the target reference of the
                                              invocation. The method reference expression necessarily has
                                              the form <span class="emphasis"><em>ReferenceType <code class="literal">::</code>
                                                    [TypeArguments] Identifier</em></span>. The constraint
                                              reduces to &#8249;<span class="type">P<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="emphasis"><em>ReferenceType</em></span>&#8250; and,
                                              for all <span class="emphasis"><em>i</em></span> (2 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">P<sub>i</sub></span>
                                              <span class="symbol">&#8594;</span> <span class="type">F<sub>i-1</sub></span>&#8250;.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-A.1"></a>
                                    	  In all other cases, <span class="emphasis"><em>n</em></span> = <span class="emphasis"><em>k</em></span>, and the constraint
                                    	  reduces to, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>),
                                    	  &#8249;<span class="type">P<sub>i</sub></span> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-C-B"></a>
                                    	  If the function type's result is not <code class="literal">void</code>, let <span class="type">R</span> be its
                                    	  return type. Then, if the result of the potentially
                                    	  applicable compile-time declaration is <code class="literal">void</code>, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise, the constraint
                                    	  reduces to &#8249;<span class="type">R</span>' <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;, where <span class="type">R</span>' is the
                                    	  result of applying capture conversion
                                    	  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the return type of the
                                    	  potentially applicable compile-time declaration.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.1-300-D"></a>
                                 Otherwise, the method reference is inexact, and:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-D-A"></a>
                                    	  If one or more of the function type's parameter types is not
                                    	  a proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                                 <p class="note">
                                    	  This condition never arises in practice, due to the handling
                                    	  of inexact method references in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>
                                    	  and the substitution applied to the target type in
                                    	  <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.1-300-D-B"></a>
                                    	  Otherwise, a search for a compile-time declaration is
                                    	  performed, as specified in <a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>. If
                                    	  there is no compile-time declaration for the method
                                    	  reference, the constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise,
                                    	  there is a compile-time declaration, and:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-A"></a>
                                             	      If the result of the function type is <code class="literal">void</code>, the
                                             	      constraint reduces to <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-B"></a>
                                             	      Otherwise, if the method reference expression elides
                                             	      <span class="emphasis"><em>TypeArguments</em></span>, and the compile-time declaration is a
                                             	      generic method, and the return type of the compile-time
                                             	      declaration mentions at least one of the method's type
                                             	      parameters, then the constraint reduces to the bound set
                                             	      <span class="type">B<sub>3</sub></span> which would be used to determine the method
                                             	      reference's invocation type when targeting the return
                                             	      type of the function type, as defined in
                                             	      <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>. <span class="type">B<sub>3</sub></span> may contain new
                                             	      inference variables, as well as dependencies between
                                             	      these new variables and the inference variables in
                                             	      <span class="type">T</span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.1-300-D-B-C"></a>
                                             	      Otherwise, let <span class="type">R</span> be the return type of the function type,
                                             	      and let <span class="type">R</span>' be the result of applying capture conversion
                                             	      (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>) to the return type of the
                                             	      invocation type (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>) of the
                                             	      compile-time declaration. If <span class="type">R</span>' is <code class="literal">void</code>, the constraint
                                             	      reduces to <span class="emphasis"><em>false</em></span>; otherwise, the constraint reduces to
                                             	      &#8249;<span class="type">R</span>' <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">The strategy used to determine a return type for a
                  generic referenced method follows the same pattern as for generic
                  method invocations (<a class="xref" href="jls-18.html#jls-18.2.1" title="18.2.1.&nbsp;Expression Compatibility Constraints">&sect;18.2.1</a>). This may involve
                  "lifting" bounds into the outer context and inferring dependencies
                  between the two sets of inference variables.
               </p>
            </div>
            <div class="section" title="18.2.2.&nbsp;Type Compatibility Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.2"></a>18.2.2.&nbsp;Type Compatibility Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.2-100"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is reduced
                  as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is compatible in a loose invocation context
                                 with <span class="type">T</span> (<a class="xref" href="jls-5.html#jls-5.3" title="5.3.&nbsp;Invocation Contexts">&sect;5.3</a>), and <span class="emphasis"><em>false</em></span>
                                 otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-B"></a>
                                 Otherwise, if <span class="type">S</span> is a primitive type, let <span class="type">S'</span> be the
                                 result of applying boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">S</span>. Then the constraint
                                 reduces to &#8249;<span class="type">S'</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-C"></a>
                                 Otherwise, if <span class="type">T</span> is a primitive type, let <span class="type">T'</span> be the
                                 result of applying boxing conversion
                                 (<a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>) to <span class="type">T</span>. Then the constraint
                                 reduces to &#8249;<span class="type">S</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-D"></a>
                                 Otherwise, if <span class="type">T</span> is a parameterized type of the form
                                 <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code>, and there exists no type of
                                 the form <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code> that is a supertype of <span class="type">S</span>, but
                                 the raw type <span class="type">G</span> is a supertype of <span class="type">S</span>, then the constraint
                                 reduces to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-E"></a>
                                 Otherwise, if <span class="type">T</span> is an array type of the form <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>,
                                 ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code><code class="literal">[]</code><sup>k</sup>, and
                                 there exists no type of the form
                                 <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code><code class="literal">[]</code><sup>k</sup>
                                 that is a supertype of <span class="type">S</span>, but the raw type
                                 <span class="type">G</span><code class="literal">[]</code><sup>k</sup> is a supertype of <span class="type">S</span>,
                                 then the constraint reduces to <span class="emphasis"><em>true</em></span>. (The notation
                                 <code class="literal">[]</code><sup>k</sup> indicates an array type
                                 of <span class="emphasis"><em>k</em></span> dimensions.)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.2-100-F"></a>
                                 Otherwise, the constraint reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code>
                                 <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.2-110"></a>The
                  fourth and fifth cases are implicit uses of unchecked conversion
                  (<a class="xref" href="jls-5.html#jls-5.1.9" title="5.1.9.&nbsp;Unchecked Conversion">&sect;5.1.9</a>). These, along with any use of unchecked
                  conversion in the first case, may result in compile-time unchecked
                  warnings, and may influence a method's invocation type
                  (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>).
               </p>
               <p class="note">Boxing <span class="type">T</span> to <span class="type">T'</span> is not
                  completeness-preserving; for example, if <span class="type">T</span> were <code class="literal">long</code>, <span class="type">S</span> might be
                  instantiated to <code class="literal">Integer</code>, which is not a subtype of <code class="literal">Long</code> but could
                  be unboxed and then widened to <code class="literal">long</code>. We avoid this problem in most
                  cases by giving special treatment to inference-variable return types
                  that we know are already constrained to be certain boxed primitive
                  types. See <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
               </p>
               <p class="note">Similarly, the treatment of unchecked conversion
                  sacrifices completeness in cases in which <span class="type">T</span> is not a parameterized
                  type (for example, if <span class="type">T</span> is an inference variable). It is not usually
                  clear in such situations whether the unchecked conversion is necessary
                  or not. Since unchecked conversions introduce unchecked warnings,
                  inference prefers to avoid them unless it is clearly necessary.
               </p>
            </div>
            <div class="section" title="18.2.3.&nbsp;Subtyping Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.3"></a>18.2.3.&nbsp;Subtyping Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.3-100"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250; is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is a subtype of <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.10" title="4.10.&nbsp;Subtyping">&sect;4.10</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-B"></a>
                                 Otherwise, if <span class="type">S</span> is the null type, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-C"></a>
                                 Otherwise, if <span class="type">T</span> is the null type, the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-D"></a>
                                 Otherwise, if <span class="type">S</span> is an inference variable, <span class="symbol">&#945;</span>, the
                                 constraint reduces to the bound <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-E"></a>
                                 Otherwise, if <span class="type">T</span> is an inference variable, <span class="symbol">&#945;</span>, the
                                 constraint reduces to the bound <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-100-F"></a>
                                 Otherwise, the constraint is reduced according to the form of
                                 <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-A"></a>
                                    	  If <span class="type">T</span> is a parameterized class or interface type, or an
                                    	  inner class type of a parameterized class or interface type
                                    	  (directly or indirectly), let <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span> be the type
                                    	  arguments of <span class="type">T</span>. Among the supertypes of <span class="type">S</span>, a
                                    	  corresponding class or interface type is identified, with
                                    	  type arguments <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span>. If no such type exists, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>. Otherwise, the constraint
                                    	  reduces to the following new constraints: for all <span class="emphasis"><em>i</em></span> (1
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">B<sub>i</sub></span> <code class="literal">&lt;=</code>
                                    	  <span class="type">A<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-B"></a>
                                    	  If <span class="type">T</span> is any other class or interface type, then the
                                    	  constraint reduces to <span class="emphasis"><em>true</em></span> if <span class="type">T</span> is among the
                                    	  supertypes of <span class="type">S</span>, and <span class="emphasis"><em>false</em></span> otherwise.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-C"></a>
                                    	  If <span class="type">T</span> is an array type, <span class="type">T'</span><code class="literal">[]</code>, then among the
                                    	  supertypes of <span class="type">S</span> that are array types, a most specific type
                                    	  is identified, <span class="type">S'</span><code class="literal">[]</code> (this may be <span class="type">S</span>
                                    	  itself). If no such array type exists, the constraint
                                    	  reduces to <span class="emphasis"><em>false</em></span>. Otherwise:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-C-A"></a>
                                             	      If neither <span class="type">S'</span> nor <span class="type">T'</span> is a primitive type, the
                                             	      constraint reduces to &#8249;<span class="type">S'</span> <code class="literal">&lt;:</code>
                                             	      <span class="type">T'</span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-C-B"></a>
                                             	      Otherwise, the constraint reduces to <span class="emphasis"><em>true</em></span> if <span class="type">S'</span>
                                             	      and <span class="type">T'</span> are the same primitive type, and <span class="emphasis"><em>false</em></span>
                                             	      otherwise.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-D"></a>
                                    	  If <span class="type">T</span> is a type variable, there are three cases:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-A"></a>
                                             	      If <span class="type">S</span> is an intersection type of which <span class="type">T</span> is an
                                             	      element, the constraint reduces to <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-B"></a>
                                             	      Otherwise, if <span class="type">T</span> has a lower bound, <span class="type">B</span>, the constraint
                                             	      reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">B</span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.2.3-100-F-D-C"></a>
                                             	      Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-100-F-E"></a>
                                    	  If <span class="type">T</span> is an intersection type, <span class="type">I<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code> <span class="type">I<sub>n</sub></span>,
                                    	  the constraint reduces to the following new constraints: for
                                    	  all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">S</span>
                                    	  <code class="literal">&lt;:</code> <span class="type">I<sub>i</sub></span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.3-200"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> <code class="literal">&lt;=</code> <span class="type">T</span>&#8250;, where
                  <span class="type">S</span> and <span class="type">T</span> are type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>), is
                  reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-A"></a>
                                 If <span class="type">T</span> is a type:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-A-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">S</span> =
                                    	  <span class="type">T</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-A-B"></a>
                                    	  If <span class="type">S</span> is a wildcard, the constraint reduces to
                                    	  <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-B"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code>, the constraint reduces
                                 to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-C"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T'</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-B"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code>, the constraint
                                    	  reduces to &#8249;<code class="literal">Object</code> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-C"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span>, the
                                    	  constraint reduces to &#8249;<span class="type">S'</span> <code class="literal">&lt;:</code> <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-C-D"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span>,
                                    	  the constraint reduces to &#8249;<code class="literal">Object</code> = <span class="type">T'</span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.3-200-D"></a>
                                 If <span class="type">T</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">T'</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-A"></a>
                                    	  If <span class="type">S</span> is a type, the constraint reduces to &#8249;<span class="type">T'</span>
                                    	  <code class="literal">&lt;:</code> <span class="type">S</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-B"></a>
                                    	  If <span class="type">S</span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span>,
                                    	  the constraint reduces to &#8249;<span class="type">T'</span> <code class="literal">&lt;:</code>
                                    	  <span class="type">S'</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.3-200-D-C"></a>
                                    	  Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="18.2.4.&nbsp;Type Equality Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.4"></a>18.2.4.&nbsp;Type Equality Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.4-100"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;, where <span class="type">S</span> and
                  <span class="type">T</span> are types, is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are proper types, the constraint reduces to
                                 <span class="emphasis"><em>true</em></span> if <span class="type">S</span> is the same as <span class="type">T</span>
                                 (<a class="xref" href="jls-4.html#jls-4.3.4" title="4.3.4.&nbsp;When Reference Types Are the Same">&sect;4.3.4</a>), and <span class="emphasis"><em>false</em></span> otherwise.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-B"></a>
                                 Otherwise, if <span class="type">S</span> or <span class="type">T</span> is the null type, the constraint
                                 reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-C"></a>
                                 Otherwise, if <span class="type">S</span> is an inference variable, <span class="symbol">&#945;</span>, and <span class="type">T</span> is
                                 not a primitive type, the constraint reduces to the bound
                                 <span class="symbol">&#945;</span> = <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-D"></a>
                                 Otherwise, if <span class="type">T</span> is an inference variable, <span class="symbol">&#945;</span>, and <span class="type">S</span> is
                                 not a primitive type, the constraint reduces to the bound <span class="type">S</span> =
                                 <span class="symbol">&#945;</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-E"></a>
                                 Otherwise, if <span class="type">S</span> and <span class="type">T</span> are class or interface types with the
                                 same erasure, where <span class="type">S</span> has type arguments <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span> and
                                 <span class="type">T</span> has type arguments <span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span>, the constraint reduces
                                 to the following new constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                 <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">B<sub>i</sub></span> = <span class="type">A<sub>i</sub></span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-F"></a>
                                 Otherwise, if <span class="type">S</span> and <span class="type">T</span> are array types, <span class="type">S'</span><code class="literal">[]</code>
                                 and <span class="type">T'</span><code class="literal">[]</code>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-100-G"></a>
                                 Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that we do not address intersection types
                  above, because it is impossible for reduction to encounter an
                  intersection type that is not a proper type.
               </p>
               <p class="norm-static"><a name="jls-18.2.4-200"></a>A
                  constraint formula of the form &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;, where <span class="type">S</span> and
                  <span class="type">T</span> are type arguments (<a class="xref" href="jls-4.html#jls-4.5.1" title="4.5.1.&nbsp;Type Arguments of Parameterized Types">&sect;4.5.1</a>), is reduced as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-A"></a>
                                 If <span class="type">S</span> and <span class="type">T</span> are types, the constraint is reduced as described
                                 above.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-B"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> and <span class="type">T</span> has the form <code class="literal">?</code>, the
                                 constraint reduces to <span class="emphasis"><em>true</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-C"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> and <span class="type">T</span> has the form <code class="literal">?</code> <code class="literal">extends</code>
                                 <span class="type">T'</span>, the constraint reduces to &#8249;<code class="literal">Object</code> =
                                 <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-D"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span> and <span class="type">T</span> has the
                                 form <code class="literal">?</code>, the constraint reduces to &#8249;<span class="type">S'</span> =
                                 <code class="literal">Object</code>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-E"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">S'</span> and <span class="type">T</span> has the
                                 form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T'</span>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-F"></a>
                                 If <span class="type">S</span> has the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">S'</span> and <span class="type">T</span> has the form
                                 <code class="literal">?</code> <code class="literal">super</code> <span class="type">T'</span>, the constraint reduces to
                                 &#8249;<span class="type">S'</span> = <span class="type">T'</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.4-200-G"></a>
                                 Otherwise, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="18.2.5.&nbsp;Checked Exception Constraints">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.2.5"></a>18.2.5.&nbsp;Checked Exception Constraints
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.2.5-100"></a>
                  A constraint formula of the form &#8249;<span class="emphasis"><em>LambdaExpression</em></span>
                  <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250; is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-A"></a>
                                 If <span class="type">T</span> is not a functional interface type
                                 (<a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-B"></a>
                                 Otherwise, let the target function type for the lambda
                                 expression be determined as specified in
                                 <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>. If no valid function type can be
                                 found, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-C"></a>
                                 Otherwise, if the lambda expression is implicitly typed, and one
                                 or more of the function type's parameter types is not a proper
                                 type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                        <p class="note">
                                 This condition never arises in practice, due to the substitution
                                 applied to the target type in <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-D"></a>
                                 Otherwise, if the function type's return type is neither <code class="literal">void</code>
                                 nor a proper type, the constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                        <p class="note">
                                 This condition never arises in practice, due to the substitution
                                 applied to the target type in <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-100-F"></a>
                                 Otherwise, let <span class="type">E<sub>1</sub></span>, ..., <span class="type">E<sub>n</sub></span> be the types in the function
                                 type's <code class="literal">throws</code> clause that are <span class="emphasis"><em>not</em></span> proper
                                 types. If the lambda expression is implicitly typed, let its
                                 parameter types be the function type's parameter types. If the
                                 lambda body is a poly expression or a block containing a poly
                                 result expression, let the targeted return type be the function
                                 type's return type. Let <span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>m</sub></span> be the checked exception
                                 types that the lambda body can throw
                                 (<a class="xref" href="jls-11.html#jls-11.2" title="11.2.&nbsp;Compile-Time Checking of Exceptions">&sect;11.2</a>). Then there are two cases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-100-F-A"></a>
                                    	  If <span class="emphasis"><em>n</em></span> = <code class="literal">0</code> (the function type's <code class="literal">throws</code> clause
                                    	  consists only of proper types), then if there exists some
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>) such that <span class="type">X<sub>i</sub></span> is not a
                                    	  subtype of any proper type in the <code class="literal">throws</code> clause, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>; otherwise, the constraint
                                    	  reduces to <span class="emphasis"><em>true</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-100-F-B"></a>
                                    	  If <span class="emphasis"><em>n</em></span> &gt; <code class="literal">0</code>, the constraint reduces to a set of
                                    	  subtyping constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    	  <span class="emphasis"><em>m</em></span>), if <span class="type">X<sub>i</sub></span> is not a subtype of any proper type in the
                                    	  <code class="literal">throws</code> clause, then the constraints include, for all
                                    	  <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">X<sub>i</sub></span> <code class="literal">&lt;:</code>
                                    	  <span class="type">E<sub>j</sub></span>&#8250;. In addition, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the constraint reduces to the bound <code class="literal">throws</code>
                                    	  <span class="type">E<sub>j</sub></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.2.5-200"></a>A
                  constraint formula of the form &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub>
                  <span class="type">T</span>&#8250; is reduced as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-A"></a>
                                 If <span class="type">T</span> is not a functional interface type, or if <span class="type">T</span> is a
                                 functional interface type but does not have a function type
                                 (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>), the constraint reduces to
                                 <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-B"></a>
                                 Otherwise, let the target function type for the method reference
                                 expression be the function type of <span class="type">T</span>. If the method reference
                                 is inexact (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>) and one or more of
                                 the function type's parameter types is not a proper type, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-C"></a>
                                 Otherwise, if the method reference is inexact and the function
                                 type's result is neither <code class="literal">void</code> nor a proper type, the
                                 constraint reduces to <span class="emphasis"><em>false</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.2.5-200-D"></a>
                                 Otherwise, let <span class="type">E<sub>1</sub></span>, ..., <span class="type">E<sub>n</sub></span> be the types in the function
                                 type's <code class="literal">throws</code> clause that are <span class="emphasis"><em>not</em></span> proper
                                 types. Let <span class="type">X<sub>1</sub></span>, ..., <span class="type">X<sub>m</sub></span> be the checked exceptions in the
                                 <code class="literal">throws</code> clause of the invocation type of the method reference's
                                 compile-time declaration (<a class="xref" href="jls-15.html#jls-15.13.2" title="15.13.2.&nbsp;Type of a Method Reference">&sect;15.13.2</a>) (as
                                 derived from the function type's parameter types and return
                                 type). Then there are two cases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-200-D-A"></a>
                                    	  If <span class="emphasis"><em>n</em></span> = <code class="literal">0</code> (the function type's <code class="literal">throws</code> clause
                                    	  consists only of proper types), then if there exists some
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>) such that <span class="type">X<sub>i</sub></span> is not a
                                    	  subtype of any proper type in the <code class="literal">throws</code> clause, the
                                    	  constraint reduces to <span class="emphasis"><em>false</em></span>; otherwise, the constraint
                                    	  reduces to <span class="emphasis"><em>true</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.2.5-200-D-B"></a>
                                    	  If <span class="emphasis"><em>n</em></span> &gt; <code class="literal">0</code>, the constraint reduces to a set of
                                    	  subtyping constraints: for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span>
                                    	  <span class="emphasis"><em>m</em></span>), if <span class="type">X<sub>i</sub></span> is not a subtype of any proper type in the
                                    	  <code class="literal">throws</code> clause, then the constraints include, for all
                                    	  <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">X<sub>i</sub></span> <code class="literal">&lt;:</code>
                                    	  <span class="type">E<sub>j</sub></span>&#8250;. In addition, for all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), the constraint reduces to the bound <code class="literal">throws</code>
                                    	  <span class="type">E<sub>j</sub></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="note">Constraints on checked exceptions are handled
                  separately from constraints on return types, because return type
                  compatibility influences applicability of methods
                  (<a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>), while exceptions only influence the
                  invocation type after overload resolution is complete
                  (<a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a>). This could be simplified by including
                  exception compatibility in the definition of lambda expression
                  compatibility (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>), but this would lead to
                  possibly surprising cases in which exceptions that can be thrown by an
                  explicitly typed lambda body change overload resolution.
               </p>
               <p class="note">The exceptions thrown by a lambda body cannot be
                  determined until i) the parameter types of the lambda are known, and
                  ii) the target type of result expressions in the body is known. (The
                  second requirement is to account for generic method invocations in
                  which, for example, the same type parameter appears in the return type
                  and the <code class="literal">throws</code> clause.) Hence, we require both of these, as derived
                  from the target type <span class="type">T</span>, to be proper types.
               </p>
               <p class="note">One consequence is that lambda expressions returned
                  from <span class="emphasis"><em>other</em></span> lambda expressions cannot generate
                  constraints from their thrown exceptions. These constraints can only
                  be generated from top-level lambda expressions.
               </p>
               <p class="note">Note that the handling of the case in which more
                  than one inference variable appears in a function type's <code class="literal">throws</code>
                  clause is not completeness-preserving.  Either variable may, on its
                  own, satisfy the constraint that each checked exception be declared,
                  but we cannot be sure which one is intended. So, for predictability,
                  we constrain them both.
               </p>
            </div>
         </div>
         <div class="section" title="18.3.&nbsp;Incorporation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.3"></a>18.3.&nbsp;Incorporation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.3-100"></a>
               As bound sets are constructed and grown during inference, it is
               possible that new bounds can be inferred based on the assertions of
               the original bounds. The process of <span class="emphasis"><em>incorporation</em></span>
               identifies these new bounds and adds them to the bound set.
            </p>
            <p class="norm-static"><a name="jls-18.3-110"></a>
               Incorporation can happen in two scenarios. One scenario is that the
               bound set contains complementary pairs of bounds; this implies new
               constraint formulas, as specified in <a class="xref" href="jls-18.html#jls-18.3.1" title="18.3.1.&nbsp;Complementary Pairs of Bounds">&sect;18.3.1</a>. The
               other scenario is that the bound set contains a bound involving
               capture conversion; this implies new bounds and may imply new
               constraint formulas, as specified in <a class="xref" href="jls-18.html#jls-18.3.2" title="18.3.2.&nbsp;Bounds Involving Capture Conversion">&sect;18.3.2</a>. In
               both scenarios, any new constraint formulas are reduced, and any new
               bounds are added to the bound set. This may trigger further
               incorporation; ultimately, the set will reach a fixed point and no
               further bounds can be inferred.
            </p>
            <p class="norm-static"><a name="jls-18.3-200"></a>
               If incorporation of a bound set has reached a fixed point, and the set
               does not contain the bound <span class="emphasis"><em>false</em></span>, then the bound set has the
               following properties:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-A"></a>
                              For each combination of a proper lower bound <code class="varname">L</code> and a proper
                              upper bound <span class="type">U</span> of an inference variable, <code class="varname">L</code> <code class="literal">&lt;:</code>
                              <span class="type">U</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-B"></a>
                              If every inference variable mentioned by a bound has an
                              instantiation, the bound is satisfied by the corresponding
                              substitution.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-200-C"></a>
                              Given a dependency <span class="symbol">&#945;</span> = <span class="symbol">&#946;</span>, every bound of <span class="symbol">&#945;</span>
                              matches a bound of <span class="symbol">&#946;</span>, and vice versa.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.3-300-D"></a>
                              Given a dependency <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="symbol">&#946;</span>, every lower bound
                              of <span class="symbol">&#945;</span> is a lower bound of <span class="symbol">&#946;</span>, and every upper bound of
                              <span class="symbol">&#946;</span> is an upper bound of <span class="symbol">&#945;</span>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The assertion that incorporation reaches a fixed
               point oversimplifies the matter slightly. Building on the work of
               Kennedy and Pierce,
               <span class="emphasis"><em><a class="link" href="http://research.microsoft.com/apps/pubs/default.aspx?id=64041" target="_top">On
                        Decidability of Nominal Subtyping with Variance</a></em></span>,
               this property can be proven by making the argument that the set of
               types that may appear in the bound set is finite.  The argument relies
               on two assumptions:
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">New capture variables are not generated when
                              reducing subtyping constraints (<a class="xref" href="jls-18.html#jls-18.2.3" title="18.2.3.&nbsp;Subtyping Constraints">&sect;18.2.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Expansive inheritance paths are not pursued.</p>
                  </li>
               </ul>
            </div>
            <p class="note">This specification does not currently guarantee
               these properties (it is imprecise about the handling of wildcards when
               reducing subtyping constraints, and does not detect expansive
               inheritance paths), but may do so in a future version. (This is not a
               new problem: the Java subtyping algorithm is also at risk of
               non-termination.)
            </p>
            <div class="section" title="18.3.1.&nbsp;Complementary Pairs of Bounds">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.3.1"></a>18.3.1.&nbsp;Complementary Pairs of Bounds
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.3.1-100"></a>
                  (In this section, <span class="type">S</span> and <span class="type">T</span> are inference variables or types, and
                  <span class="type">U</span> is a proper type. For conciseness, a bound of the form <span class="symbol">&#945;</span> =
                  <span class="type">T</span> may also match a bound of the form <span class="type">T</span> = <span class="symbol">&#945;</span>.)
               </p>
               <p class="norm-static"><a name="jls-18.3.1-200"></a>When a
                  bound set contains a pair of bounds that match one of the following
                  rules, a new constraint formula is implied:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-A"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="symbol">&#945;</span> = <span class="type">T</span> imply &#8249;<span class="type">S</span> = <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-B"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-C"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">S</span> and <span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> imply &#8249;<span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">S</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-D"></a>
                                 <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> and <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-E"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">U</span> and <span class="type">S</span> = <span class="type">T</span> imply &#8249;<span class="type">S</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code> = <span class="type">T</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code>&#8250;
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.1-200-F"></a>
                                 <span class="symbol">&#945;</span> = <span class="type">U</span> and <span class="type">S</span> <code class="literal">&lt;:</code> <span class="type">T</span> imply &#8249;<span class="type">S</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code> <code class="literal">&lt;:</code> <span class="type">T</span><code class="literal">[</code><span class="symbol">&#945;</span>:=<span class="type">U</span><code class="literal">]</code>&#8250;
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.3.1-300"></a>
                  When a bound set contains a pair of bounds <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">S</span> and
                  <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span>, and there exists a supertype of <span class="type">S</span> of the form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>n</sub></span><code class="literal">&gt;</code> and a supertype of <span class="type">T</span> of the form
                  <span class="type">G</span><code class="literal">&lt;</code><span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>n</sub></span><code class="literal">&gt;</code> (for some generic class or
                  interface, <span class="type">G</span>), then for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if
                  <span class="type">S<sub>i</sub></span> and <span class="type">T<sub>i</sub></span> are types (not wildcards), the constraint formula
                  &#8249;<span class="type">S<sub>i</sub></span> = <span class="type">T<sub>i</sub></span>&#8250; is implied.
               </p>
            </div>
            <div class="section" title="18.3.2.&nbsp;Bounds Involving Capture Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.3.2"></a>18.3.2.&nbsp;Bounds Involving Capture Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.3.2-100"></a>When a
                  bound set contains a bound of the form <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                  <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> = capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>), new
                  bounds are implied and new constraint formulas may be implied, as
                  follows.
               </p>
               <p class="norm-static"><a name="jls-18.3.2-200"></a>Let <span class="type">P<sub>1</sub></span>,
                  ..., <span class="type">P<sub>n</sub></span> represent the type parameters of <span class="type">G</span> and let <span class="type">B<sub>1</sub></span>, ..., <span class="type">B<sub>n</sub></span>
                  represent the bounds of these type parameters. Let <span class="symbol">&#952;</span> represent
                  the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>n</sub></span><code class="literal">]</code>.
                  Let <span class="type">R</span> be a type that is <span class="emphasis"><em>not</em></span> an inference
                  variable (but is not necessarily a proper type).
               </p>
               <p class="norm-static"><a name="jls-18.3.2-210"></a>
                  A set of bounds on <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> is implied, constructed
                  from the declared bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>n</sub></span> as specified in
                  <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
               </p>
               <p class="norm-static"><a name="jls-18.3.2-220"></a>
                  In addition, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-A"></a>
                                 If <span class="type">A<sub>i</sub></span> is not a wildcard, then the bound <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">A<sub>i</sub></span> is implied.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-B"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-B"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-B-C"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-C"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code> <code class="literal">extends</code> <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-B"></a>
                                    	  If <span class="type">B<sub>i</sub></span> is <code class="literal">Object</code>, then <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">T</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-C"></a>
                                    	  If <span class="type">T</span> is <code class="literal">Object</code>, then <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-C-D"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.3.2-220-D"></a>
                                 If <span class="type">A<sub>i</sub></span> is a wildcard of the form <code class="literal">?</code> <code class="literal">super</code> <span class="type">T</span>:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-A"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> = <span class="type">R</span> implies the bound <span class="emphasis"><em>false</em></span></p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-B"></a>
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">R</span> implies the constraint formula &#8249;<span class="type">B<sub>i</sub></span> <span class="symbol">&#952;</span> <code class="literal">&lt;:</code> <span class="type">R</span>&#8250;
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.3.2-220-D-C"></a>
                                    	  <span class="type">R</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> implies the constraint formula &#8249;<span class="type">R</span> <code class="literal">&lt;:</code> <span class="type">T</span>&#8250;
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="18.4.&nbsp;Resolution">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.4"></a>18.4.&nbsp;Resolution
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-18.4-100"></a>Given a
               bound set that does not contain the bound <span class="emphasis"><em>false</em></span>, a subset of the
               inference variables mentioned by the bound set may
               be <span class="emphasis"><em>resolved</em></span>. This means that a satisfactory
               instantiation may be added to the set for each inference variable,
               until all the requested variables have instantiations.
            </p>
            <p class="norm-static"><a name="jls-18.4-200"></a>
               Dependencies in the bound set may require that the variables be
               resolved in a particular order, or that additional variables be
               resolved. Dependencies are specified as follows:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-A"></a>
                              Given a bound of one of the following forms, where <span class="type">T</span> is either
                              an inference variable <span class="symbol">&#946;</span> or a type that mentions
                              <span class="symbol">&#946;</span>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-A"></a><span class="symbol">&#945;</span> = <span class="type">T</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-B"></a><span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <span class="type">T</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-C"></a><span class="type">T</span> = <span class="symbol">&#945;</span></p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-200-A-D"></a><span class="type">T</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span></p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-200-A.1"></a>
                              If <span class="symbol">&#945;</span> appears on the left-hand side of another bound of the
                              form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>), then <span class="symbol">&#946;</span> depends on the
                              resolution of <span class="symbol">&#945;</span>. Otherwise, <span class="symbol">&#945;</span> depends on the
                              resolution of <span class="symbol">&#946;</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-B"></a>
                              An inference variable <span class="symbol">&#945;</span> appearing on the left-hand side of
                              a bound of the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) depends on the resolution of
                              every other inference variable mentioned in this bound (on both
                              sides of the = sign).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-C"></a>
                              An inference variable <span class="symbol">&#945;</span> depends on the resolution of an
                              inference variable <span class="symbol">&#946;</span> if there exists an inference variable
                              <span class="symbol">&#947;</span> such that <span class="symbol">&#945;</span> depends on the resolution of <span class="symbol">&#947;</span>
                              and <span class="symbol">&#947;</span> depends on the resolution of <span class="symbol">&#946;</span>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-200-D"></a>
                              An inference variable <span class="symbol">&#945;</span> depends on the resolution of itself.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm-static"><a name="jls-18.4-300"></a>Given a set
               of inference variables to resolve, let <span class="type">V</span> be the union of this set
               and all variables upon which the resolution of at least one variable
               in this set depends.
            </p>
            <p class="norm-static"><a name="jls-18.4-310"></a>If every
               variable in <span class="type">V</span> has an instantiation, then resolution succeeds and
               this procedure terminates.
            </p>
            <p class="norm-static"><a name="jls-18.4-320"></a>Otherwise,
               let { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } be a non-empty subset of
               uninstantiated variables in <span class="type">V</span> such that i) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span>
               <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> depends on the resolution of a
               variable <span class="symbol">&#946;</span>, then either <span class="symbol">&#946;</span> has an instantiation or there is
               some <span class="emphasis"><em>j</em></span> such that <span class="symbol">&#946;</span> = <span class="symbol">&#945;</span><span class="type"><sub>j</sub></span>; and ii) there exists no
               non-empty proper subset of { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } with this
               property. Resolution proceeds by generating an instantiation for each
               of <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> based on the bounds in the bound
               set:
            </p>
            <div class="">
               <ul class="" type="disc">
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-320-A"></a>
                              If the bound set does not contain a bound of the form
                              <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                              <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), then a candidate instantiation <span class="type">T<sub>i</sub></span> is defined
                              for each <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-A"></a>
                                 	  If <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> has one or more <span class="emphasis"><em>proper</em></span>
                                 	  lower bounds, <code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>, then <span class="type">T<sub>i</sub></span> = lub(<code class="varname">L<sub>1</sub></code>, ...,
                                 	  <code class="varname">L<sub>k</sub></code>) (<a class="xref" href="jls-4.html#jls-4.10.4" title="4.10.4.&nbsp;Least Upper Bound">&sect;4.10.4</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-B"></a>
                                 	  Otherwise, if the bound set contains <code class="literal">throws</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, and
                                 	  the proper upper bounds of <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> are, at most,
                                 	  <code class="literal">Exception</code>, <code class="literal">Throwable</code>, and <code class="literal">Object</code>, then <span class="type">T<sub>i</sub></span> =
                                 	  <code class="literal">RuntimeException</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-A-C"></a>
                                 	  Otherwise, where <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> has <span class="emphasis"><em>proper</em></span>
                                 	  upper bounds <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>, <span class="type">T<sub>i</sub></span> = glb(<span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>)
                                 	  (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>).
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-320-A.1"></a>
                              The bounds <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span> = <span class="type">T<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> = <span class="type">T<sub>n</sub></span> are
                              incorporated with the current bound set.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-A.2"></a>
                              If the result does not contain the bound <span class="emphasis"><em>false</em></span>, then the
                              result becomes the new bound set, and resolution proceeds by
                              selecting a new set of variables to instantiate (if necessary),
                              as described above.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-A.3"></a>
                              Otherwise, the result contains the bound <span class="emphasis"><em>false</em></span>, so a second
                              attempt is made to instantiate { <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> } by
                              performing the step below.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm-static"><a name="jls-18.4-320-B"></a>
                              If the bound set contains a bound of the form <span class="type">G</span><code class="literal">&lt;</code>...,
                              <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> = capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) for some
                              <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), or;
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.1"></a>
                              If the bound set produced in the step above contains the bound
                              <span class="emphasis"><em>false</em></span>;
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.2"></a>
                              then let <span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span> be fresh type variables whose bounds
                              are as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-B.2-A"></a>
                                 	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), if <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>
                                 	  has one or more <span class="emphasis"><em>proper</em></span> lower bounds
                                 	  <code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>, then let the lower bound of <span class="type">Y<sub>i</sub></span> be
                                 	  lub(<code class="varname">L<sub>1</sub></code>, ..., <code class="varname">L<sub>k</sub></code>); if not, then <span class="type">Y<sub>i</sub></span> has no lower
                                 	  bound.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm-static"><a name="jls-18.4-320-B.2-B"></a>
                                 	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), where <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>
                                 	  has upper bounds <span class="type">U<sub>1</sub></span>, ..., <span class="type">U<sub>k</sub></span>, let the upper bound of
                                 	  <span class="type">Y<sub>i</sub></span> be glb(<span class="type">U<sub>1</sub></span> <span class="symbol">&#952;</span>, ..., <span class="type">U<sub>k</sub></span> <span class="symbol">&#952;</span>), where <span class="symbol">&#952;</span> is
                                 	  the substitution <code class="literal">[</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>:=<span class="type">Y<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span>:=<span class="type">Y<sub>n</sub></span><code class="literal">]</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-18.4-320-B.3"></a>
                              If the type variables <span class="type">Y<sub>1</sub></span>, ..., <span class="type">Y<sub>n</sub></span> do not have well-formed
                              bounds (that is, a lower bound is not a subtype of an upper
                              bound, or an intersection type is inconsistent), then resolution
                              fails.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.4"></a>
                              Otherwise, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), all
                              bounds of the form <span class="type">G</span><code class="literal">&lt;</code>..., <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, ...<code class="literal">&gt;</code> =
                              capture(<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>) are removed from the current
                              bound set, and the bounds <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span> = <span class="type">Y<sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>n</sub></span> = <span class="type">Y<sub>n</sub></span>
                              are incorporated.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.5"></a>
                              If the result does not contain the bound <span class="emphasis"><em>false</em></span>, then the
                              result becomes the new bound set, and resolution proceeds by
                              selecting a new set of variables to instantiate (if necessary),
                              as described above.
                     </p>
                     <p class="norm-static"><a name="jls-18.4-320-B.6"></a>
                              Otherwise, the result contains the bound <span class="emphasis"><em>false</em></span>, and
                              resolution fails.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">The first method of instantiating an inference
               variable derives the instantiation from that variable's
               bounds. Sometimes, however, complex dependencies mean that the result
               is not within the variable's bounds. In that case, a different method
               of instantiation is performed, analogous to capture conversion
               (<a class="xref" href="jls-5.html#jls-5.1.10" title="5.1.10.&nbsp;Capture Conversion">&sect;5.1.10</a>): fresh type variables are introduced,
               with bounds derived from the bounds of the inference variables. Note
               that the lower bounds of these "capture" variables are computed using
               only proper types: this is important in order to avoid attempts to
               perform typing computations on uninstantiated type variables.
            </p>
         </div>
         <div class="section" title="18.5.&nbsp;Uses of Inference">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-18.5"></a>18.5.&nbsp;Uses of Inference
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm">Using the inference processes defined above, the
               following analyses are performed at compile time.
            </p>
            <div class="section" title="18.5.1.&nbsp;Invocation Applicability Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.1"></a>18.5.1.&nbsp;Invocation Applicability Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.1-100"></a>Given a
                  method invocation that provides no explicit type arguments, the
                  process to determine whether a potentially applicable generic method
                  <code class="varname">m</code> is applicable is as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-A"></a>
                                 Where <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span> (<span class="emphasis"><em>p</em></span> <span class="symbol">&#8805;</span> 1) are the type parameters
                                 of <code class="varname">m</code>, let <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span> be inference variables, and
                                 let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                                 <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-B"></a>
                                 An initial bound set, <span class="type">B<sub>0</sub></span>, is constructed from the declared
                                 bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, as described in
                                 <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-C"></a>
                                 For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>p</em></span>), if <span class="type">P<sub>i</sub></span> appears in
                                 the <code class="literal">throws</code> clause of <code class="varname">m</code>, then the bound <code class="literal">throws</code> <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span> is
                                 implied. These bounds, if any, are incorporated with <span class="type">B<sub>0</sub></span> to
                                 produce a new bound set, <span class="type">B<sub>1</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-D"></a>
                                 A set of constraint formulas, <span class="type">C</span>, is constructed as follows.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.1-100-D.1"></a>
                                 Let <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>n</sub></span> be the formal parameter types of <code class="varname">m</code>, and
                                 let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the
                                 invocation. Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A"></a>
                                    	  To test for <span class="emphasis"><em>applicability by strict invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A.1"></a>
                                    	  If <span class="emphasis"><em>k</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>n</em></span>, or if there exists an <span class="emphasis"><em>i</em></span> (1
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>) such that <code class="varname">e<sub>i</sub></code> is pertinent to
                                    	  applicability (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) and either
                                    	  i) <code class="varname">e<sub>i</sub></code> is a standalone expression of a primitive type but
                                    	  <span class="type">F<sub>i</sub></span> is a reference type, or ii) <span class="type">F<sub>i</sub></span> is a primitive type
                                    	  but <code class="varname">e<sub>i</sub></code> is not a standalone expression of a primitive type;
                                    	  then the method is not applicable and there is no need to
                                    	  proceed with inference.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-A.2"></a>
                                    	  Otherwise, <span class="type">C</span> includes, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent to applicability,
                                    	  &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B"></a>
                                    	  To test for <span class="emphasis"><em>applicability by loose invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B.1"></a>
                                    	  If <span class="emphasis"><em>k</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>n</em></span>, the method is not applicable and
                                    	  there is no need to proceed with inference.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-B.2"></a>
                                    	  Otherwise, <span class="type">C</span> includes, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span>
                                    	  <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent to applicability,
                                    	  &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-C"></a>
                                    	  To test for <span class="emphasis"><em>applicability by variable arity invocation</em></span>:
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.1-100-D.1-C.1"></a>
                                    	  Let <span class="type">F'<sub>1</sub></span>, ..., <span class="type">F'<sub>k</sub></span> be the first <span class="emphasis"><em>k</em></span> variable
                                    	  arity parameter types of <code class="varname">m</code>
                                    	  (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>).  <span class="type">C</span> includes, for all
                                    	  <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>) where <code class="varname">e<sub>i</sub></code> is pertinent
                                    	  to applicability, &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span> <span class="type">F'<sub>i</sub></span>
                                    	  <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-E"></a>
                                 <span class="type">C</span> is reduced (<a class="xref" href="jls-18.html#jls-18.2" title="18.2.&nbsp;Reduction">&sect;18.2</a>) and the resulting
                                 bounds are incorporated with <span class="type">B<sub>1</sub></span> to produce a new bound set,
                                 <span class="type">B<sub>2</sub></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.1-100-F"></a>
                                 Finally, the method <code class="varname">m</code> is applicable if <span class="type">B<sub>2</sub></span> does not contain
                                 the bound <span class="emphasis"><em>false</em></span> and resolution of all the inference
                                 variables in <span class="type">B<sub>2</sub></span> succeeds (<a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a>).
                        </p>
                     </li>
                  </ul>
               </div>
               <div class="informalexample">
                  <p class="note">Consider the following method invocation and
                     assignment:
                  </p><pre class="screen">List&lt;Number&gt; ln = Arrays.asList(1, 2.0);</pre><p class="note">A most specific applicable method for the invocation
                     must be identified as described in <a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>. The
                     only potentially applicable method (<a class="xref" href="jls-15.html#jls-15.12.2.1" title="15.12.2.1.&nbsp;Identify Potentially Applicable Methods">&sect;15.12.2.1</a>)
                     is declared as follows:
                  </p><pre class="screen">public static &lt;T&gt; List&lt;T&gt; asList(T... a)</pre><p class="note">Trivially (because of its arity), this method is
                     neither applicable by strict invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>) nor applicable by loose invocation
                     (<a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>). But since there are no other
                     candidates, in a third phase the method is checked for applicability
                     by variable arity invocation.
                  </p>
                  <p class="note">The initial bound set, <span class="type">B</span>, is a trivial upper bound
                     for a single inference variable, <span class="symbol">&#945;</span>:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code> }
                  </p>
                  <p class="note">The initial constraint formula set is as follows:</p>
                  <p class="note">{ &#8249;<code class="literal">1</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250;,
                     &#8249;<code class="literal">2.0</code> <span class="symbol">&#8594;</span> <span class="symbol">&#945;</span>&#8250; }
                  </p>
                  <p class="note">These are reduced to a new bound set, <span class="type">B<sub>1</sub></span>:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                     <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                     <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> }
                  </p>
                  <p class="note">Then, to test whether the method is applicable, we
                     attempt to resolve these bounds.  We succeed, producing the rather
                     complex instantiation
                  </p>
                  <p class="note"><span class="symbol">&#945;</span> = <code class="literal">Number &amp; Comparable&lt;?
                        extends Number &amp; Comparable&lt;?&gt;&gt;</code></p>
                  <p class="note">We have thus demonstrated that the method is
                     applicable; since no other candidates exist, it is the most specific
                     applicable method. Still, the type of the method invocation, and its
                     compatibility with the target type in the assignment, is not
                     determined until further inference can occur, as described in the next
                     section.
                  </p>
               </div>
            </div>
            <div class="section" title="18.5.2.&nbsp;Invocation Type Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.2"></a>18.5.2.&nbsp;Invocation Type Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.2-100"></a>Given a
                  method invocation that provides no explicit type arguments, and a
                  corresponding most specific applicable generic method <code class="varname">m</code>, the process
                  to infer the invocation type (<a class="xref" href="jls-15.html#jls-15.12.2.6" title="15.12.2.6.&nbsp;Method Invocation Type">&sect;15.12.2.6</a>) of the
                  chosen method is as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-A"></a>
                                 Let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                                 <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code> defined in <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>
                                 to replace the type parameters of <code class="varname">m</code> with inference
                                 variables.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-B"></a>
                                 Let <span class="type">B<sub>2</sub></span> be the bound set produced by reduction in order to
                                 demonstrate that <code class="varname">m</code> is applicable in
                                 <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>. (While it was necessary in
                                 <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a> to demonstrate that the inference
                                 variables in <span class="type">B<sub>2</sub></span> could be resolved, in order to establish
                                 applicability, the instantiations produced by this resolution
                                 step are <span class="emphasis"><em>not</em></span> considered part of <span class="type">B<sub>2</sub></span>.)
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-C"></a>
                                 If the invocation is not a poly expression, let the bound set
                                 <span class="type">B<sub>3</sub></span> be the same as <span class="type">B<sub>2</sub></span>.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.2-100-C.1"></a>
                                 If the invocation is a poly expression, let the bound set <span class="type">B<sub>3</sub></span>
                                 be derived from <span class="type">B<sub>2</sub></span> as follows. Let <span class="type">R</span> be the return type of
                                 <code class="varname">m</code>, let <span class="type">T</span> be the invocation's target type, and then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-C.1-A"></a>
                                    	  If unchecked conversion was necessary for the method to be
                                    	  applicable during constraint set reduction in
                                    	  <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>, the constraint formula
                                    	  &#8249;|<span class="type">R</span>| <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is reduced and incorporated
                                    	  with <span class="type">B<sub>2</sub></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-C.1-B"></a>
                                    	  Otherwise, if <span class="type">R</span> <span class="symbol">&#952;</span> is a parameterized type,
                                    	  <span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>, and one of <span class="type">A<sub>1</sub></span>, ...,
                                    	  <span class="type">A<sub>n</sub></span> is a wildcard, then, for fresh inference variables
                                    	  <span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span>, the constraint formula
                                    	  &#8249;<span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> <span class="symbol">&#8594;</span>
                                    	  <span class="type">T</span>&#8250; is reduced and incorporated, along with the bound
                                    	  <span class="type">G</span><code class="literal">&lt;</code><span class="symbol">&#946;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#946;</span><span class="type"><sub>n</sub></span><code class="literal">&gt;</code> =
                                    	  capture(<span class="type">G</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>n</sub></span><code class="literal">&gt;</code>), with
                                    	  <span class="type">B<sub>2</sub></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-C.1-C"></a>
                                    	  Otherwise, if <span class="type">R</span> <span class="symbol">&#952;</span> is an inference variable <span class="symbol">&#945;</span>,
                                    	  and one of the following is true:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-C.1-C-A"></a>
                                             	      <span class="type">T</span> is a reference type, but is not a
                                             	      wildcard-parameterized type, and either i) <span class="type">B<sub>2</sub></span> contains
                                             	      a bound of one of the forms <span class="symbol">&#945;</span> = <span class="type">S</span> or <span class="type">S</span>
                                             	      <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where <span class="type">S</span> is a wildcard-parameterized
                                             	      type, or ii) <span class="type">B<sub>2</sub></span> contains two bounds of the forms <span class="type">S<sub>1</sub></span>
                                             	      <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> and <span class="type">S<sub>2</sub></span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where <span class="type">S<sub>1</sub></span>
                                             	      and <span class="type">S<sub>2</sub></span> have supertypes that are two different
                                             	      parameterizations of the same generic class or
                                             	      interface.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-C.1-C-B"></a>
                                             	      <span class="type">T</span> is a parameterization of a generic class or
                                             	      interface, <span class="type">G</span>, and <span class="type">B<sub>2</sub></span> contains a bound of one of the
                                             	      forms <span class="symbol">&#945;</span> = <span class="type">S</span> or <span class="type">S</span> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, where
                                             	      there exists no type of the form <span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>
                                             	      that is a supertype of <span class="type">S</span>, but the raw type
                                             	      |<span class="type">G</span><code class="literal">&lt;</code>...<code class="literal">&gt;</code>| is a supertype of <span class="type">S</span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-C.1-C-C"></a>	    
                                             	      <span class="type">T</span> is a primitive type, and one of the primitive
                                             	      wrapper classes mentioned in <a class="xref" href="jls-5.html#jls-5.1.7" title="5.1.7.&nbsp;Boxing Conversion">&sect;5.1.7</a>
                                             	      is an instantiation, upper bound, or lower bound for
                                             	      <span class="symbol">&#945;</span> in <span class="type">B<sub>2</sub></span>.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                                 <p class="norm-static"><a name="jls-18.5.2-100-C.1-C.1"></a>
                                    	  then <span class="symbol">&#945;</span> is resolved in <span class="type">B<sub>2</sub></span>, and where the capture of
                                    	  the resulting instantiation of <span class="symbol">&#945;</span> is <span class="type">U</span>, the
                                    	  constraint formula &#8249;<span class="type">U</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; is reduced
                                    	  and incorporated with <span class="type">B<sub>2</sub></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-C-D"></a>
                                    	  Otherwise, the constraint formula &#8249;<span class="type">R</span> <span class="symbol">&#952;</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; 
                                    	  is reduced and incorporated with <span class="type">B<sub>2</sub></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-D"></a>
                                 A set of constraint formulas, <span class="type">C</span>, is constructed as follows.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.2-100-D.1"></a>
                                 Let <code class="varname">e<sub>1</sub></code>, ..., <code class="varname">e<sub>k</sub></code> be the actual argument expressions of the
                                 invocation. If <code class="varname">m</code> is applicable by strict or loose invocation,
                                 let <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>k</sub></span> be the formal parameter types of <code class="varname">m</code>; if <code class="varname">m</code>
                                 is applicable by variable arity invocation, let <span class="type">F<sub>1</sub></span>, ..., <span class="type">F<sub>k</sub></span>
                                 the first <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m</code>
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>). Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-D.1-A"></a>
                                    	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), if <code class="varname">e<sub>i</sub></code> is not
                                    	  pertinent to applicability, <span class="type">C</span> contains &#8249;<code class="varname">e<sub>i</sub></code> <span class="symbol">&#8594;</span>
                                    	  <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-D.1-B"></a>
                                    	  For all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), additional
                                    	  constraints may be included, depending on the form of <code class="varname">e<sub>i</sub></code>:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A"></a>	    
                                             	      If <code class="varname">e<sub>i</sub></code> is a <span class="emphasis"><em>LambdaExpression</em></span>,
                                             	      <span class="type">C</span> contains &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                          </p>
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1"></a>
                                             	      In addition, the lambda body is searched for additional constraints:
                                          </p>
                                          <div class="norm">
                                             <ul class="norm" type="disc">
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1-A"></a>
                                                      		  For a block lambda body,
                                                      		  the search is applied recursively to each result expression.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1-B"></a>
                                                      		  For a poly class instance creation expression
                                                      		  (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or a poly method
                                                      		  invocation expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>),
                                                      		  <span class="type">C</span> contains all the constraint formulas that would
                                                      		  appear in the set <span class="type">C</span> generated by
                                                      		  <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a> when inferring the poly
                                                      		  expression's invocation type.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1-C"></a>
                                                      		  For a parenthesized expression,
                                                      		  the search is applied recursively to the contained expression.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1-D"></a>
                                                      		  For a conditional expression,
                                                      		  the search is applied recursively to the second and third operands.
                                                   </p>
                                                </li>
                                                <li class="listitem">
                                                   <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-A.1-E"></a>
                                                      		  For a lambda expression,
                                                      		  the search is applied recursively to the lambda body.
                                                   </p>
                                                </li>
                                             </ul>
                                          </div>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-B"></a>
                                             	      If <code class="varname">e<sub>i</sub></code> is a <span class="emphasis"><em>MethodReference</em></span>,
                                             	      <span class="type">C</span> contains &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">F<sub>i</sub></span> <span class="symbol">&#952;</span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-C"></a>
                                             	      If <code class="varname">e<sub>i</sub></code> is a poly class instance creation expression
                                             	      (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or a poly method invocation
                                             	      expression (<a class="xref" href="jls-15.html#jls-15.12" title="15.12.&nbsp;Method Invocation Expressions">&sect;15.12</a>), <span class="type">C</span> contains
                                             	      all the constraint formulas that would appear in the set
                                             	      <span class="type">C</span> generated by <a class="xref" href="jls-18.html#jls-18.5.2" title="18.5.2.&nbsp;Invocation Type Inference">&sect;18.5.2</a> when
                                             	      inferring the poly expression's invocation type.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-D"></a>
                                             	      If <code class="varname">e<sub>i</sub></code> is a parenthesized expression,
                                             	      these rules are applied recursively to the contained expression.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-D.1-B-E"></a>
                                             	      If <code class="varname">e<sub>i</sub></code> is a conditional expression,
                                             	      these rules are applied recursively to the second and third operands.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-E"></a>
                                 While <span class="type">C</span> is not empty, the following process is repeated,
                                 starting with the bound set <span class="type">B<sub>3</sub></span> and accumulating new bounds
                                 into a "current" bound set, ultimately producing a new bound
                                 set, <span class="type">B<sub>4</sub></span>:
                        </p>
                        <div class="orderedlist">
                           <ol class="orderedlist" type="1">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-A"></a>
                                    	  A subset of constraints is selected in <span class="type">C</span>, satisfying the
                                    	  property that, for each constraint, no input variable
                                    	  can influence an output variable of another
                                    	  constraint in <span class="type">C</span>. The terms <span class="emphasis"><em>input
                                          	  variable</em></span> and <span class="emphasis"><em>output variable</em></span>
                                    	  are defined below. An inference variable
                                    	  <span class="symbol">&#945;</span> <span class="emphasis"><em>can influence</em></span> an inference
                                    	  variable <span class="symbol">&#946;</span> if <span class="symbol">&#945;</span> depends on the resolution of
                                    	  <span class="symbol">&#946;</span> (<a class="xref" href="jls-18.html#jls-18.4" title="18.4.&nbsp;Resolution">&sect;18.4</a>), or vice versa; or if
                                    	  there exists a third inference variable <span class="symbol">&#947;</span> such that
                                    	  <span class="symbol">&#945;</span> can influence <span class="symbol">&#947;</span> and <span class="symbol">&#947;</span> can influence
                                    	  <span class="symbol">&#946;</span>.
                                 </p>
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-A.1"></a>
                                    	  If this subset is empty, then there is a cycle (or cycles)
                                    	  in the graph of dependencies between constraints. In this
                                    	  case, all constraints are considered that participate in a
                                    	  dependency cycle (or cycles) and do not depend on any
                                    	  constraints outside of the cycle (or cycles). A single
                                    	  constraint is selected from the considered constraints, as
                                    	  follows:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="circle">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-E-A.1-A"></a>
                                             	      If any of the considered constraints have the form
                                             	      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, then the selected
                                             	      constraint is the considered constraint of this form
                                             	      that contains the expression to the left
                                             	      (<a class="xref" href="jls-3.html#jls-3.5" title="3.5.&nbsp;Input Elements and Tokens">&sect;3.5</a>) of the expression of every
                                             	      other considered constraint of this form.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.2-100-E-A.1-B"></a>
                                             	      If no considered constraint has the form
                                             	      &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, then the selected
                                             	      constraint is the considered constraint that contains
                                             	      the expression to the left of the expression of every
                                             	      other considered constraint.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-B"></a>
                                    	  The selected constraint(s) are removed from <span class="type">C</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-C"></a>
                                    	  The input variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span> of all the
                                    	  selected constraint(s) are resolved.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-D"></a>
                                    	  Where <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>m</sub></span> are the instantiations of <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>,
                                    	  ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span>, the substitution <code class="literal">[</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>, ...,
                                    	  <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span>:=<span class="type">T<sub>m</sub></span><code class="literal">]</code> is applied to every constraint.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-E-E"></a>
                                    	  The constraint(s) resulting from substitution are reduced
                                    	  and incorporated with the current bound set.
                                 </p>
                              </li>
                           </ol>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-100-F"></a>
                                 Finally, if <span class="type">B<sub>4</sub></span> does not contain the bound <span class="emphasis"><em>false</em></span>, the
                                 inference variables in <span class="type">B<sub>4</sub></span> are resolved.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.2-100-F.1"></a>
                                 If resolution succeeds with instantiations <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>p</sub></span> for
                                 inference variables <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span>, let <span class="symbol">&#952;</span>' be
                                 the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="type">T<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>:=<span class="type">T<sub>p</sub></span><code class="literal">]</code>. Then:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-F.1-A"></a>
                                    	  If unchecked conversion was necessary for the method to be
                                    	  applicable during constraint set reduction in
                                    	  <a class="xref" href="jls-18.html#jls-18.5.1" title="18.5.1.&nbsp;Invocation Applicability Inference">&sect;18.5.1</a>, then the parameter types of
                                    	  the invocation type of <code class="varname">m</code> are obtained by applying
                                    	  <span class="symbol">&#952;</span>' to the parameter types of <code class="varname">m</code>'s type, and the
                                    	  return type and thrown types of the invocation type of <code class="varname">m</code>
                                    	  are given by the erasure of the return type and thrown types
                                    	  of <code class="varname">m</code>'s type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-100-F.1-B"></a>
                                    	  If unchecked conversion was not necessary for the method to
                                    	  be applicable, then the invocation type of <code class="varname">m</code> is obtained
                                    	  by applying <span class="symbol">&#952;</span>' to the type of <code class="varname">m</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-error"><a name="jls-18.5.2-100-F.2"></a>
                                 If <span class="type">B<sub>4</sub></span> contains the bound <span class="emphasis"><em>false</em></span>, or if resolution fails,
                                 then a compile-time error occurs.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.5.2-200"></a>
                  Invocation type inference may require carefully sequencing the
                  reduction of constraint formulas of the forms &#8249;<span class="emphasis"><em>Expression</em></span>
                  <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;,
                  and &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;. To facilitate
                  this sequencing, the <span class="emphasis"><em>input variables</em></span> of these
                  constraints are defined as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-A"></a>
                                 For &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-A-A"></a>
                                    	  If <span class="type">T</span> is an inference variable, it is the (only) input
                                    	  variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-A-B"></a>
                                    	  If <span class="type">T</span> is a functional interface type, and a function type
                                    	  can be derived from <span class="type">T</span> (<a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>),
                                    	  then the input variables include i) if the lambda expression
                                    	  is implicitly typed, the inference variables mentioned by
                                    	  the function type's parameter types; and ii) if the function
                                    	  type's return type, <span class="type">R</span>, is not <code class="literal">void</code>, then for each result
                                    	  expression <code class="varname">e</code> in the lambda body (or for the body itself if
                                    	  it is an expression), the input variables of &#8249;<code class="varname">e</code>
                                    	  <span class="symbol">&#8594;</span> <span class="type">R</span>&#8250;.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-A-C"></a>
                                    	  Otherwise, there are no input variables.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-B"></a>
                                 For &#8249;<span class="emphasis"><em>LambdaExpression</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-B-A"></a>
                                    	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-B-B"></a>
                                    	  If <span class="type">T</span> is a functional interface type, and a function type
                                    	  can be derived, as described in
                                    	  <a class="xref" href="jls-15.html#jls-15.27.3" title="15.27.3.&nbsp;Type of a Lambda Expression">&sect;15.27.3</a>, the input variables include
                                    	  i) if the lambda expression is implicitly typed, the
                                    	  inference variables mentioned by the function type's
                                    	  parameter types; and ii) the inference variables mentioned
                                    	  by the function type's return type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-B-C"></a>
                                    	  Otherwise, there are no input variables.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-C"></a>
                                 For &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-C-A"></a>
                                    	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-C-B"></a>
                                    	  If <span class="type">T</span> is a functional interface type with a function type,
                                    	  and if the method reference is inexact
                                    	  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), the input variables are the
                                    	  inference variables mentioned by the function type's
                                    	  parameter types.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-C-C"></a>
                                    	  Otherwise, there are no input variables.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-D"></a>
                                 For &#8249;<span class="emphasis"><em>MethodReference</em></span> <span class="symbol">&#8594;</span><sub><span class="emphasis"><em>throws</em></span></sub> <span class="type">T</span>&#8250;:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-D-A"></a>
                                    	  If <span class="type">T</span> is an inference variable, it is the (only) input variable.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-D-B"></a>
                                    	  If <span class="type">T</span> is a functional interface type with a function type,
                                    	  and if the method reference is inexact
                                    	  (<a class="xref" href="jls-15.html#jls-15.13.1" title="15.13.1.&nbsp;Compile-Time Declaration of a Method Reference">&sect;15.13.1</a>), the input variables are the
                                    	  inference variables mentioned by the function type's
                                    	  parameter types and the function type's return type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.2-200-D-C"></a>
                                    	  Otherwise, there are no input variables.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-E"></a>
                                 For &#8249;<span class="emphasis"><em>Expression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, if <span class="emphasis"><em>Expression</em></span> is a
                                 parenthesized expression:
                        </p>
                        <p class="norm-static"><a name="jls-18.5.2-200-E.1"></a>
                                 Where the contained expression of <span class="emphasis"><em>Expression</em></span> is <span class="emphasis"><em>Expression</em></span>',
                                 the input variables are the input variables of
                                 &#8249;<span class="emphasis"><em>Expression</em></span>' <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-F"></a>
                                 For &#8249;<span class="emphasis"><em>ConditionalExpression</em></span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;:
                        </p>
                        <p class="norm-static"><a name="jls-18.5.2-200-F.1"></a>
                                 Where the conditional expression has the form <code class="varname">e<sub>1</sub></code> <code class="literal">?</code> <code class="varname">e<sub>2</sub></code>
                                 <code class="literal">:</code> <code class="varname">e<sub>3</sub></code>, the input variables are the input variables of
                                 &#8249;<code class="varname">e<sub>2</sub></code> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250; and &#8249;<code class="varname">e<sub>3</sub></code> <span class="symbol">&#8594;</span>
                                 <span class="type">T</span>&#8250;.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.2-200-G"></a>
                                 For all other constraint formulas, there are no input variables.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.5.2-300"></a>
                  The <span class="emphasis"><em>output variables</em></span> of these constraints are all
                  inference variables mentioned by the type on the right-hand side of
                  the constraint, <span class="type">T</span>, that are not input variables.
               </p>
               <p class="note">It is important to note that two "rounds" of
                  inference are involved in finding the type of a method
                  invocation. This is necessary to allow a target type to influence the
                  type of the invocation without allowing it to influence the choice of
                  an applicable method. The first round produces a bound set and tests
                  that a resolution exists, but does not commit to that resolution. The
                  second round reduces additional constraints and then performs a second
                  resolution, this time "for real".
               </p>
               <div class="informalexample">
                  <p class="note">Consider the example from the previous section:</p><pre class="screen">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code> ln = Arrays.asList(1, 2.0);</pre><p class="note">The most specific applicable method was identified as:</p><pre class="screen">public static <code class="literal">&lt;</code>T<code class="literal">&gt;</code> List<code class="literal">&lt;</code>T<code class="literal">&gt;</code> asList(T... a)</pre><p class="note">In order to complete type-checking of the method
                     invocation, we must determine whether it is compatible with its target
                     type, <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>.
                  </p>
                  <p class="note">The bound set used to demonstrate applicability in
                     the previous section, <span class="type">B<sub>2</sub></span>, was:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                     <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                     <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span> }
                  </p>
                  <p class="note">The new constraint formula set is as follows:</p>
                  <p class="note">{ &#8249;<code class="literal">List<code class="literal">&lt;</code><span class="symbol">&#945;</span><code class="literal">&gt;</code></code> <span class="symbol">&#8594;</span> <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>&#8250; }
                  </p>
                  <p class="note">This compatibility constraint produces an equality
                     bound for <span class="symbol">&#945;</span>, which is included in the new bound set, <span class="type">B<sub>3</sub></span>:
                  </p>
                  <p class="note">{ <span class="symbol">&#945;</span> <code class="literal">&lt;:</code> <code class="literal">Object</code>, 
                     <code class="literal">Integer</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                     <code class="literal">Double</code> <code class="literal">&lt;:</code> <span class="symbol">&#945;</span>, 
                     <span class="symbol">&#945;</span> = <code class="literal">Number</code> }
                  </p>
                  <p class="note">These bounds are trivially resolved:</p>
                  <p class="note"><span class="symbol">&#945;</span> = <code class="literal">Number</code></p>
                  <p class="note">Finally, we perform a substitution on the declared
                     return type of <code class="literal">asList</code> to determine that the method
                     invocation has type <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>;
                     clearly, this is compatible with the target type.
                  </p>
                  <p class="note">This inference strategy is different than the Java
                     SE 7 Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>, which would have instantiated <span class="symbol">&#945;</span> based
                     on its lower bounds (before even considering the invocation's target
                     type), as we did in the previous section. This would result in a type
                     error, since the resulting type is not a subtype
                     of <code class="literal">List<code class="literal">&lt;</code>Number<code class="literal">&gt;</code></code>.
                  </p>
               </div>
               <p class="note">Under various special circumstances, based on the
                  bounds appearing in <span class="type">B<sub>2</sub></span>, we eagerly resolve an inference variable
                  that appears as the return type of the invocation. This is to avoid
                  unfortunate situations in which the usual constraint, 
                  &#8249;<span class="type">R</span> <span class="symbol">&#952;</span> <span class="symbol">&#8594;</span> <span class="type">T</span>&#8250;, is not completeness-preserving. 
                  It is, unfortunately, possible that by eagerly resolving the variable,
                  we are unable to make use of bounds that would be inferred later. It
                  is also possible that, in some cases, bounds that will later be
                  inferred from the invocation arguments (such as implicitly typed
                  lambda expressions) would have caused a different outcome if they had
                  been present in <span class="type">B<sub>2</sub></span>. Despite these limitations, the strategy allows
                  for reasonable outcomes in typical use cases, and is backwards
                  compatible with the algorithm in the Java SE 7 Edition of
                  <em class="citetitle">The <span class="trademark">Java</span>&reg; Language Specification</em>.
               </p>
            </div>
            <div class="section" title="18.5.3.&nbsp;Functional Interface Parameterization Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.3"></a>18.5.3.&nbsp;Functional Interface Parameterization Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.3-100"></a>
                  Where a lambda expression with explicit parameter types <span class="type">P<sub>1</sub></span>, ...,
                  <span class="type">P<sub>n</sub></span> targets a functional interface type <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ...,
                  <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code> with at least one wildcard type argument, then a
                  parameterization of <span class="type">F</span> may be derived as the ground target type of
                  the lambda expression as follows.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-200"></a>
                  Let <span class="type">Q<sub>1</sub></span>, ..., <span class="type">Q<sub>k</sub></span> be the parameter types of the function type of the
                  type <span class="type">F</span><code class="literal">&lt;</code><span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span><code class="literal">&gt;</code>, where <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ...,
                  <span class="symbol">&#945;</span><span class="type"><sub>m</sub></span> are fresh inference variables.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-210"></a>
                  If <span class="emphasis"><em>n</em></span> <span class="symbol">&#8800;</span> <span class="emphasis"><em>k</em></span>, no valid parameterization exists. Otherwise, a
                  set of constraint formulas is formed with, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span>
                  <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>n</em></span>), &#8249;<span class="type">P<sub>i</sub></span> = <span class="type">Q<sub>i</sub></span>&#8250;. This constraint
                  formula set is reduced to form the bound set <span class="type">B</span>.
               </p>
               <p class="norm-static"><a name="jls-18.5.3-220"></a>
                  If <span class="type">B</span> contains the bound <span class="emphasis"><em>false</em></span>, no valid parameterization
                  exists. Otherwise, a new parameterization of the functional interface
                  type, <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, is constructed as
                  follows, for 1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>m</em></span>:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.3-220-A"></a>
                                 If <span class="type">B</span> contains an instantiation (<a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>)
                                 for <span class="symbol">&#945;</span><span class="type"><sub>i</sub></span>, <span class="type">T</span>, then <span class="type">A'<sub>i</sub></span> = <span class="type">T</span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.3-220-B"></a>
                                 Otherwise, <span class="type">A'<sub>i</sub></span> = <span class="type">A<sub>i</sub></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm-static"><a name="jls-18.5.3-230"></a>
                  If <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is not a well-formed
                  type (that is, the type arguments are not within their bounds), or if
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code> is not a subtype of
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A<sub>1</sub></span>, ..., <span class="type">A<sub>m</sub></span><code class="literal">&gt;</code>, no valid parameterization
                  exists. Otherwise, the inferred parameterization is either
                  <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ..., <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, if all the type
                  arguments are types, or the non-wildcard parameterization
                  (<a class="xref" href="jls-9.html#jls-9.9" title="9.9.&nbsp;Function Types">&sect;9.9</a>) of <span class="type">F</span><code class="literal">&lt;</code><span class="type">A'<sub>1</sub></span>, ...,
                  <span class="type">A'<sub>m</sub></span><code class="literal">&gt;</code>, if one or more type arguments are still
                  wildcards.
               </p>
               <p class="note">In order to determine the function type of a
                  wildcard-parameterized functional interface, we have to "instantiate"
                  the wildcard type arguments with specific types. The "default"
                  approach is to simply replace the wildcards with their bounds, as
                  described in <a class="xref" href="jls-9.html#jls-9.8" title="9.8.&nbsp;Functional Interfaces">&sect;9.8</a>, but this produces spurious
                  errors in cases where a lambda expression has explicit parameter types
                  that do <span class="emphasis"><em>not</em></span> correspond to the wildcard bounds.
                  For example:
               </p><pre class="screen">Predicate&lt;? super Integer&gt; p = (Number n) <code class="literal">-&gt;</code> n.equals(23);</pre><p class="note">The lambda expression is
                  a <code class="literal">Predicate&lt;Number&gt;</code>, which is a subtype
                  of <code class="literal">Predicate&lt;? super Integer&gt;</code> but
                  not <code class="literal">Predicate&lt;Integer&gt;</code>. The analysis in this
                  section is used to infer that <code class="literal">Number</code> is an
                  appropriate choice for the type argument
                  to <code class="literal">Predicate</code>.
               </p>
               <p class="note">That said, the analysis here, while described in
                  terms of general type inference, is intentionally quite simple.  The
                  only constraints are equality constraints, which means that reduction
                  amounts to simple pattern matching. A more powerful strategy might
                  also infer constraints from the body of the lambda expression. But,
                  given possible interactions with inference for surrounding and/or
                  nested generic method invocations, this would introduce a lot of extra
                  complexity.
               </p>
            </div>
            <div class="section" title="18.5.4.&nbsp;More Specific Method Inference">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-18.5.4"></a>18.5.4.&nbsp;More Specific Method Inference
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm-static"><a name="jls-18.5.4-100"></a>When
                  testing that one applicable method is <span class="emphasis"><em>more
                        specific</em></span> than another (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>),
                  where the second method is generic, it is necessary to test whether
                  some instantiation of the second method's type parameters can be
                  inferred to make the first method more specific than the
                  second.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-200"></a>Let <code class="varname">m<sub>1</sub></code>
                  be the first method and <code class="varname">m<sub>2</sub></code> be the second method. Where <code class="varname">m<sub>2</sub></code> has type
                  parameters <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, let <span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>, ..., <span class="symbol">&#945;</span><span class="type"><sub>p</sub></span> be inference
                  variables, and let <span class="symbol">&#952;</span> be the substitution <code class="literal">[</code><span class="type">P<sub>1</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>1</sub></span>,
                  ..., <span class="type">P<sub>p</sub></span>:=<span class="symbol">&#945;</span><span class="type"><sub>p</sub></span><code class="literal">]</code>.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-210"></a>Let <code class="varname">e<sub>1</sub></code>,
                  ..., <code class="varname">e<sub>k</sub></code> be the argument expressions of the corresponding
                  invocation. Then:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-210-A"></a>
                                 If <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by strict or loose invocation
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.2" title="15.12.2.2.&nbsp;Phase 1: Identify Matching Arity Methods Applicable by Strict Invocation">&sect;15.12.2.2</a>,
                                 <a class="xref" href="jls-15.html#jls-15.12.2.3" title="15.12.2.3.&nbsp;Phase 2: Identify Matching Arity Methods Applicable by Loose Invocation">&sect;15.12.2.3</a>), then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span> be
                                 the formal parameter types of <code class="varname">m<sub>1</sub></code>, and let <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>k</sub></span> be
                                 the result of <span class="symbol">&#952;</span> applied to the formal parameter types of
                                 <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-210-B"></a>
                                 If <code class="varname">m<sub>1</sub></code> and <code class="varname">m<sub>2</sub></code> are applicable by variable arity invocation
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.4" title="15.12.2.4.&nbsp;Phase 3: Identify Methods Applicable by Variable Arity Invocation">&sect;15.12.2.4</a>), then let <span class="type">S<sub>1</sub></span>, ..., <span class="type">S<sub>k</sub></span> be
                                 the first <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m<sub>1</sub></code>, and let
                                 <span class="type">T<sub>1</sub></span>, ..., <span class="type">T<sub>k</sub></span> be the result of <span class="symbol">&#952;</span> applied to the first
                                 <span class="emphasis"><em>k</em></span> variable arity parameter types of <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">Note that no substitution is applied to <span class="type">S<sub>1</sub></span>, ...,
                  <span class="type">S<sub>k</sub></span>; even if <code class="varname">m<sub>1</sub></code> is generic, the type parameters of <code class="varname">m<sub>1</sub></code> are treated
                  as type variables, not inference variables.
               </p>
               <p class="norm-static"><a name="jls-18.5.4-300"></a>The
                  process to determine if <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code> is as
                  follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-A"></a>
                                 First, an initial bound set, <span class="type">B</span>, is constructed from the
                                 declared bounds of <span class="type">P<sub>1</sub></span>, ..., <span class="type">P<sub>p</sub></span>, as specified in
                                 <a class="xref" href="jls-18.html#jls-18.1.3" title="18.1.3.&nbsp;Bounds">&sect;18.1.3</a>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-B"></a>
                                 Second, for all <span class="emphasis"><em>i</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>i</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), a set of
                                 constraint formulas or bounds is generated.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.1"></a>
                                 If <span class="type">T<sub>i</sub></span> is a proper type, the result is <span class="emphasis"><em>true</em></span> if <span class="type">S<sub>i</sub></span> is
                                 more specific than <span class="type">T<sub>i</sub></span> for <code class="varname">e<sub>i</sub></code>
                                 (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>), and <span class="emphasis"><em>false</em></span>
                                 otherwise. (Note that <span class="type">S<sub>i</sub></span> is always a proper type.)
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.2"></a>
                                 Otherwise, if <span class="type">T<sub>i</sub></span> is not a functional interface type, the
                                 constraint formula &#8249;<span class="type">S<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">T<sub>i</sub></span>&#8250; is
                                 generated.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.3"></a>
                                 Otherwise, <span class="type">T<sub>i</sub></span> is a parameterization of a functional interface,
                                 <span class="type">I</span>. It must be determined whether <span class="type">S<sub>i</sub></span> satisfies the following
                                 five conditions:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.3-A"></a>
                                    	  <span class="type">S<sub>i</sub></span> is a functional interface type.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.3-B"></a>
                                    	  <span class="type">S<sub>i</sub></span> is not a superinterface of <span class="type">I</span>, nor a parameterization
                                    	  of a superinterface of <span class="type">I</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.3-C"></a>
                                    	  <span class="type">S<sub>i</sub></span> is not a subinterface of <span class="type">I</span>, nor a parameterization of
                                    	  a subinterface of <span class="type">I</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.3-D"></a>
                                    	  If <span class="type">S<sub>i</sub></span> is an intersection type, at least one element of the
                                    	  intersection is not a superinterface of <span class="type">I</span>, nor a
                                    	  parameterization of a superinterface of <span class="type">I</span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.3-E"></a>
                                    	  If <span class="type">S<sub>i</sub></span> is an intersection type, no element of the
                                    	  intersection is a subinterface of <span class="type">I</span>, nor a parameterization
                                    	  of a subinterface of <span class="type">I</span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.4"></a>
                                 If all five conditions are true, then the following constraint
                                 formulas or bounds are generated (where <span class="type">U<sub>1</sub></span> ... <span class="type">U<sub>k</sub></span> and <span class="type">R<sub>1</sub></span>
                                 are the parameter types and return type of the function type of
                                 the capture of <span class="type">S<sub>i</sub></span>, and <span class="type">V<sub>1</sub></span> ... <span class="type">V<sub>k</sub></span> and <span class="type">R<sub>2</sub></span> are the
                                 parameter types and return type of the function type of
                                 <span class="type">T<sub>i</sub></span>):
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-A"></a>
                                    	  If <code class="varname">e<sub>i</sub></code> is an explicitly typed lambda expression:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-A"></a>
                                             	      For all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), &#8249;<span class="type">U<sub>j</sub></span> = <span class="type">V<sub>j</sub></span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-B"></a>
                                             	      If <span class="type">R<sub>2</sub></span> is <code class="literal">void</code>, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-C"></a>
                                             	      Otherwise, if <span class="type">R<sub>1</sub></span> and <span class="type">R<sub>2</sub></span> are functional interface
                                             	      types, and neither interface is a subinterface of the
                                             	      other, and <code class="varname">e<sub>i</sub></code> has at least one result expression, then
                                             	      these rules are applied recursively to <span class="type">R<sub>1</sub></span> and <span class="type">R<sub>2</sub></span>,
                                             	      for each result expression in <code class="varname">e<sub>i</sub></code>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-D"></a>
                                             	      Otherwise, if <span class="type">R<sub>1</sub></span> is a primitive type and <span class="type">R<sub>2</sub></span> is not,
                                             	      and <code class="varname">e<sub>i</sub></code> has at least one result expression,
                                             	      and each result expression of <code class="varname">e<sub>i</sub></code> is a standalone
                                             	      expression (<a class="xref" href="jls-15.html#jls-15.2" title="15.2.&nbsp;Forms of Expressions">&sect;15.2</a>) of a primitive
                                             	      type, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-E"></a>
                                             	      Otherwise, if <span class="type">R<sub>2</sub></span> is a primitive type and <span class="type">R<sub>1</sub></span> is not,
                                             	      and <code class="varname">e<sub>i</sub></code> has at least one result expression,
                                             	      and each result expression of <code class="varname">e<sub>i</sub></code> is either a
                                             	      standalone expression of a reference type or a poly
                                             	      expression, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-A-F"></a>
                                             	      Otherwise, &#8249;<span class="type">R<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>2</sub></span>&#8250;.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-B"></a>
                                    	  If <code class="varname">e<sub>i</sub></code> is an exact method reference:
                                 </p>
                                 <div class="norm">
                                    <ul class="norm" type="square">
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-A"></a>
                                             	      For all <span class="emphasis"><em>j</em></span> (1 <span class="symbol">&#8804;</span> <span class="emphasis"><em>j</em></span> <span class="symbol">&#8804;</span> <span class="emphasis"><em>k</em></span>), &#8249;<span class="type">U<sub>j</sub></span> = <span class="type">V<sub>j</sub></span>&#8250;.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-B"></a>
                                             	      If <span class="type">R<sub>2</sub></span> is <code class="literal">void</code>, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-C"></a>
                                             	      Otherwise, if <span class="type">R<sub>1</sub></span> is a primitive type and <span class="type">R<sub>2</sub></span> is not,
                                             	      and the compile-time declaration for <code class="varname">e<sub>i</sub></code> has a
                                             	      primitive return type, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-D"></a>
                                             	      Otherwise if <span class="type">R<sub>2</sub></span> is a primitive type and <span class="type">R<sub>1</sub></span> is not,
                                             	      and the compile-time declaration for <code class="varname">e<sub>i</sub></code> has a
                                             	      reference return type, <span class="emphasis"><em>true</em></span>.
                                          </p>
                                       </li>
                                       <li class="listitem">
                                          <p class="norm-static"><a name="jls-18.5.4-300-B.4-B-E"></a>
                                             	      Otherwise, &#8249;<span class="type">R<sub>1</sub></span> <code class="literal">&lt;:</code> <span class="type">R<sub>2</sub></span>&#8250;.
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-C"></a>
                                    	  If <code class="varname">e<sub>i</sub></code> is a parenthesized expression, these rules are
                                    	  applied recursively to the contained expression.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-D"></a>
                                    	  If <code class="varname">e<sub>i</sub></code> is a conditional expression, these rules are applied
                                    	  recursively to each of the second and third operands.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm-static"><a name="jls-18.5.4-300-B.4-E"></a>
                                    	  Otherwise, <span class="emphasis"><em>false</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p class="norm-static"><a name="jls-18.5.4-300-B.5"></a>
                                 If the five constraints on <span class="type">S<sub>i</sub></span> are not satisfied, the
                                 constraint formula &#8249;<span class="type">S<sub>i</sub></span> <code class="literal">&lt;:</code> <span class="type">T<sub>i</sub></span>&#8250; is
                                 generated instead.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-C"></a>
                                 Third, if <code class="varname">m<sub>2</sub></code> is applicable by variable arity invocation and
                                 has <span class="emphasis"><em>k</em></span>+1 parameters, then where <span class="type">S<sub>k+1</sub></span> is the <span class="emphasis"><em>k</em></span>+1'th
                                 variable arity parameter type of <code class="varname">m<sub>1</sub></code> and <span class="type">T<sub>k+1</sub></span> is the
                                 result of <span class="symbol">&#952;</span> applied to the <span class="emphasis"><em>k</em></span>+1'th variable arity
                                 parameter type of <code class="varname">m<sub>2</sub></code>, the constraint &#8249;<span class="type">S<sub>k+1</sub></span>
                                 <code class="literal">&lt;:</code> <span class="type">T<sub>k+1</sub></span>&#8250; is generated.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-static"><a name="jls-18.5.4-300-D"></a>
                                 Fourth, the generated bounds and constraint formulas are reduced
                                 and incorporated with <span class="type">B</span> to produce a bound set
                                 <span class="type">B'</span>.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-D.1"></a>
                                 If <span class="type">B'</span> does not contain the bound <span class="emphasis"><em>false</em></span>, and
                                 resolution of all the inference variables in <span class="type">B'</span> succeeds,
                                 then <code class="varname">m<sub>1</sub></code> is more specific than <code class="varname">m<sub>2</sub></code>.
                        </p>
                        <p class="norm-static"><a name="jls-18.5.4-300-D.2"></a>
                                 Otherwise, <code class="varname">m<sub>1</sub></code> is not more specific than <code class="varname">m<sub>2</sub></code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-17.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-19.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;17.&nbsp;Threads and Locks&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;19.&nbsp;Syntax</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>