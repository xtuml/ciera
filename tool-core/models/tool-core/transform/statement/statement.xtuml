-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'statement',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("c1939e8a-8fe3-4cee-9fcb-7fc8e8cc2592",
	112,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.1.17',
	'tool-core::transform::statement');
INSERT INTO DIM_DIA
	VALUES ("c1939e8a-8fe3-4cee-9fcb-7fc8e8cc2592",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	"00000000-0000-0000-0000-000000000000",
	'transformBridgeInvocation',
	'',
	'act_brg = param.act_brg;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_brg->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570];
if ( empty util_func )
  select one s_ee related by act_brg->S_BRG[R674]->S_EE[R19];
  select one s_ee_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  select any empty_comp_def from instances of ComponentDefinition where false;
  ::transformUtility( s_ee:s_ee, ep_pkg:s_ee_pkg, containing_comp_def:empty_comp_def, exclude:true, path: ::ep_pkgToPath( ep_pkg:s_ee_pkg ) );
  select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570];

  // add module dependency if necessary
  select any main_mod from instances of Module where selected.main_module;
  select one mod related by s_ee->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
  if mod != main_mod
    select any dependency related by main_mod->Dependency[R5753.''requires''] where selected.required_module_name == mod.name;
    if empty dependency
      create object instance dependency of Dependency;
      relate mod to main_mod across R5753.''required by'' using dependency;
    end if;
  end if;
 
end if;
select one invocable related by util_func->InvocableObject[R427];
select one utility related by util_func->Utility[R4559];
select one utility_file related by utility->File[R401];
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def )
  select any util_ref related by utility->UtilityInComponent[R4558] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  if ( empty util_ref )
    create object instance util_ref of UtilityInComponent;
    relate utility to containing_comp_def across R4558 using util_ref;
  end if;
end if;
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr2 across R795;
  // create utility reference
  create object instance utility_ref of UtilityReference;
  relate utility_ref to utility across R3914;
  relate utility_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  // transform actual parameters
  select many v_pars related by act_brg->V_PAR[R628];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("352665b2-b1ca-4679-b298-9ca266aadaf3",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'act_brg',
	"9401259e-aff6-4747-8963-a78cca9bb312",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9401259e-aff6-4747-8963-a78cca9bb312",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("5495268f-96a0-4daa-ad63-c0a3f6bc7003",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"352665b2-b1ca-4679-b298-9ca266aadaf3",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Code Block>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("d70d90ad-fb70-4874-b173-f7e5961e06e8",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"5495268f-96a0-4daa-ad63-c0a3f6bc7003",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	"00000000-0000-0000-0000-000000000000",
	'transformFunctionInvocation',
	'',
	'act_fnc = param.act_fnc;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fnc->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select one s_sync related by act_fnc->S_SYNC[R675];
containing_comp_def = ::getCompDefForStatement( smt:smt );
select any invocable related by containing_comp_def->Function[R405]->InvocableObject[R427] where ( selected.name == s_sync.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr2 across R795;
  // create named reference
  create object instance domain_ref of DomainReference;
  relate domain_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  // transform actual parameters
  select many v_pars related by act_fnc->V_PAR[R669];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("4b2aafc8-3fec-4b00-b681-6d73ba77aeca",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'act_fnc',
	"86cad241-b50f-4db8-85e7-1f596daa2aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("86cad241-b50f-4db8-85e7-1f596daa2aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("03a296be-0cc2-4739-aab1-a165c687b305",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"4b2aafc8-3fec-4b00-b681-6d73ba77aeca",
	'');
INSERT INTO S_SPARM
	VALUES ("9376b863-3c08-4a7f-a09d-53af4225082e",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"03a296be-0cc2-4739-aab1-a165c687b305",
	'');
INSERT INTO PE_PE
	VALUES ("abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("73520fae-d9ee-4105-950f-69fe437a613e",
	"00000000-0000-0000-0000-000000000000",
	'transformOperationInvocation',
	'',
	'act_tfm = param.act_tfm;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_tfm->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select one o_tfr related by act_tfm->O_TFR[R673];
select one obj related by o_tfr->O_OBJ[R115]->Class[R409];
select any invocable related by obj->Operation[R416]->InvocableObject[R427]
  where ( selected.name == o_tfr.Name or selected.name == "_" + obj.name + "_" + o_tfr.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate eas to expr across R476;
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  select one op_v_var related by act_tfm->V_VAR[R667];
  if ( empty op_v_var ) // class based operation
    // for class based operations, add domain as first parameter
    create object instance expr3 of Expression;
    relate expr3 to smt across R775;
    expr3.expression_number = "1.1";
    relate void_type to expr3 across R795;
    relate expr3 to invoc across R798;
    // create named reference
    create object instance domain_ref of DomainReference;
    relate domain_ref to expr3 across R776;

		// transform actual parameters
		select many v_pars related by act_tfm->V_PAR[R627];
		::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );

  else // instance based operation
    // create variable reference expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775;
    expr2.expression_number = "1.1";
    relate expr2 to invoc across R798;
    op_var = ::getVariableInScope(smt:smt, name:op_v_var.Name);
    op_type = ::getObjectReference(obj:obj);
    relate op_type to expr2 across R795;
    if ( not_empty op_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate op_var to var_ref across R782;
      relate var_ref to expr2 across R776;
    elif ( "self" == op_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to expr2 across R776;
      self_ref.name = "self()";
    else
      // TODO bad
    end if;
		// transform actual parameters
		select many v_pars related by act_tfm->V_PAR[R627];
		::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
  end if;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e85eda2c-3c15-4bd7-9595-08b630b7a666",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'act_tfm',
	"c3a0c649-c89b-4f9b-9fdc-719fe83d5949",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c3a0c649-c89b-4f9b-9fdc-719fe83d5949",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("ee005cc8-cd28-4b02-a6b8-fb16d32ff8ec",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"e85eda2c-3c15-4bd7-9595-08b630b7a666",
	'');
INSERT INTO S_SPARM
	VALUES ("7aad2443-ee03-4b07-a9a3-d43b7040878e",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"ee005cc8-cd28-4b02-a6b8-fb16d32ff8ec",
	'');
INSERT INTO PE_PE
	VALUES ("73520fae-d9ee-4105-950f-69fe437a613e",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3e960d0c-6b93-4eb9-b226-4655058ab532",
	"00000000-0000-0000-0000-000000000000",
	'transformSignalInvocation',
	'',
	'act_sgn = param.act_sgn;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_sgn->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select one spr_rs related by act_sgn->SPR_RS[R660];
select one spr_ps related by act_sgn->SPR_PS[R663];
select one c_ep related by spr_rs->SPR_REP[R4502]->C_EP[R4500];
if ( empty c_ep )
  select one c_ep related by spr_ps->SPR_PEP[R4503]->C_EP[R4501];
end if;
select one c_po related by spr_rs->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009]->C_PO[R4016];
if ( empty c_po )
  select one c_po related by spr_ps->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009]->C_PO[R4016];
end if;
select one target_port related by c_po->Port[R422];
select any invocable related by target_port->PortMessage[R420]->InvocableObject[R427] where ( selected.name == c_ep.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate eas to expr across R476;
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  relate expr2 to invoc across R798;
  void_type = ::getBasicTypeReferenceByName( name:"void" );
  relate void_type to expr2 across R795;
  // create port reference
  create object instance port_ref of PortReference;
  relate port_ref to target_port across R3915;
  relate port_ref to expr2 across R776;
  // transform actual parameters
  select many v_pars related by act_sgn->V_PAR[R662];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("f1d2c3b8-1e18-4855-a7dc-7517c6460cf0",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'act_sgn',
	"a5d7357e-b251-4e0f-8026-7df3117e656e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a5d7357e-b251-4e0f-8026-7df3117e656e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Signal Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("0736d699-4c6c-479d-92f5-5867a8d07aa8",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"f1d2c3b8-1e18-4855-a7dc-7517c6460cf0",
	'');
INSERT INTO S_SPARM
	VALUES ("99a75507-8e17-475b-8368-71fa62cd158f",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"0736d699-4c6c-479d-92f5-5867a8d07aa8",
	'');
INSERT INTO PE_PE
	VALUES ("3e960d0c-6b93-4eb9-b226-4655058ab532",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("de7e24ef-9847-4033-a108-d402987edf81",
	"00000000-0000-0000-0000-000000000000",
	'transformIfStatement',
	'',
	'act_if = param.act_if;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_if->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select any empty_invocable from instances of InvocableObject where false;
// create if statement
create object instance if_smt of IfSmt;
relate if_smt to smt across R451;
if_smt.is_else_if = false;
// translate if expression
select one if_val related by act_if->V_VAL[R625];
::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
select any if_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate if_expr to if_smt across R471;
// create then block
then_block_number = ::getNextBlockNumber( upper_block:block );
select one then_blk related by act_if->ACT_BLK[R607];
::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocable:empty_invocable );
select any then_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == then_block_number );
relate then_block to if_smt across R453;
// translate elifs
select many act_els related by act_if->ACT_EL[R682];
select many translated_act_els from instances of ACT_EL where false;
remaining_act_els = act_els - translated_act_els;
while ( not_empty remaining_act_els )
  // get the next elif
  select any act_el from instances of ACT_EL where false;
  for each remaining_act_el in remaining_act_els
    if ( empty act_el )
      act_el = remaining_act_el;
    else
      select one act_el_smt related by act_el->ACT_SMT[R603];
      select one remaining_act_el_smt related by remaining_act_el->ACT_SMT[R603];
      if ( remaining_act_el_smt.LineNumber < act_el_smt.LineNumber or
           remaining_act_el_smt.LineNumber == act_el_smt.LineNumber and remaining_act_el_smt.StartPosition == act_el_smt.StartPosition )
        act_el = remaining_act_el;
      end if;
    end if;
  end for;
  // create block for elif
  elif_block_number = ::getNextBlockNumber( upper_block:block );
  ::transformBlockForElif( upper_block:block, act_el:act_el, block_number:elif_block_number );
  select any else_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == elif_block_number );
  relate else_block to if_smt across R454;
  // set the new current block and if statement
  block = else_block;
  select any if_smt related by if_smt->CodeBlock[R454]->Statement[R450]->IfSmt[R451];
  // mark the elif as translated
  translated_act_els = translated_act_els + act_el;
  remaining_act_els = act_els - translated_act_els;
end while;
// create else block
else_block_number = ::getNextBlockNumber( upper_block:block );
select one else_blk related by act_if->ACT_E[R683]->ACT_BLK[R606];
if ( not_empty else_blk )
  ::transformBlock( upper_block:block, act_blk:else_blk, block_number:else_block_number, invocable:empty_invocable );
  select any else_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == else_block_number );
  relate else_block to if_smt across R454;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("552c46f9-9d62-416c-85a9-4f3e6a48cf78",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'act_if',
	"bb76d140-b203-4872-8599-9118f0d24469",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bb76d140-b203-4872-8599-9118f0d24469",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<If Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("825e76f0-0e5b-48b5-934d-91e6e2f4b4c3",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"552c46f9-9d62-416c-85a9-4f3e6a48cf78",
	'');
INSERT INTO S_SPARM
	VALUES ("ebe132d9-4995-4f47-a949-e8061a13dc4f",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"825e76f0-0e5b-48b5-934d-91e6e2f4b4c3",
	'');
INSERT INTO PE_PE
	VALUES ("de7e24ef-9847-4033-a108-d402987edf81",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("65b5e300-7f3b-4575-850c-ff44c70f27ab",
	"00000000-0000-0000-0000-000000000000",
	'transformWhileStatement',
	'',
	'act_whl = param.act_whl;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_whl->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

select any empty_invocable from instances of InvocableObject where false;
// create while statement
create object instance while_smt of WhileSmt;
relate while_smt to smt across R451;
// translate while expression
select one while_val related by act_whl->V_VAL[R626];
::transformExpression( v_val:while_val, expr_number:"1", smt:smt );
select any while_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate while_expr to while_smt across R472;
// create control block
control_block_number = ::getNextBlockNumber( upper_block:block );
select one control_blk related by act_whl->ACT_BLK[R608];
::transformBlock( upper_block:block, act_blk:control_blk, block_number:control_block_number, invocable:empty_invocable );
select any control_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == control_block_number );
relate control_block to while_smt across R456;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2f21f7a6-bc41-4aa5-b407-02b485f9c3a5",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'act_whl',
	"86e01ede-4100-4b04-9d71-5d50a8ab4dd8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("86e01ede-4100-4b04-9d71-5d50a8ab4dd8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<While Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("949a2c93-01d1-4d82-9e09-092ac18e3d00",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"2f21f7a6-bc41-4aa5-b407-02b485f9c3a5",
	'');
INSERT INTO S_SPARM
	VALUES ("1450494b-793f-4c98-8b92-762ca3cd9685",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"949a2c93-01d1-4d82-9e09-092ac18e3d00",
	'');
INSERT INTO PE_PE
	VALUES ("65b5e300-7f3b-4575-850c-ff44c70f27ab",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	"00000000-0000-0000-0000-000000000000",
	'transformBreakStatement',
	'',
	'act_brk = param.act_brk;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_brk->ACT_SMT[R603];

// find a for or while statement in a block that is a direct ancestor of the current block
select any loop_smt related by block->InvocableObject[R4000]->CodeBlock[R4000]->Statement[R450]->ForSmt[R451]->Statement[R451]
  where (selected.block_number != block.block_number and STRING::indexof(haystack:block.block_number, needle:selected.block_number) == 0);
if empty loop_smt
  select any loop_smt related by block->InvocableObject[R4000]->CodeBlock[R4000]->Statement[R450]->WhileSmt[R451]->Statement[R451]
    where (selected.block_number != block.block_number and STRING::indexof(haystack:block.block_number, needle:selected.block_number) == 0);
end if;

if not_empty loop_smt

  // create a statement
  create object instance smt of Statement;
  relate smt to block across R450;
  if ( not_empty prev_smt )
    smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
    relate smt to prev_smt across R477.''executes after'';
  else
    smt.statement_number = "1";
  end if;
  select one body related by block->InvocableObject[R4000];
  smt.actions = ::getOalStatement(act_smt:act_smt);
  smt.line_number = act_smt.LineNumber;
  
  // create break statement
  create object instance break_smt of BreakSmt;
  relate break_smt to smt across R451;

else
  select one invocable related by block->InvocableObject[R4000];
  ::semanticError(invocable:invocable, line_number:act_smt.LineNumber, message:"''break'' statement must be within a loop");
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9d2176aa-8350-411d-8089-18be2d55aa4d",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'act_brk',
	"da79315c-1694-40ef-bd42-87a95148b582",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("da79315c-1694-40ef-bd42-87a95148b582",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Break>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("44c502a7-27b2-4b2d-91b9-7e3510f1597f",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"9d2176aa-8350-411d-8089-18be2d55aa4d",
	'');
INSERT INTO S_SPARM
	VALUES ("28b2c872-c56c-4e83-b170-53a736402329",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"44c502a7-27b2-4b2d-91b9-7e3510f1597f",
	'');
INSERT INTO PE_PE
	VALUES ("9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	"00000000-0000-0000-0000-000000000000",
	'transformContinueStatement',
	'',
	'act_con = param.act_con;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_con->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create continue statement
create object instance continue_smt of ContinueSmt;
relate continue_smt to smt across R451;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e9a9c1cd-e629-4407-b390-05f9637ce18a",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'act_con',
	"d64b7f9b-4188-431e-8dd3-f34c683c0a7a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d64b7f9b-4188-431e-8dd3-f34c683c0a7a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Continue>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("3b25b90e-976a-4f1b-b451-f5b800796a23",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"e9a9c1cd-e629-4407-b390-05f9637ce18a",
	'');
INSERT INTO S_SPARM
	VALUES ("0035ec14-8c30-46d7-91e6-a3fa5ea1771c",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"3b25b90e-976a-4f1b-b451-f5b800796a23",
	'');
INSERT INTO PE_PE
	VALUES ("5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d38219f-e7ec-4d37-920a-526625941452",
	"00000000-0000-0000-0000-000000000000",
	'transformAssignToMember',
	'',
	'act_ai = param.act_ai;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ai->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// If this assignment is assigning an invocation return value to a variable
// that is never read in the body, simply execute the invocation. OAL has
// a limitation in that you cannot invoke bodies that return a value without
// assigning the value to something (even if you do not intend to use it).
// If there is an invocation of T::include anywhere in the body, bail because
// the variable might be referenced in the template.
select one l_val related by act_ai->V_VAL[R689];
select one l_val_dt related by l_val->S_DT[R820];
select one r_val related by act_ai->V_VAL[R609];
select one r_val_dt related by r_val->S_DT[R820];
select one v_var related by l_val->V_TVL[R801]->V_VAR[R805];
if ( empty v_var )
  select one v_var related by l_val->V_IRF[R801]->V_VAR[R808];
  if ( empty v_var )
    select one v_var related by l_val->V_ISR[R801]->V_VAR[R809];
  end if;
end if;
num_references = ::numReferences( v_var:v_var );
select one r_brv related by r_val->V_BRV[R801];
select one r_fnv related by r_val->V_FNV[R801];
select one r_trv related by r_val->V_TRV[R801];
rhs_is_invocation = not_empty r_brv or not_empty r_fnv or not_empty r_trv;
select many s_brgs related by act_ai->ACT_SMT[R603]->ACT_BLK[R602]->ACT_ACT[R601]->ACT_BLK[R601]->ACT_SMT[R602]->ACT_BRG[R603]->S_BRG[R674] where ( selected.Name == "include" );
select any s_ee related by s_brgs->S_EE[R19] where ( selected.Key_Lett == "T" );
if ( empty s_ee and rhs_is_invocation and num_references == 1 )
  // create right operand
  ::transformExpression( v_val:r_val, expr_number:"1", smt:smt );
  select any r_op related by smt->Expression[R775] where ( selected.expression_number == "1" );
  relate r_op to eas across R476;
else
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate expr to eas across R476;
  // create binary operation and assignment expression
  create object instance binop of BinaryOperation;
  relate binop to expr across R776;
  binop.operator = "=";
  binop.invocation = false;
  // create left operand
  ::transformExpression( v_val:l_val, expr_number:"1.1", smt:smt );
  select any l_op related by smt->Expression[R775] where ( selected.expression_number == "1.1" );
  relate l_op to binop across R779;
  select one ltype related by l_op->TypeReference[R795];
  ::transformExpression(v_val:r_val, expr_number:"1.2", smt:smt);
  select any r_op related by smt->Expression[R775] where ( selected.expression_number == "1.2" );
  relate r_op to binop across R778;
  // link l_op type to the main expression
  select one type related by l_op->TypeReference[R795];
  relate type to expr across R795;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1794be11-aeec-48b5-add2-4a1f9da41cb6",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'act_ai',
	"dd812f1d-8408-4547-b6a7-b4647dde5560",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("dd812f1d-8408-4547-b6a7-b4647dde5560",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Assign to Member>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("a07595ec-559e-4c0a-aec7-3d8102508762",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"1794be11-aeec-48b5-add2-4a1f9da41cb6",
	'');
INSERT INTO S_SPARM
	VALUES ("f07f3063-c859-4332-babd-e18233358cba",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"a07595ec-559e-4c0a-aec7-3d8102508762",
	'');
INSERT INTO PE_PE
	VALUES ("5d38219f-e7ec-4d37-920a-526625941452",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("72240988-bdbe-4ced-9848-4e72f7fda04e",
	"00000000-0000-0000-0000-000000000000",
	'transformForStatement',
	'',
	'act_for = param.act_for;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_for->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create for statement
create object instance for_smt of ForSmt;
relate for_smt to smt across R451;
for_smt.external_loop_variable = true;  // OAL defines the loop variable in the outer scope

// translate iterable expression
select one iterable_v_var related by act_for->V_VAR[R652];
select one iterable_o_obj related by iterable_v_var->V_INS[R814]->O_OBJ[R819];
iterable_var = ::getVariableInScope(smt:smt, name:iterable_v_var.Name);
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
type = ::getTypeReferenceForV_VAR(v_var:iterable_v_var);
relate type to expr across R795;
create object instance var_ref of VariableReference;
relate iterable_var to var_ref across R782;
relate var_ref to expr across R776;
relate expr to for_smt across R478;

// create iterator variable
select one iter_v_var related by act_for->V_VAR[R614];
iter_var = ::getVariableInScope(smt:smt, name:iter_v_var.Name);
relate iter_var to for_smt across R459;

// create control block
control_block_number = ::getNextBlockNumber( upper_block:block );
select one control_blk related by act_for->ACT_BLK[R605];
select any empty_invocable from instances of InvocableObject where false;
::transformBlock(upper_block:block, act_blk:control_blk, block_number:control_block_number, invocable:empty_invocable);
select any control_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == control_block_number );
relate control_block to for_smt across R455;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("baa5eb23-30c7-4592-8bf0-fedf3ad2bc74",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'act_for',
	"5f3e2b9f-0432-4222-bce6-7ac8c9a492e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5f3e2b9f-0432-4222-bce6-7ac8c9a492e2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<For Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("54474ea7-1f74-4740-bd7c-91baa009ca41",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"baa5eb23-30c7-4592-8bf0-fedf3ad2bc74",
	'');
INSERT INTO S_SPARM
	VALUES ("b887d774-52e2-465d-ae0c-0bba3c5df376",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"54474ea7-1f74-4740-bd7c-91baa009ca41",
	'');
INSERT INTO PE_PE
	VALUES ("72240988-bdbe-4ced-9848-4e72f7fda04e",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectFromInstances',
	'',
	'act_fio = param.act_fio;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fio->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_fio->V_VAR[R639];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select_var = ::getVariableInScope(smt:smt, name:select_v_var.Name);
select_type = ::getTypeReferenceForV_VAR(v_var:select_v_var);
relate select_type to l_op across R795;
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
// create right operand
select one obj related by act_fio->O_OBJ[R677]->Class[R409];
create object instance r_op of Expression;
relate r_op to smt across R775;
r_op.expression_number = "1.2";
relate r_op to binop across R778;
relate select_type to r_op across R795;
fio_type = ::getObjectStreamReference(obj:obj);
if ( "any" == act_fio.cardinality ) // create another expression for the ''any''. Note that this is a little tricky because the local var ''r_op'' is being reused
  create object instance any_expr of AnyExpr;
  relate any_expr to r_op across R776;
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2.1";
  relate fio_type to r_op across R795;
  relate r_op to any_expr across R783;
end if;
create object instance sel of SelectExpr;
relate sel to r_op across R776;
create object instance sel_fi of SelectFromInstances;
relate sel_fi to sel across R789;
relate obj to sel_fi across R799;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9c483a34-c551-4b76-9a15-a4ea2d3b36dc",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'act_fio',
	"42f4ea26-5209-40ef-9c07-9e6e6abf7b73",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("42f4ea26-5209-40ef-9c07-9e6e6abf7b73",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select From Instances>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("aec982f2-5bca-4547-aa75-c2c552fe7982",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"9c483a34-c551-4b76-9a15-a4ea2d3b36dc",
	'');
INSERT INTO S_SPARM
	VALUES ("c5cccfd9-6b1f-4daf-9acb-6ac0617cbf7d",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"aec982f2-5bca-4547-aa75-c2c552fe7982",
	'');
INSERT INTO PE_PE
	VALUES ("0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11c6c837-e285-46ea-a532-2be0c0a19b7a",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectFromInstancesWhere',
	'',
	'act_fiw = param.act_fiw;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fiw->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_fiw->V_VAR[R665];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select_var = ::getVariableInScope(smt:smt, name:select_v_var.Name);
select_type = ::getTypeReferenceForV_VAR(v_var:select_v_var);
relate select_type to l_op across R795;
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
// create right operand
select one where_clause_val related by act_fiw->V_VAL[R610];
select one where_clause_lbo related by where_clause_val->V_LBO[R801];
// special case where the where clause is ''false''
if ( not_empty where_clause_lbo and ( "false" == T::sub( format:"l", s:where_clause_lbo.Value ) ) )
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  create object instance named_expr of NamedReference;
  relate named_expr to r_op across R776;
  select one select_type_def related by select_type->Type[R3800];
  named_expr.name = select_type_def.default_value;
else
  select one obj related by act_fiw->O_OBJ[R676]->Class[R409];
  fiw_type = ::getObjectStreamReference(obj:obj);
  // create where clause
  ::transformWhereClause(v_val:where_clause_val, smt:smt, expr_number:"1.2", where_type:select_type, multiplicity:act_fiw.cardinality);
  select any r_op related by smt->Expression[R775] where selected.expression_number == "1.2";
  relate r_op to binop across R778;
  // create selection expr
  // this selection assumes only 1 where clause per statement which is always true in OAL
  select any where_expr related by smt->Expression[R775]->WhereExpr[R776];
  create object instance sel_expr of Expression;
  relate sel_expr to smt across R775;
  sel_expr.expression_number = where_expr.expression_number + ".1";
  relate fiw_type to sel_expr across R795;
  relate sel_expr to where_expr across R790;
  create object instance sel of SelectExpr;
  relate sel to sel_expr across R776;
  create object instance sel_fi of SelectFromInstances;
  relate sel_fi to sel across R789;
  relate obj to sel_fi across R799;
end if;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("37fd3836-f715-45b7-b4a8-7012c2fb68e0",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'act_fiw',
	"2527a5ea-3890-49e4-9f12-44ef91b2fdab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2527a5ea-3890-49e4-9f12-44ef91b2fdab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select From Instances Where>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("f9e20633-3e98-4cbb-8742-1272414935bf",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"37fd3836-f715-45b7-b4a8-7012c2fb68e0",
	'');
INSERT INTO S_SPARM
	VALUES ("cad3d747-4f86-4a0d-a7a8-a4a23a2a5137",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"f9e20633-3e98-4cbb-8742-1272414935bf",
	'');
INSERT INTO PE_PE
	VALUES ("11c6c837-e285-46ea-a532-2be0c0a19b7a",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	"00000000-0000-0000-0000-000000000000",
	'transformSelect',
	'',
	'act_sel = param.act_sel;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_sel->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_sel->V_VAR[R638];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select one last_lnk related by act_sel->ACT_LNK[R637];
select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
while ( not_empty next_lnk )
  last_lnk = next_lnk;
  select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
end while;
select_var = ::getVariableInScope(smt:smt, name:select_v_var.Name);
select_type = ::getTypeReferenceForV_VAR(v_var:select_v_var);
relate select_type to l_op across R795;
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
// create right operand
select one where_clause_val related by act_sel->ACT_SRW[R664]->V_VAL[R611];
select one where_clause_lbo related by where_clause_val->V_LBO[R801];
if ( not_empty where_clause_lbo and ( "false" == T::sub( format:"l", s:where_clause_lbo.Value ) ) ) // special case where the where clause is ''false''
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  create object instance named_expr of NamedReference;
  relate named_expr to r_op across R776;
  select one select_type_def related by select_type->Type[R3800];
  named_expr.name = select_type_def.default_value;
else
  // get the final selection chain link
  select one lnk related by act_sel->ACT_LNK[R637];
  select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
  while ( not_empty next_lnk )
    lnk = next_lnk;
    select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
  end while;

  if not_empty where_clause_val
    // create where clause
    ::transformWhereClause(v_val:where_clause_val, smt:smt, expr_number:"1.2", where_type:select_type, multiplicity:act_sel.cardinality);
    select any r_op related by smt->Expression[R775] where selected.expression_number == "1.2";
    relate r_op to binop across R778;
    // create expression for last chain link
    // this selection assumes only 1 where clause per statement which is always true in OAL
    select any where_expr related by smt->Expression[R775]->WhereExpr[R776];
    ::transformSelectionLink( act_lnk:lnk, expr_number:where_expr.expression_number + ".1", smt:smt );
    select any sel_expr related by smt->Expression[R775] where selected.expression_number == where_expr.expression_number + ".1";
    relate sel_expr to where_expr across R790;

  elif act_sel.cardinality == "one"
    // link the selection directly
    ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2", smt:smt );
    select any select_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2" );
    relate select_expr to binop across R778;

  elif act_sel.cardinality == "any"
    // create an any expression
    create object instance r_op of Expression;
    relate r_op to smt across R775;
    r_op.expression_number = "1.2";
    relate r_op to binop across R778;
    relate select_type to r_op across R795;
    create object instance any_expr of AnyExpr;
    relate any_expr to r_op across R776;
    // create expression for last chain link
    ::transformSelectionLink( act_lnk:lnk, expr_number:r_op.expression_number + ".1", smt:smt );
    select any select_expr related by smt->Expression[R775] where ( selected.expression_number == r_op.expression_number + ".1" );
    relate select_expr to any_expr across R783;

  else
    ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2", smt:smt );
    select any r_op related by smt->Expression[R775] where ( selected.expression_number == "1.2" );
    relate r_op to binop across R778;
  end if;
end if;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("3c110882-7386-49b1-85c3-486a1c0efda7",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'act_sel',
	"633aa463-4eea-4f3c-aa01-8220a7870baa",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("633aa463-4eea-4f3c-aa01-8220a7870baa",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("8e258060-79d3-4d22-b9b1-960a8dc1f2ec",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"3c110882-7386-49b1-85c3-486a1c0efda7",
	'');
INSERT INTO S_SPARM
	VALUES ("6b2430e0-f218-427b-8b46-28feeaa6fdab",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"8e258060-79d3-4d22-b9b1-960a8dc1f2ec",
	'');
INSERT INTO PE_PE
	VALUES ("af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6036379f-2a05-4d11-a876-958e0d4819c3",
	"00000000-0000-0000-0000-000000000000",
	'transformCreate',
	'',
	'act_cr = param.act_cr;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_cr->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one cr_v_var related by act_cr->V_VAR[R633];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
cr_var = ::getVariableInScope(smt:smt, name:cr_v_var.Name);
cr_type = ::getTypeReferenceForV_VAR(v_var:cr_v_var);
relate cr_type to l_op across R795;
create object instance var_ref of VariableReference;
relate cr_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
// create right operand
create object instance r_op of Expression;
relate r_op to smt across R775;
r_op.expression_number = "1.2";
relate cr_type to r_op across R795;
create object instance cr of Creation;
relate cr to r_op across R776;
select one obj related by act_cr->O_OBJ[R671]->Class[R409];
relate cr to obj across R780;
relate r_op to binop across R778;
// link create type to the main expression
relate cr_type to expr across R795;
// link the initial state (lowest numbered state)
select one ism related by obj->StateMachine[R4750] where selected.is_instance;
select any init_state related by ism->State[R4751] where SORT::ascending(attr:"number") and selected.number > 0;
if not_empty init_state
  relate init_state to cr across R3923;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("48e1fa81-e41e-4fa9-a148-ddd99a3c72fc",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'act_cr',
	"07240b48-02ee-409d-b202-725bbb1b6707",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("07240b48-02ee-409d-b202-725bbb1b6707",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Create>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("de027b78-58a9-49f7-b97a-eb9dc2082ab8",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"48e1fa81-e41e-4fa9-a148-ddd99a3c72fc",
	'');
INSERT INTO S_SPARM
	VALUES ("1dc782ac-a634-4929-8faf-f3a611c8cc49",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"de027b78-58a9-49f7-b97a-eb9dc2082ab8",
	'');
INSERT INTO PE_PE
	VALUES ("6036379f-2a05-4d11-a876-958e0d4819c3",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	"00000000-0000-0000-0000-000000000000",
	'transformCreateNoVariable',
	'',
	'act_cnv = param.act_cnv;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_cnv->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
relate eas to expr across R476;
select any s_irdt related by act_cnv->O_OBJ[R672]->S_IRDT[R123] where ( not selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
cr_type = ::getTypeReferenceForS_DT(s_dt:s_dt);
relate cr_type to expr across R795;
// create creation
create object instance cr of Creation;
relate cr to expr across R776;
select one obj related by act_cnv->O_OBJ[R672]->Class[R409];
relate cr to obj across R780;
select one class_file related by obj->File[R401];
// link the initial state (lowest numbered state)
select one ism related by obj->StateMachine[R4750] where selected.is_instance;
select any init_state related by ism->State[R4751] where SORT::ascending(attr:"number") and selected.number > 0;
if not_empty init_state
  relate init_state to cr across R3923;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("0d2c8921-c1eb-4cb9-9429-8f7ded79758a",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'act_cnv',
	"6cab5519-9843-4065-80d9-10e766f232a1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6cab5519-9843-4065-80d9-10e766f232a1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Create No Variable>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("bc5221f0-a255-4931-a2f1-99279f77e4ec",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"0d2c8921-c1eb-4cb9-9429-8f7ded79758a",
	'');
INSERT INTO S_SPARM
	VALUES ("42d0e1cd-a14c-4295-9f31-8881f78b56dd",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"bc5221f0-a255-4931-a2f1-99279f77e4ec",
	'');
INSERT INTO PE_PE
	VALUES ("5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("963265b3-faa7-40a3-9425-55bca25e12e7",
	"00000000-0000-0000-0000-000000000000",
	'transformControl',
	'',
	'act_ctl = param.act_ctl;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ctl->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create halt statement
create object instance halt_smt of Halt;
relate halt_smt to smt across R451;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("70eba75f-b729-4e41-98a6-758d0b221973",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'act_ctl',
	"dbe30ccb-7f4a-4fde-b51a-cfd0b3dac9c9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("dbe30ccb-7f4a-4fde-b51a-cfd0b3dac9c9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Control>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("2a2a9434-69e4-4888-887c-e3a36000315b",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"70eba75f-b729-4e41-98a6-758d0b221973",
	'');
INSERT INTO S_SPARM
	VALUES ("b3d9aee1-b7c6-4bb9-82ce-b642056d1fa7",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"2a2a9434-69e4-4888-887c-e3a36000315b",
	'');
INSERT INTO PE_PE
	VALUES ("963265b3-faa7-40a3-9425-55bca25e12e7",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1ae7862a-2280-485d-adf4-4f7f2b553c75",
	"00000000-0000-0000-0000-000000000000",
	'transformDelete',
	'',
	'act_del = param.act_del;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_del->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create delete statement
create object instance del of DeleteSmt;
relate del to smt across R451;
// create variable reference expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
relate del to expr across R462;
select one del_v_var related by act_del->V_VAR[R634];
del_var = ::getVariableInScope(smt:smt, name:del_v_var.Name);
del_type = ::getTypeReferenceForV_VAR(v_var:del_v_var);
relate del_type to expr across R795;
if ( not_empty del_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate del_var to var_ref across R782;
  relate var_ref to expr across R776;
elif ( "self" == del_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("015844df-dd39-45e8-b46b-ebb29b3cb13a",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'act_del',
	"a3a3437e-a8c2-4229-b348-ba64feaa5de5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a3a3437e-a8c2-4229-b348-ba64feaa5de5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Delete>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("833eb53d-3f12-423c-9fb2-a82f973d507d",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"015844df-dd39-45e8-b46b-ebb29b3cb13a",
	'');
INSERT INTO S_SPARM
	VALUES ("ecd46958-bc87-4eba-9ed5-fe1ff575dd18",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"833eb53d-3f12-423c-9fb2-a82f973d507d",
	'');
INSERT INTO PE_PE
	VALUES ("1ae7862a-2280-485d-adf4-4f7f2b553c75",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a5290be7-15be-4b55-a290-f48a0523e7ac",
	"00000000-0000-0000-0000-000000000000",
	'transformReturnStatement',
	'',
	'act_ret = param.act_ret;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ret->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create return statement
create object instance ret of ReturnSmt;
relate ret to smt across R451;
// create return expression
select one ret_val related by act_ret->V_VAL[R668];
if ( not_empty ret_val )
  select one act_act related by body->ACT_ACT[R432];
  select one val_dt related by ret_val->S_DT[R820];
  ::transformExpression( v_val:ret_val, expr_number:"1", smt:smt );
  select any ret_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
  relate ret_expr to ret across R473;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("f52cd030-7a44-4ab4-ad14-b039b7a13438",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'act_ret',
	"e1613f59-f8aa-49fe-b922-77a457143277",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e1613f59-f8aa-49fe-b922-77a457143277",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Return Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("5bde5d99-af6c-4cfc-9176-3cc09d3cd0ba",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"f52cd030-7a44-4ab4-ad14-b039b7a13438",
	'');
INSERT INTO S_SPARM
	VALUES ("446a5838-2c77-49b6-8a63-680ea0b2710f",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"5bde5d99-af6c-4cfc-9176-3cc09d3cd0ba",
	'');
INSERT INTO PE_PE
	VALUES ("a5290be7-15be-4b55-a290-f48a0523e7ac",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8644d33b-9954-4438-97ab-f130505c0621",
	"00000000-0000-0000-0000-000000000000",
	'transformRelate',
	'',
	'act_rel = param.act_rel;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_rel->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create relate statement
create object instance relsmt of RelateSmt;
relate relsmt to smt across R451;
// select the relationship
select one r_rel related by act_rel->R_REL[R653];
select one one_v_var related by act_rel->V_VAR[R615];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_rel->V_VAR[R616];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
    other_phrase = C_UTIL::stripTics( s:act_rel.relationship_phrase );
    select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_rel.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
    if ( not_empty oir )
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
    else
      // TODO bad
    end if;
  else // non-reflexive simple association
    select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
    select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
    if ( not_empty one_oir and not_empty other_oir )
      one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
      other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
    else
      // TODO bad
    end if;
  end if;
else
  select one subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty subsup )
    one_phrase = "is_a";
    other_phrase = "is_a";
  end if;
end if;
select any form_v_var from instances of V_VAR where false;
select any part_v_var from instances of V_VAR where false;
select any form_obj from instances of O_OBJ where false;
select any part_obj from instances of O_OBJ where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
  select any rel related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
  if ( not_empty rel )
    form_v_var = one_v_var;
    form_obj = one_o_obj;
    part_v_var = other_v_var;
    part_obj = other_o_obj;
  else
    select any rel related by containing_comp_def->Relationship[R448]
      where ( selected.num == r_rel.Numb and
        ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
    form_v_var = other_v_var;
    form_obj = other_o_obj;
    part_v_var = one_v_var;
    part_obj = one_o_obj;
  end if;
  if ( not_empty rel )
    relate rel to relsmt across R481;
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;
// create variable reference expression for formalizer
create object instance form_expr of Expression;
relate form_expr to smt across R775;
form_expr.expression_number = "1";
relate relsmt to form_expr across R479;
form_var = ::getVariableInScope(smt:smt, name:form_v_var.Name);
select one form_s_dt related by form_v_var->S_DT[R848];
form_type = ::getTypeReferenceForV_VAR(v_var:form_v_var);
relate form_type to form_expr across R795;
if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate form_var to var_ref across R782;
  relate var_ref to form_expr across R776;
elif ( "self" == form_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to form_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;
// create variable reference expression for participant
create object instance part_expr of Expression;
relate part_expr to smt across R775;
part_expr.expression_number = "2";
relate relsmt to part_expr across R480;
part_var = ::getVariableInScope(smt:smt, name:part_v_var.Name);
part_type = ::getTypeReferenceForV_VAR(v_var:part_v_var);
relate part_type to part_expr across R795;
if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate part_var to var_ref across R782;
  relate var_ref to part_expr across R776;
elif ( "self" == part_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to part_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("dd0fd3f1-b737-409e-b37c-5f7518308ec5",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'act_rel',
	"d5097eb3-4f7a-4187-8d85-db8765b299c4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d5097eb3-4f7a-4187-8d85-db8765b299c4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relate>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("adcc66ef-8480-4080-8ccc-1c8086f742ef",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"dd0fd3f1-b737-409e-b37c-5f7518308ec5",
	'');
INSERT INTO S_SPARM
	VALUES ("4b39a960-38e5-4edf-8e2a-1387c16ca900",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"adcc66ef-8480-4080-8ccc-1c8086f742ef",
	'');
INSERT INTO PE_PE
	VALUES ("8644d33b-9954-4438-97ab-f130505c0621",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("17595ebc-9b3b-4a65-9834-4433f9a542a3",
	"00000000-0000-0000-0000-000000000000",
	'transformRelateUsing',
	'',
	'act_ru = param.act_ru;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ru->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// select the relationship
select one r_rel related by act_ru->R_REL[R654];
select one one_v_var related by act_ru->V_VAR[R617];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_ru->V_VAR[R618];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one link_v_var related by act_ru->V_VAR[R619];
select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
select one link_class related by link_o_obj->Class[R409];
if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
  other_phrase = C_UTIL::stripTics( s:act_ru.relationship_phrase );
  select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_ru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
  select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
  select any one_oir from instances of R_OIR where false;
  for each oir in oirs
    if ( not_empty link and oir.OIR_ID != link.OIR_ID )
      one_oir = oir;
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
      break;
    end if;
  end for;
  if ( empty one_oir )
    // TODO bad
  end if;
else // non-reflexive linked association
  select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
  select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
  if ( not_empty one_oir and not_empty other_oir )
    one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
    other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
  else
    // TODO bad
  end if;
end if;
select any rel1 from instances of Relationship where false;
select any rel2 from instances of Relationship where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
  select any rel1 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
  select any rel2 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
else
  // TODO bad
end if;
if ( not_empty rel1 and not_empty rel2 )
  // create first relate statement (one to link)
  create object instance relsmt1 of RelateSmt;
  relate relsmt1 to smt across R451;
  relate rel1 to relsmt1 across R481;
  // create variable reference expression for formalizer for the first relate
  create object instance form_expr1 of Expression;
  relate form_expr1 to smt across R775;
  form_expr1.expression_number = "1";
  relate relsmt1 to form_expr1 across R479;
  form_var = ::getVariableInScope(smt:smt, name:link_v_var.Name);
  form_type = ::getTypeReferenceForV_VAR(v_var:link_v_var);
  relate form_type to form_expr1 across R795;
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr1 across R776;
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the first relate
  create object instance part_expr1 of Expression;
  relate part_expr1 to smt across R775;
  part_expr1.expression_number = "2";
  relate relsmt1 to part_expr1 across R480;
  part_var = ::getVariableInScope(smt:smt, name:one_v_var.Name);
  part_type = ::getTypeReferenceForV_VAR(v_var:one_v_var);
  relate part_type to part_expr1 across R795;
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr1 across R776;
  elif ( "self" == one_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create second relate statement (other to link)
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = STRING::itoa( i:STRING::atoi( s:smt.statement_number ) + 1 );
  relate smt2 to smt across R477.''executes after'';
  smt2.actions = "";
  create object instance relsmt2 of RelateSmt;
  relate relsmt2 to smt2 across R451;
  relate rel2 to relsmt2 across R481;
  // create variable reference expression for formalizer for the second relate
  create object instance form_expr2 of Expression;
  relate form_expr2 to smt2 across R775;
  form_expr2.expression_number = "1";
  relate relsmt2 to form_expr2 across R479;
  relate form_type to form_expr2 across R795;
  form_var = ::getVariableInScope(smt:smt, name:link_v_var.Name);
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr2 across R776;
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the second relate
  create object instance part_expr2 of Expression;
  relate part_expr2 to smt2 across R775;
  part_expr2.expression_number = "2";
  relate relsmt2 to part_expr2 across R480;
  part_var = ::getVariableInScope(smt:smt, name:other_v_var.Name);
  part_type = ::getTypeReferenceForV_VAR(v_var:other_v_var);
  relate part_type to part_expr2 across R795;
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr2 across R776;
  elif ( "self" == other_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // couple the two statements together
  relate relsmt1 to relsmt2 across R523.''couples with'';
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("c8b2f235-5faf-4c10-8efb-a0100f64f453",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'act_ru',
	"d67aab73-fa78-4bdb-b3a2-3d9eb1e798e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d67aab73-fa78-4bdb-b3a2-3d9eb1e798e2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relate Using>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("0b1f5daa-5019-4d3f-9e24-081df02b7f43",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"c8b2f235-5faf-4c10-8efb-a0100f64f453",
	'');
INSERT INTO S_SPARM
	VALUES ("7a53e811-2dad-48b3-b4f8-af62426fb774",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"0b1f5daa-5019-4d3f-9e24-081df02b7f43",
	'');
INSERT INTO PE_PE
	VALUES ("17595ebc-9b3b-4a65-9834-4433f9a542a3",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	"00000000-0000-0000-0000-000000000000",
	'transformUnrelate',
	'',
	'act_unr = param.act_unr;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_unr->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create unrelate statement
create object instance unrelsmt of UnrelateSmt;
relate unrelsmt to smt across R451;
// select the relationship
select one r_rel related by act_unr->R_REL[R655];
select one one_v_var related by act_unr->V_VAR[R620];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_unr->V_VAR[R621];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
    other_phrase = C_UTIL::stripTics( s:act_unr.relationship_phrase );
    select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_unr.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
    if ( not_empty oir )
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
    else
      // TODO bad
    end if;
  else // non-reflexive simple association
    select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
    select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
    if ( not_empty one_oir and not_empty other_oir )
      one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
      other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
    else
      // TODO bad
    end if;
  end if;
else
  select one subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty subsup )
    one_phrase = "is_a";
    other_phrase = "is_a";
  end if;
end if;
select any form_v_var from instances of V_VAR where false;
select any part_v_var from instances of V_VAR where false;
select any form_obj from instances of O_OBJ where false;
select any part_obj from instances of O_OBJ where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
  select any rel related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
  if ( not_empty rel )
    form_v_var = one_v_var;
    form_obj = one_o_obj;
    part_v_var = other_v_var;
    part_obj = other_o_obj;
  else
    select any rel related by containing_comp_def->Relationship[R448]
      where ( selected.num == r_rel.Numb and
        ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
    form_v_var = other_v_var;
    form_obj = other_o_obj;
    part_v_var = one_v_var;
    part_obj = one_o_obj;
  end if;
  if ( not_empty rel )
    relate rel to unrelsmt across R484;
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;
// create variable reference expression for formalizer
create object instance form_expr of Expression;
relate form_expr to smt across R775;
form_expr.expression_number = "1";
relate unrelsmt to form_expr across R483;
form_var = ::getVariableInScope(smt:smt, name:form_v_var.Name);
form_type = ::getTypeReferenceForV_VAR(v_var:form_v_var);
relate form_type to form_expr across R795;
if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate form_var to var_ref across R782;
  relate var_ref to form_expr across R776;
elif ( "self" == form_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to form_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;
// create variable reference expression for participant
create object instance part_expr of Expression;
relate part_expr to smt across R775;
part_expr.expression_number = "2";
relate unrelsmt to part_expr across R482;
part_var = ::getVariableInScope(smt:smt, name:part_v_var.Name);
part_type = ::getTypeReferenceForV_VAR(v_var:part_v_var);
relate part_type to part_expr across R795;
if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate part_var to var_ref across R782;
  relate var_ref to part_expr across R776;
elif ( "self" == part_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to part_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1dac3743-7efa-410e-9f60-f1bdfe79b3ce",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'act_unr',
	"eb4d7904-ebb3-44a2-a564-13c9f7978b60",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eb4d7904-ebb3-44a2-a564-13c9f7978b60",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Unrelate>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("c781e493-f545-4b53-bea8-5f604cae99ed",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"1dac3743-7efa-410e-9f60-f1bdfe79b3ce",
	'');
INSERT INTO S_SPARM
	VALUES ("94993921-0dad-4ee2-a3b6-51979d5ac418",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"c781e493-f545-4b53-bea8-5f604cae99ed",
	'');
INSERT INTO PE_PE
	VALUES ("ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("48985724-4b82-49d9-9e43-d57a9ed432fd",
	"00000000-0000-0000-0000-000000000000",
	'transformUnrelateUsing',
	'',
	'act_uru = param.act_uru;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_uru->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableObject[R4000];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// select the relationship
select one r_rel related by act_uru->R_REL[R656];
select one one_v_var related by act_uru->V_VAR[R622];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_uru->V_VAR[R623];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one link_v_var related by act_uru->V_VAR[R624];
select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
select one link_class related by link_o_obj->Class[R409];
if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
  other_phrase = C_UTIL::stripTics( s:act_uru.relationship_phrase );
  select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_uru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
  select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
  select any one_oir from instances of R_OIR where false;
  for each oir in oirs
    if ( not_empty link and oir.OIR_ID != link.OIR_ID )
      one_oir = oir;
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
      break;
    end if;
  end for;
  if ( empty one_oir )
    // TODO bad
  end if;
else // non-reflexive linked association
  select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
  select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
  if ( not_empty one_oir and not_empty other_oir )
    one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
    other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
  else
    // TODO bad
  end if;
end if;
select any rel1 from instances of Relationship where false;
select any rel2 from instances of Relationship where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
  select any rel1 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
  select any rel2 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
else
  // TODO bad
end if;
if ( not_empty rel1 and not_empty rel2 )
  // create first unrelate statement (one to link)
  create object instance unrelsmt1 of UnrelateSmt;
  relate unrelsmt1 to smt across R451;
  relate rel1 to unrelsmt1 across R484;
  // create variable reference expression for formalizer for the first unrelate
  create object instance form_expr1 of Expression;
  relate form_expr1 to smt across R775;
  form_expr1.expression_number = "1";
  relate unrelsmt1 to form_expr1 across R483;
  form_var = ::getVariableInScope(smt:smt, name:link_v_var.Name);
  form_type = ::getTypeReferenceForV_VAR(v_var:link_v_var);
  relate form_type to form_expr1 across R795;
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr1 across R776;
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the first relate
  create object instance part_expr1 of Expression;
  relate part_expr1 to smt across R775;
  part_expr1.expression_number = "2";
  relate unrelsmt1 to part_expr1 across R482;
  part_var = ::getVariableInScope(smt:smt, name:one_v_var.Name);
  part_type = ::getTypeReferenceForV_VAR(v_var:one_v_var);
  relate part_type to part_expr1 across R795;
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr1 across R776;
  elif ( "self" == one_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create second relate statement (other to link)
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = STRING::itoa( i:STRING::atoi( s:smt.statement_number ) + 1 );
  relate smt2 to smt across R477.''executes after'';
  smt2.actions = "";
  create object instance unrelsmt2 of UnrelateSmt;
  relate unrelsmt2 to smt2 across R451;
  relate rel2 to unrelsmt2 across R484;
  // create variable reference expression for formalizer for the second relate
  create object instance form_expr2 of Expression;
  relate form_expr2 to smt2 across R775;
  form_expr2.expression_number = "1";
  relate unrelsmt2 to form_expr2 across R483;
  relate form_type to form_expr2 across R795;
  form_var = ::getVariableInScope(smt:smt, name:link_v_var.Name);
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr2 across R776;
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the second relate
  create object instance part_expr2 of Expression;
  relate part_expr2 to smt2 across R775;
  part_expr2.expression_number = "2";
  relate unrelsmt2 to part_expr2 across R482;
  part_var = ::getVariableInScope(smt:smt, name:other_v_var.Name);
  part_type = ::getTypeReferenceForV_VAR(v_var:other_v_var);
  relate part_type to part_expr2 across R795;
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr2 across R776;
  elif ( "self" == other_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // couple the two statements together
  relate unrelsmt1 to unrelsmt2 across R452.''couples with'';
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("777239a3-27e7-410e-935e-0b4299d7115e",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'act_uru',
	"0c25b822-1415-4179-a600-998ebcb89b17",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0c25b822-1415-4179-a600-998ebcb89b17",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Unrelate Using>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("f4c88b70-1d06-4464-968a-46acb41222ec",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"777239a3-27e7-410e-935e-0b4299d7115e",
	'');
INSERT INTO S_SPARM
	VALUES ("b683f05a-48a7-4c5b-8949-a3438906cdee",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"f4c88b70-1d06-4464-968a-46acb41222ec",
	'');
INSERT INTO PE_PE
	VALUES ("48985724-4b82-49d9-9e43-d57a9ed432fd",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1086e27e-2bff-450b-b9e1-903ffcc7f983",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameter',
	'',
	'invocation = param.invocation;
parm = param.parm;
v_par = param.v_par;
prev_act_parm = param.prev_act_parm;
expr_number = param.expression_num;

select one smt related by invocation->Expression[R776]->Statement[R775];

select any expr from instances of Expression where false;

select one v_val related by v_par->V_VAL[R800];
if ( not_empty v_val )
  ::transformExpression(v_val:v_val, expr_number:expr_number, smt:smt);
  select any expr related by smt->Expression[R775] where (selected.expression_number == expr_number);
else
  // TODO bad
end if;

if ( not_empty expr )

  // create the actual parameter
  create object instance act_parm of ActualParameter;
  relate act_parm to expr across R794;
  relate invocation to act_parm across R793;
  if (not_empty parm)
    relate act_parm to parm across R3904;
  end if;
  if (not_empty prev_act_parm)
    relate prev_act_parm to act_parm across R3905.''precedes'';
  end if;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("58a320b8-144a-4b2d-bf9f-794e7007f45b",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'invocation',
	"887d1375-b0ab-4462-b2be-ec5b8e265583",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("887d1375-b0ab-4462-b2be-ec5b8e265583",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocation>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/expression/expression.xtuml');
INSERT INTO S_SPARM
	VALUES ("951ecc90-134e-49da-9ed8-c63a155663e0",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'parm',
	"4f106c1b-2473-4622-9798-816c7eb93613",
	0,
	'',
	"58a320b8-144a-4b2d-bf9f-794e7007f45b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4f106c1b-2473-4622-9798-816c7eb93613",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Formal Parameter>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("395d0c03-151e-48dc-a94c-3446a5137c72",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'expression_num',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"951ecc90-134e-49da-9ed8-c63a155663e0",
	'');
INSERT INTO S_SPARM
	VALUES ("ccea4989-d98a-418c-9e68-f3c4f0a37fcf",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'v_par',
	"2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	0,
	'',
	"395d0c03-151e-48dc-a94c-3446a5137c72",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("d1b3d818-7d61-4e09-8a18-23cac76427be",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'prev_act_parm',
	"15f335b9-816f-44ca-811f-2a2daa85f28b",
	0,
	'',
	"ccea4989-d98a-418c-9e68-f3c4f0a37fcf",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15f335b9-816f-44ca-811f-2a2daa85f28b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Actual Parameter>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("1086e27e-2bff-450b-b9e1-903ffcc7f983",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameters',
	'',
	'invocation = param.invocation;
v_pars = param.v_pars;
expr_number = param.expr_number;
base_num = param.base_num;

// get first formal parameter
select any parm related by invocation->InvocableObject[R792]->FormalParameter[R429];
select one prev_parm related by parm->FormalParameter[R404.''follows''];
while ( not_empty prev_parm )
  parm = prev_parm;
  select one prev_parm related by parm->FormalParameter[R404.''follows''];
end while;

// get the last parameter in the current list
select any prev_act_parm related by invocation->ActualParameter[R793];
select one prev_prev_act_parm related by prev_act_parm->ActualParameter[R3905.''follows''];
while not_empty prev_prev_act_parm
  prev_act_parm = prev_prev_act_parm;
  select one prev_prev_act_parm related by prev_act_parm->ActualParameter[R3905.''follows''];
end while;

// transform each parameter
num = base_num;
select any v_par from instances of V_PAR where false;
while ( not_empty parm )
  for each par in v_pars
    if ( "p_" + par.Name == parm.name )
      v_par = par;
      break;
    end if;
  end for;
  ::transformActualParameter( invocation:invocation, parm:parm, expression_num:expr_number + "." + STRING::itoa( i:num ), v_par:v_par, prev_act_parm:prev_act_parm );
  select any prev_act_parm related by invocation->ActualParameter[R793] where (selected.expression_number == expr_number + "." + STRING::itoa( i:num ));
  select one parm related by parm->FormalParameter[R404.''precedes''];
  num = num + 1;
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1fe4d601-e86d-4986-81ce-83aa4a39f88e",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'invocation',
	"887d1375-b0ab-4462-b2be-ec5b8e265583",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5e01e39f-65f1-46fe-84b9-ecfda3d67470",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'v_pars',
	"cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	0,
	'',
	"1fe4d601-e86d-4986-81ce-83aa4a39f88e",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("f1e1995e-dc4c-4f29-93ec-f8e6d0cc1c9f",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5e01e39f-65f1-46fe-84b9-ecfda3d67470",
	'');
INSERT INTO S_SPARM
	VALUES ("ad54a420-a271-4416-8160-585c7d6b65d9",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'base_num',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"f1e1995e-dc4c-4f29-93ec-f8e6d0cc1c9f",
	'');
INSERT INTO PE_PE
	VALUES ("d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	"00000000-0000-0000-0000-000000000000",
	'transformBlock',
	'',
	'upper_block = param.upper_block;
act_blk = param.act_blk;
if (not_empty act_blk)

  invocable = param.invocable;

  // create code block
  create object instance block of CodeBlock;
  if ( empty upper_block )
    block.top_level = true;
  else
    select one invocable related by upper_block->InvocableObject[R4000];
    block.top_level = false;
    relate block to upper_block across R498.''contained by'';
  end if;
  relate block to invocable across R4000;
  block.block_number = param.block_number;

  // copy visibile variables from upper block
  select many vars related by upper_block->VariableInScope[R458];
  for each var in vars
		create object instance var_in_scope of VariableInScope;
		var_in_scope.distance = var.distance + 1;
		select one var_decl related by var->Variable[R458];
		relate var_decl to block across R458 using var_in_scope;
  end for;

  // create variable declarations for this code block
  ::transformVariables(act_blk:act_blk, block:block);

  // transform all statements
  ::transformStatements( act_blk:act_blk, block:block );

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("c7c645e5-1940-478e-9373-907b72bb2272",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'upper_block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"af2f4c5c-5579-48a7-afc9-c6d816d71299",
	'');
INSERT INTO S_SPARM
	VALUES ("48703f0c-67e0-473b-aede-2525092b2198",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"c7c645e5-1940-478e-9373-907b72bb2272",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("069f7c9f-7387-4d78-8d66-5f72c773e58e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Block>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("47463209-70cd-45f6-8be8-763363b0cfe6",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"48703f0c-67e0-473b-aede-2525092b2198",
	'');
INSERT INTO S_SPARM
	VALUES ("af2f4c5c-5579-48a7-afc9-c6d816d71299",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'invocable',
	"3ab44839-4426-4754-b12a-0a00ce4dae1a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3ab44839-4426-4754-b12a-0a00ce4dae1a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocable Object>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/invocable/invocable.xtuml');
INSERT INTO PE_PE
	VALUES ("c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1f9fe480-5772-4b3b-9bc1-137bca58c156",
	"00000000-0000-0000-0000-000000000000",
	'transformBlockForElif',
	'',
	'upper_block = param.upper_block;
act_el = param.act_el;

// create block
select one invocable related by upper_block->InvocableObject[R4000];
create object instance block of CodeBlock;
relate block to invocable across R4000;
block.block_number = param.block_number;
relate block to upper_block across R498.''contained by'';

// copy visibile variables from upper block
select many vars related by upper_block->VariableInScope[R458];
for each var in vars
	create object instance var_in_scope of VariableInScope;
	var_in_scope.distance = var.distance + 1;
	select one var_decl related by var->Variable[R458];
	relate var_decl to block across R458 using var_in_scope;
end for;

// create single statement in block
create object instance smt of Statement;
relate smt to block across R450;
smt.statement_number = "1";
select one body related by block->InvocableObject[R4000];
select one act_smt related by act_el->ACT_SMT[R603];
smt.actions = ::getOalStatement(act_smt:act_smt);
smt.line_number = act_smt.LineNumber;

// create if statement
create object instance if_smt of IfSmt;
relate if_smt to smt across R451;
if_smt.is_else_if = true;

// translate if expression
select one if_val related by act_el->V_VAL[R659];
::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
select any if_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate if_expr to if_smt across R471;

// create then block
select any empty_invocable from instances of InvocableObject where false;
then_block_number = ::getNextBlockNumber( upper_block:block );
select one then_blk related by act_el->ACT_BLK[R658];
::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocable:empty_invocable );
select any then_block related by block->InvocableObject[R4000]->CodeBlock[R4000] where ( selected.block_number == then_block_number );
relate then_block to if_smt across R453;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e32ea91a-410f-40ab-accd-76e327852918",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'upper_block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a7dfa395-bf16-4110-8ff6-c5f19da15fe0",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'act_el',
	"c73f7572-ce31-4792-9718-8a411cbfe1eb",
	0,
	'',
	"e32ea91a-410f-40ab-accd-76e327852918",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c73f7572-ce31-4792-9718-8a411cbfe1eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ElseIf Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("51da31a8-3182-4ffc-8f99-df45099bc3f7",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a7dfa395-bf16-4110-8ff6-c5f19da15fe0",
	'');
INSERT INTO PE_PE
	VALUES ("1f9fe480-5772-4b3b-9bc1-137bca58c156",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	"00000000-0000-0000-0000-000000000000",
	'transformBody',
	'',
	'invocable = param.invocable;
select one act_act related by invocable->ACT_ACT[R432];
if ( not_empty act_act and not_empty invocable )
    
  // check if deferred operation
  select one deferral related by act_act->ACT_OPB[R698]->O_TFR[R696]->O_DEF[R126];
  if (not_empty deferral and STRING::indexof(haystack:invocable.name, needle:"_supertype_") != 0)
    ::transformDeferral(invocable:invocable, deferral:deferral);
  else
    select any upper_block from instances of CodeBlock where false;
    select one act_blk related by act_act->ACT_BLK[R666];
    ::transformBlock( invocable:invocable, upper_block:upper_block, act_blk:act_blk, block_number:"1" );
    
    // finalize variables referenced from within a where clause
    ::resloveVariableFinalizations( invocable:invocable );
  end if;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("bce2fe74-a3cb-4614-8044-7d471c36ab0d",
	"e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	'invocable',
	"3ab44839-4426-4754-b12a-0a00ce4dae1a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("04db27cc-9322-4de2-9d0d-d758274a9cda",
	"00000000-0000-0000-0000-000000000000",
	'transformStatement',
	'',
	'act_smt = param.act_smt;
block = param.block;
prev_smt = param.prev_smt;
if ( empty act_smt or empty block )
  // TODO bad
end if;

select one act_brg related by act_smt->ACT_BRG[R603];
if ( not_empty act_brg )
  ::transformBridgeInvocation( act_brg:act_brg, block:block, prev_smt:prev_smt );
  
else
select one act_fnc related by act_smt->ACT_FNC[R603];
if ( not_empty act_fnc )
  ::transformFunctionInvocation( act_fnc:act_fnc, block:block, prev_smt:prev_smt );
  
else
select one act_tfm related by act_smt->ACT_TFM[R603];
if ( not_empty act_tfm )
  ::transformOperationInvocation( act_tfm:act_tfm, block:block, prev_smt:prev_smt );
  
else
select one act_sgn related by act_smt->ACT_SGN[R603];
if ( not_empty act_sgn )
  ::transformSignalInvocation( act_sgn:act_sgn, block:block, prev_smt:prev_smt );
  
else
select one act_if related by act_smt->ACT_IF[R603];
if ( not_empty act_if )
  ::transformIfStatement( act_if:act_if, block:block, prev_smt:prev_smt );
  
else
select one act_whl related by act_smt->ACT_WHL[R603];
if ( not_empty act_whl )
  ::transformWhileStatement( act_whl:act_whl, block:block, prev_smt:prev_smt );
  
else
select one act_brk related by act_smt->ACT_BRK[R603];
if ( not_empty act_brk )
  ::transformBreakStatement( act_brk:act_brk, block:block, prev_smt:prev_smt );

else
select one act_con related by act_smt->ACT_CON[R603];
if ( not_empty act_con )
  ::transformContinueStatement( act_con:act_con, block:block, prev_smt:prev_smt );

else
select one act_ai related by act_smt->ACT_AI[R603];
if ( not_empty act_ai )
  ::transformAssignToMember( act_ai:act_ai, block:block, prev_smt:prev_smt );

else
select one act_for related by act_smt->ACT_FOR[R603];
if ( not_empty act_for )
  ::transformForStatement( act_for:act_for, block:block, prev_smt:prev_smt );

else
select one act_fio related by act_smt->ACT_FIO[R603];
if ( not_empty act_fio )
  ::transformSelectFromInstances( act_fio:act_fio, block:block, prev_smt:prev_smt );

else
select one act_fiw related by act_smt->ACT_FIW[R603];
if ( not_empty act_fiw )
  ::transformSelectFromInstancesWhere( act_fiw:act_fiw, block:block, prev_smt:prev_smt );

else
select one act_sel related by act_smt->ACT_SEL[R603];
if ( not_empty act_sel )
  ::transformSelect( act_sel:act_sel, block:block, prev_smt:prev_smt );

else 
select one act_cr related by act_smt->ACT_CR[R603];
if ( not_empty act_cr )
  ::transformCreate( act_cr:act_cr, block:block, prev_smt:prev_smt );

else
select one act_cnv related by act_smt->ACT_CNV[R603];
if ( not_empty act_cnv )
  ::transformCreateNoVariable( act_cnv:act_cnv, block:block, prev_smt:prev_smt );
 
else
select one act_ctl related by act_smt->ACT_CTL[R603];
if ( not_empty act_ctl )
  ::transformControl( act_ctl:act_ctl, block:block, prev_smt:prev_smt );

else
select one act_del related by act_smt->ACT_DEL[R603];
if ( not_empty act_del )
  ::transformDelete( act_del:act_del, block:block, prev_smt:prev_smt );

else
select one act_ret related by act_smt->ACT_RET[R603];
if ( not_empty act_ret )
  ::transformReturnStatement( act_ret:act_ret, block:block, prev_smt:prev_smt );

else
select one act_rel related by act_smt->ACT_REL[R603];
if ( not_empty act_rel )
  ::transformRelate( act_rel:act_rel, block:block, prev_smt:prev_smt );

else
select one act_ru related by act_smt->ACT_RU[R603];
if ( not_empty act_ru )
  ::transformRelateUsing( act_ru:act_ru, block:block, prev_smt:prev_smt );

else
select one act_unr related by act_smt->ACT_UNR[R603];
if ( not_empty act_unr )
  ::transformUnrelate( act_unr:act_unr, block:block, prev_smt:prev_smt );

else
select one act_uru related by act_smt->ACT_URU[R603];
if ( not_empty act_uru )
  ::transformUnrelateUsing( act_uru:act_uru, block:block, prev_smt:prev_smt );
  
else
select one e_ess related by act_smt->E_ESS[R603];
if ( not_empty e_ess )
  ::transformEventSpecificationStatement( e_ess:e_ess, block:block, prev_smt:prev_smt );

else
select one e_gpr related by act_smt->E_GPR[R603];
if ( not_empty e_gpr )
  LOG::LogFailure(message:"Generate pre-existing event is not supported");

else
  LOG::LogFailure( message:"statement type not supported" );
end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("6a797716-53e0-4e73-a25b-a85802ff8f54",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'act_smt',
	"8ca0ad46-f8b8-47ba-9456-548bf0777490",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8ca0ad46-f8b8-47ba-9456-548bf0777490",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("7ddfbe6a-6e18-4242-92c6-9c6c0090d58c",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"6a797716-53e0-4e73-a25b-a85802ff8f54",
	'');
INSERT INTO S_SPARM
	VALUES ("85a83eca-bdf5-487b-9110-50b786be86c7",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"7ddfbe6a-6e18-4242-92c6-9c6c0090d58c",
	'');
INSERT INTO PE_PE
	VALUES ("04db27cc-9322-4de2-9d0d-d758274a9cda",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bb386e4f-49ba-4b23-b465-577216ff4555",
	"00000000-0000-0000-0000-000000000000",
	'transformStatements',
	'',
	'act_blk = param.act_blk;
block = param.block;
// transform all statements
// BridgePoint produces statement lists in reverse order of what they would be expected
// to be according to the role phrases: https://support.onefact.net/issues/5382.
// This code appears to select the last statement which is actually the first statement.
// Then, when iterating to the next statement, it iterates backwards which is actually
// forwards (gah).
select any act_smt from instances of ACT_SMT where false;
select many act_smts related by act_blk->ACT_SMT[R602];
for each smt in act_smts
  if ( empty act_smt )
    act_smt = smt;
  else
    if ( smt.LineNumber < act_smt.LineNumber or smt.LineNumber == act_smt.LineNumber and smt.StartPosition < act_smt.StartPosition )
      act_smt = smt;
    end if;
  end if;
end for;

prev_smt = ::lastStatementInBlock(block:block);
while ( not_empty act_smt )
  // transform the statement
  ::transformStatement( act_smt:act_smt, block:block, prev_smt:prev_smt );
  
  // get the last created statement by selecting any ordered descending by statement number
  prev_smt = ::lastStatementInBlock(block:block);

  // see if array needs to be declared
  ::resolveArrayDeclaration(smt:prev_smt);
  
  // get next statement
  select one act_smt related by act_smt->ACT_SMT[R661.''succeeds''];
  
  // skip remaining statements if previous statement causes exit
  exiting_statement = ::getExitingStatement(block:block);
  if not_empty act_smt and not_empty exiting_statement
    select one invocable related by block->InvocableObject[R4000];
    ::semanticWarning(invocable:invocable, line_number:prev_smt.line_number, message:"Warning! Skipping unreachable statements after block exiting statement");
    return;
  end if;

end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("50ed669c-51ab-49f7-8029-0a7263aac5e5",
	"bb386e4f-49ba-4b23-b465-577216ff4555",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d1fafd85-9481-48cb-97e4-7ac46c0814b6",
	"bb386e4f-49ba-4b23-b465-577216ff4555",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"50ed669c-51ab-49f7-8029-0a7263aac5e5",
	'');
INSERT INTO PE_PE
	VALUES ("bb386e4f-49ba-4b23-b465-577216ff4555",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("66cd847e-1baf-4368-98bd-abc7fffced6f",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectionLink',
	'',
	'act_lnk = param.act_lnk;
smt = param.smt;
expr_number = param.expr_number;

// create expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = expr_number;

// create select expression
create object instance sel of SelectExpr;
relate sel to expr across R776;
create object instance sel_rel of SelectRelated;
relate sel_rel to sel across R789;

// transform the previous link
select any base_expr from instances of Expression where false;
select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds''];
select any base_class from instances of Class where false;
if ( not_empty prev_lnk )
  ::transformSelectionLink( act_lnk:prev_lnk, expr_number:expr_number + ".1", smt:smt );
  select any base_expr related by smt->Expression[R775] where ( selected.expression_number == expr_number + ".1" );
  relate base_expr to sel_rel across R791;
  select one base_class related by prev_lnk->O_OBJ[R678]->Class[R409];
else
  select one base_val related by act_lnk->ACT_SEL[R637]->V_VAL[R613];
  select one base_class related by base_val->V_IRF[R801]->V_VAR[R808]->V_INT[R814]->O_OBJ[R818]->Class[R409];
  ::transformExpression( v_val:base_val, expr_number:expr_number + ".1", smt:smt );
  select any base_expr related by smt->Expression[R775] where ( selected.expression_number == expr_number + ".1" );
  relate base_expr to sel_rel across R791;
end if;

// link type
select one base_expr_stream_type related by base_expr->TypeReference[R795]->StreamTypeReference[R3801];
select one target_class related by act_lnk->O_OBJ[R678]->Class[R409];
select any type from instances of TypeReference where false;
if not_empty base_expr_stream_type or ::act_lnkGetMult( act_lnk:act_lnk ) == Mult::MANY
  type = ::getObjectStreamReference(obj:target_class);
else
  type = ::getObjectReference(obj:target_class);
end if;
relate type to expr across R795;

// get the selector
select one r_rel related by act_lnk->R_REL[R681];
phrase = C_UTIL::stripTics( s:act_lnk.Rel_Phrase );
if ( "" == phrase ) // if the phrase is not included, may need to get the phrase for getting the selector
  select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                 selected.form_name == target_class.name and
                                                                 selected.part_name == base_class.name ); // if no phrase was included, the target and base class must be different
  if ( not_empty relationship )
    phrase = relationship.form_phrase;
  else
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == base_class.name and
                                                                   selected.part_name == target_class.name );
    if ( not_empty relationship )
      phrase = relationship.part_phrase;
    end if;
  end if;
end if;
selector_name = "R" + STRING::itoa( i:r_rel.Numb ) + "_";
if ( "" != phrase )
  selector_name = selector_name + T::sub( format:"_", s:phrase ) + "_";
end if;
selector_name = selector_name + target_class.name;
select any selector related by base_class->Selector[R442] where ( selected.name == selector_name );
if ( not_empty selector )
  relate selector to sel_rel across R797;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2ba68ecf-32d2-466e-bb9a-4d61abfd64fd",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("cb909a0f-1538-4a1c-bf9b-480f132d9279",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2ba68ecf-32d2-466e-bb9a-4d61abfd64fd",
	'');
INSERT INTO S_SPARM
	VALUES ("3d367fc8-3174-4399-b90f-e7160cc99484",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"cb909a0f-1538-4a1c-bf9b-480f132d9279",
	'');
INSERT INTO PE_PE
	VALUES ("66cd847e-1baf-4368-98bd-abc7fffced6f",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	"00000000-0000-0000-0000-000000000000",
	'resolveArrayDeclaration',
	'',
	'smt = param.smt;

select many declared_vars related by smt->Variable[R457];
for each declared_var in declared_vars
  select many var_refs related by declared_var->VariableReference[R782] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
  select any earliest_var_ref from instances of VariableReference where false;
  for each var_ref in var_refs
    if ( empty earliest_var_ref or var_ref.expression_number < earliest_var_ref.expression_number )
      earliest_var_ref = var_ref;
    end if;
  end for;
  if ( not_empty earliest_var_ref )
    earliest_var_ref.declaration = true;
  end if;
end for;

select many array_vars related by smt->Expression[R775]->IndexedCollectionReference[R776]->Expression[R3900]->VariableReference[R776]->Variable[R782];
for each array_var in array_vars
  select one declaring_smt related by array_var->Statement[R457];
  if ( smt.block_number == declaring_smt.block_number and smt.statement_number == declaring_smt.statement_number ) // variable was declared in this statement
    select many array_refs related by array_var->VariableReference[R782]->Expression[R776]->IndexedCollectionReference[R3900] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
    select any earliest_array_ref from instances of IndexedCollectionReference where false;
    for each array_ref in array_refs
      if ( empty earliest_array_ref or array_ref.expression_number < earliest_array_ref.expression_number )
        earliest_array_ref = array_ref;
      end if;
    end for;
    select one var_type related by array_var->TypeReference[R461];
    select one array_index related by earliest_array_ref->Expression[R3901];;
    T::push_buffer();
    array_index.render();
    // TODO handle array initialization
    //smt.prefix = smt.prefix + var_type.type_reference_name + " " + array_var.name + " = new " + var_type.type_name + "[" + T::body() + "+1];\n";
    T::pop_buffer();
    // no longer need to mark the first reference as a declaration
    select many var_refs related by array_var->VariableReference[R782] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
    for each var_ref in var_refs
      var_ref.declaration = false;
    end for;
  end if;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("23c66a56-7518-4f4b-b8bc-15f4d63d9d19",
	"c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("56579a04-8946-4a1f-ac3e-d51efab8a618",
	"00000000-0000-0000-0000-000000000000",
	'transformEventSpecificationStatement',
	'',
	'e_ess = param.e_ess;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by e_ess->ACT_SMT[R603];

select one e_ges related by e_ess->E_GES[R701];
if (not_empty e_ges)

  // create a statement
  create object instance smt of Statement;
  relate smt to block across R450;
  if (not_empty prev_smt)
    smt.statement_number = STRING::itoa(i:STRING::atoi(s:prev_smt.statement_number) + 1);
    relate smt to prev_smt across R477.''executes after'';
  else
    smt.statement_number = "1";
  end if;
  select one body related by block->InvocableObject[R4000];
  smt.actions = ::getOalStatement(act_smt:act_smt);
  smt.line_number = act_smt.LineNumber;

  // transform generate statements
  select one evt related by e_ges->E_GSME[R703]->SM_EVT[R707]->Event[R4759];
  select one target_v_var related by e_ges->E_GSME[R703]->E_GEN[R705]->V_VAR[R712];
  
  // create generate statement
  create object instance gen_smt of Generate;
  relate gen_smt to smt across R451;
  gen_smt.to_self = false;
  
  // create event reference expression
  create object instance evt_expr of Expression;
  relate evt_expr to smt across R775;
  evt_expr.expression_number = "1";
  obj_type_ref = ::getBasicTypeReferenceByName(name:"Object");
  relate obj_type_ref to evt_expr across R795;
  create object instance event_ref of EventReference;
  relate event_ref to evt_expr across R776;
  relate event_ref to evt across R3916;
  relate evt_expr to gen_smt across R486;

  // create the target expression
  create object instance target_expr of Expression;
  relate target_expr to smt across R775;
  target_expr.expression_number = "2";
  relate target_expr to gen_smt across R487;
  if (not_empty target_v_var)
    select one target_obj related by target_v_var->V_INT[R814]->O_OBJ[R818]->Class[R409];
    target_type = ::getObjectReference(obj:target_obj);
    relate target_type to target_expr across R795;
    target_var = ::getVariableInScope(smt:smt, name:target_v_var.Name);
    if (not_empty target_var)
      create object instance var_ref of VariableReference;
      relate target_var to var_ref across R782;
      relate var_ref to target_expr across R776;
    elif (target_v_var.Name == "self")
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to target_expr across R776;
      self_ref.name = "self()";
      gen_smt.to_self = true;
    else
      // TODO bad
    end if;
  else
    void_type = ::getBasicTypeReferenceByName(name:"void");
    relate void_type to target_expr across R795;
    // create class state machine reference
    create object instance state_machine_ref of ClassStateMachineReference;
    relate state_machine_ref to target_expr across R776;
    select one sm related by evt->Class[R4752]->StateMachine[R4750];
    relate sm to state_machine_ref across R3922;
  end if;

  // transform event parameters
  select many v_pars related by e_ess->V_PAR[R700];
  select any null_expr from instances of Expression where false;
  ::transformEventParameters(smt:smt, expr:null_expr, evt:evt, v_pars:v_pars, base_num:3);
  
else
  
  // event creation statements not supported except directly preceding a timer start invocation

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("987c4060-b7f5-4209-a28f-a21665d23a52",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'e_ess',
	"a885b904-2a7c-42ce-bc53-db13d709ae6f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a885b904-2a7c-42ce-bc53-db13d709ae6f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Event Specification Statement>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Event/Event.xtuml');
INSERT INTO S_SPARM
	VALUES ("81098ce2-32c5-4ea7-95de-124f52bad3bb",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"987c4060-b7f5-4209-a28f-a21665d23a52",
	'');
INSERT INTO S_SPARM
	VALUES ("9eb8d78c-fe64-46fb-84ea-d1dcd014404f",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"81098ce2-32c5-4ea7-95de-124f52bad3bb",
	'');
INSERT INTO PE_PE
	VALUES ("56579a04-8946-4a1f-ac3e-d51efab8a618",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	"00000000-0000-0000-0000-000000000000",
	'transformDeferral',
	'',
	'invocable = param.invocable;
deferral = param.deferral;

select one o_tfr related by deferral->O_TFR[R126];
select one type related by invocable->TypeReference[R428];
returns_value = "void" != type.type_reference;
select many subtypes related by deferral->R_REL[R126]->R_SUBSUP[R206]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];

// create code block
create object instance block of CodeBlock;
block.top_level = true;
relate block to invocable across R4000;
block.block_number = "1";

// create an invocation for each subtype
for each subtype in subtypes

  // create a select statement
  create object instance smt of Statement;
  relate smt to block across R450;
  smt.statement_number = "1";
  smt.actions = "";
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  // create binary operation and assignment expression
  create object instance binop of BinaryOperation;
  relate binop to expr across R776;
  binop.operator = "=";
  binop.invocation = false;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create left operand
  create object instance l_op of Expression;
  relate l_op to smt across R775;
  l_op.expression_number = "1.1";
  select any subtype_invocable related by subtype->O_TFR[R115]->ACT_OPB[R696]->ACT_ACT[R698]->InvocableObject[R432] where (selected.name == invocable.name);
  target_invocable = subtype_invocable;
  if (empty subtype_invocable and deferral.required == 1)  // deferral is optional
    select any target_invocable related by invocable->Operation[R427]->Class[R416]->Operation[R416]->InvocableObject[R427] where (selected.name == "_supertype_" + invocable.name);
  elif (empty subtype_invocable and deferral.required != 1)
    LOG::LogFailure(message:"Could not find matching operation: " + invocable.name + " for subtype: " + subtype.Name);
  end if;
  select one select_class related by subtype->Class[R409];
  select_type = ::getObjectReference(obj:select_class);
  relate select_type to l_op across R795;
  // create new variable
  create object instance select_var of Variable;
  relate select_var to smt across R457;
  select_var.name = T::sub(format:"l", s:select_class.name);
  // link in scope
  select one block related by smt->CodeBlock[R450];
  relate select_var to block across R496;
  create object instance var_in_scope of VariableInScope;
  relate select_var to block across R458 using var_in_scope;
  // link data type
  relate select_type to select_var across R461;
  // create variable reference
  create object instance var_ref of VariableReference;
  var_ref.declaration = true;
  relate select_var to var_ref across R782;
  relate var_ref to l_op across R776;
  relate l_op to binop across R779;
  // create right operand
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  // create select expression
  create object instance sel of SelectExpr;
  relate sel to r_op across R776;
  create object instance sel_rel of SelectRelated;
  relate sel_rel to sel across R789;
  // create named reference
  create object instance self_expr of Expression;
  relate self_expr to smt across R775;
  self_expr.expression_number = "1.2.1";
  select one self_class related by invocable->Operation[R427]->Class[R416];
  self_type = ::getObjectReference(obj:self_class);
  relate self_type to self_expr across R795;
  create object instance self_ref of NamedReference;
  relate self_ref to self_expr across R776;
  self_ref.name = "self()";
  relate self_expr to sel_rel across R791;
  // get the selector
  select one r_rel related by deferral->R_REL[R126];
  select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                 selected.form_name == select_class.name and
                                                                 selected.part_name == self_class.name ); // if no phrase was included, the target and base class must be different
  selector_name = "R" + STRING::itoa( i:r_rel.Numb ) + "_is_a_" + select_class.name;
  select any selector related by self_class->Selector[R442] where ( selected.name == selector_name );
  if ( not_empty selector )
    relate selector to sel_rel across R797;
  else
    // TODO bad
  end if;
  // link select type to the main expression
  relate select_type to expr across R795;
  
  // create if statement
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = "2";
  relate smt2 to smt across R477.''executes after'';
  smt2.actions = "";
  create object instance if_smt of IfSmt;
  relate if_smt to smt2 across R451;
  if_smt.is_else_if = false;
  // translate if expression
  create object instance if_expr of Expression;
  relate if_expr to smt2 across R775;
  if_expr.expression_number = "1";
  relate if_expr to if_smt across R471;
  // link type
  if_type = ::getBasicTypeReferenceByName(name:"boolean");
  relate if_type to if_expr across R795;
  // create the unary expression
  create object instance unary of UnaryOperation;
  relate unary to if_expr across R776;
  unary.operator = "!";
  unary.invocation = false;
  // create ''empty'' expression
  create object instance if_expr2 of Expression;
  relate if_expr2 to smt2 across R775;
  if_expr2.expression_number = "1.1";
  relate if_expr2 to unary across R777;
  relate if_type to if_expr2 across R795;
  create object instance unary2 of UnaryOperation;
  relate unary2 to if_expr2 across R776;
  unary2.operator = "isEmpty";
  unary2.invocation = true;
  // transform the operand expression
  create object instance op_expr of Expression;
  relate op_expr to smt2 across R775;
  op_expr.expression_number = "1.1.1";
  // link type
  relate select_type to op_expr across R795;
  // create variable reference
  create object instance op_var_ref of VariableReference;
  relate select_var to op_var_ref across R782;
  relate op_var_ref to op_expr across R776;
  relate op_expr to unary2 across R777;
  // create then block
  then_block_number = ::getNextBlockNumber(upper_block:block);
  create object instance then_block of CodeBlock;
  relate then_block to block across R498.''contained by'';
  then_block.top_level = false;
  relate then_block to invocable across R4000;
  then_block.block_number = then_block_number;
  relate then_block to if_smt across R453;
  // create invocation
  create object instance smt3 of Statement;
  relate smt3 to then_block across R450;
  smt3.statement_number = "1";
  smt3.actions = "";
  // create invocation expression
  create object instance invoc_expr of Expression;
  relate invoc_expr to smt3 across R775;
  invoc_expr.expression_number = "1";
  // link type
  void_type = ::getBasicTypeReferenceByName(name:"void");
  relate void_type to invoc_expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to invoc_expr across R776;
  relate invoc to target_invocable across R792;
  if (empty subtype_invocable and deferral.required == 1)  // deferral is optional
    // create named reference
    create object instance self_expr of Expression;
    relate self_expr to smt3 across R775;
    self_expr.expression_number = "1.1";
    relate self_type to self_expr across R795;
    relate self_expr to invoc across R798;
    create object instance self_ref of NamedReference;
    relate self_ref to self_expr across R776;
    self_ref.name = "self()";
  else
    // create variable reference expression
    create object instance invoc_expr2 of Expression;
    relate invoc_expr2 to smt3 across R775;
    invoc_expr2.expression_number = "1.1";
    relate invoc_expr2 to invoc across R798;
    relate select_type to invoc_expr2 across R795;
    create object instance invoc_var_ref of VariableReference;
    relate select_var to invoc_var_ref across R782;
    relate invoc_var_ref to invoc_expr2 across R776;
  end if;
  // transform actual parameters
  base_num = 2;
  select any prev_actual_parameter from instances of ActualParameter where false;
  select any formal_parameter related by target_invocable->FormalParameter[R429];
  select one prev_formal_parameter related by formal_parameter->FormalParameter[R404.''follows''];
  while (not_empty prev_formal_parameter)
    formal_parameter = prev_formal_parameter;
    select one prev_formal_parameter related by formal_parameter->FormalParameter[R404.''follows''];
  end while;
  while (not_empty formal_parameter)
    // create parameter reference
    select any referenced_formal_parameter related by invocable->FormalParameter[R429] where (selected.name == formal_parameter.name);
    create object instance param_ref_expr of Expression;
    relate param_ref_expr to smt3 across R775;
    param_ref_expr.expression_number = "1." + STRING::itoa(i:base_num);
    select one param_type related by formal_parameter->TypeReference[R431];
    relate param_type to param_ref_expr across R795;
    create object instance param_ref of ParameterReference;
    relate param_ref to param_ref_expr across R776;
    relate referenced_formal_parameter to param_ref across R781;
    // create actual parameter
    create object instance act_parm of ActualParameter;
    relate act_parm to param_ref_expr across R794;
    relate invoc to act_parm across R793;
    relate formal_parameter to act_parm across R3904;
    if (not_empty prev_actual_parameter)
      relate prev_actual_parameter to act_parm across R3905.''precedes'';
    end if;
    base_num = base_num + 1;
    prev_actual_parameter = act_parm;
    select one formal_parameter related by formal_parameter->FormalParameter[R404.''precedes''];
  end while;
  if (returns_value)
    // create return statement
    create object instance ret_smt of ReturnSmt;
    relate ret_smt to smt3 across R451;
    relate invoc_expr to ret_smt across R473;
  else
    // create expression as statement
    create object instance eas2 of ExpressionAsStatement;
    relate eas2 to smt3 across R451;
    relate invoc_expr to eas2 across R476;
  end if;
  // create else block
  else_block_number = ::getNextBlockNumber(upper_block:block);
  create object instance else_block of CodeBlock;
  else_block.top_level = false;
  relate else_block to invocable across R4000;
  else_block.block_number = else_block_number;
  relate else_block to if_smt across R454;
  relate else_block to block across R498.''contained by'';
  
  block = else_block;

end for;

// add an exception if no subtypes match
create object instance smt4 of Statement;
relate smt4 to block across R450;
smt4.statement_number = "1";
smt4.actions = "";
// create named references for thows
create object instance throws_expr of Expression;
relate throws_expr to smt4 across R775;
throws_expr.expression_number = "1.2.1";
void_type = ::getBasicTypeReferenceByName(name:"void");
relate void_type to throws_expr across R795;
create object instance throws_ref of NamedReference;
relate throws_ref to throws_expr across R776;
throws_ref.name = "throw new XtumlException(" + STRING::quote() + "No subtype selected" + STRING::quote() + ")";
// create expression as statement
create object instance eas3 of ExpressionAsStatement;
relate eas3 to smt4 across R451;
relate throws_expr to eas3 across R476;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("29cc6813-0b74-4cfe-899d-8def3337814c",
	"56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	'deferral',
	"b5231088-af9f-42ab-b08b-e1578453a954",
	0,
	'',
	"ea06b63f-8eb7-49ef-9a4e-cb5781f398ad",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b5231088-af9f-42ab-b08b-e1578453a954",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Deferral>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("ea06b63f-8eb7-49ef-9a4e-cb5781f398ad",
	"56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	'invocable',
	"3ab44839-4426-4754-b12a-0a00ce4dae1a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	"00000000-0000-0000-0000-000000000000",
	'transformEventParameters',
	'',
	'smt = param.smt;
expr = param.expr;
evt = param.evt;
v_pars = param.v_pars;
base_num = param.base_num;

expr_number = "";
if not_empty expr
  expr_number = expr.expression_number;
end if;

select one generate_smt related by smt->Generate[R451];
select one schedule_expr related by expr->Schedule[R776];
order = 1;

// loop through event formal parameters in order and find a matching actual parameter
select any formal_param related by evt->InvocableObject[R427]->FormalParameter[R429];
select one prev_formal_param related by formal_param->FormalParameter[R404.''follows''];
while not_empty prev_formal_param
  formal_param = prev_formal_param;
  select one prev_formal_param related by formal_param->FormalParameter[R404.''follows''];
end while;
while not_empty formal_param
  
  // wish there was a better way in OAL...
  select any v_par from instances of V_PAR where false;
  for each v_par in v_pars
    if "p_" + v_par.Name == formal_param.name;
      break;
    end if;
  end for;
  
  // transform the expression
  select one v_val related by v_par->V_VAL[R800];
  if (expr_number != "")
    expr_number = expr_number + ".";
  end if;
  expr_number = expr_number + STRING::itoa(i:base_num);
  ::transformExpression(v_val:v_val, expr_number:expr_number, smt:smt);
  select any expr related by smt->Expression[R775] where selected.expression_number == expr_number;
  
  // relate to the statement
  if not_empty generate_smt
		create object instance evt_arg of GenerateEventArgument;
		evt_arg.order = order;
		relate evt_arg to formal_param across R553;
		relate expr to generate_smt across R488 using evt_arg;
	elif not_empty schedule_expr
		create object instance evt_arg of ScheduleEventArgument;
		evt_arg.order = order;
		relate evt_arg to formal_param across R3930;
		relate expr to schedule_expr across R3913 using evt_arg;
	else
	  LOG::LogFailure(message:"cannot transform event parameter");
	end if;
  
  order = order + 1;
  base_num = base_num + 1;
  select one formal_param related by formal_param->FormalParameter[R404.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO S_SPARM
	VALUES ("ab2c4cc4-47f1-4244-8e3b-31542f01294c",
	"aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("e98a7819-aeb7-4c3e-9f5b-5f1a885b7436",
	"aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	'evt',
	"6f9d5490-60e9-489c-a2c7-507dc913da72",
	0,
	'',
	"8b9c0acf-6494-480d-b8fb-20f8a2ab120e",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6f9d5490-60e9-489c-a2c7-507dc913da72",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Event>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/statemachine/statemachine.xtuml');
INSERT INTO S_SPARM
	VALUES ("26f1c76c-efab-411e-9d5f-c89f452efc7d",
	"aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	'v_pars',
	"cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	0,
	'',
	"e98a7819-aeb7-4c3e-9f5b-5f1a885b7436",
	'');
INSERT INTO S_SPARM
	VALUES ("8b9c0acf-6494-480d-b8fb-20f8a2ab120e",
	"aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	'expr',
	"c732060c-653b-48f6-8ce5-99439b2a9c63",
	0,
	'',
	"ab2c4cc4-47f1-4244-8e3b-31542f01294c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c732060c-653b-48f6-8ce5-99439b2a9c63",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Expression>',
	'',
	'',
	'../../../../../core-architecture/models/core-architecture/architecture/expression/expression.xtuml');
INSERT INTO S_SPARM
	VALUES ("370634a7-d3fc-4c62-921e-0e6df9e1dcc4",
	"aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	'base_num',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"26f1c76c-efab-411e-9d5f-c89f452efc7d",
	'');
INSERT INTO PE_PE
	VALUES ("aebd9ad8-4479-40dd-abaf-2af93c833ae5",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("031efdba-e4fd-4f49-a706-41adaee562a2",
	"00000000-0000-0000-0000-000000000000",
	'transformVariables',
	'',
	'act_blk = param.act_blk;
block = param.block;

// create a forward delcaration for all vars defined in this scope
// ignore the deprecated event type and references to "self"
select any evt_dt from instances of S_DT where selected.Name == "inst<Event>";
select many v_vars related by act_blk->V_VAR[R823] where selected.DT_ID != evt_dt.DT_ID and selected.Name != "self";
for each v_var in v_vars
  
  // create a statement
  prev_smt = ::lastStatementInBlock(block:block);
  create object instance smt of Statement;
  relate smt to block across R450;
  if (not_empty prev_smt)
    smt.statement_number = STRING::itoa(i:STRING::atoi(s:prev_smt.statement_number) + 1);
    relate smt to prev_smt across R477.''executes after'';
  else
    smt.statement_number = "1";
  end if;

  // create new variable
  create object instance new_var of Variable;
  relate new_var to smt across R457;
  new_var.name = v_var.Name;
  var_type = ::getTypeReferenceForV_VAR(v_var:v_var);
  relate var_type to new_var across R461;
  
  // link in scope
  select one scope related by smt->CodeBlock[R450];
  relate new_var to scope across R496;
  create object instance var_in_scope of VariableInScope;
  relate new_var to scope across R458 using var_in_scope;

  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;

  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate var_type to expr across R795;
  relate expr to eas across R476;

  // create variable reference
  create object instance var_ref of VariableReference;
  relate new_var to var_ref across R782;
  relate var_ref to expr across R776;
  var_ref.declaration = true;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	2);
INSERT INTO S_SPARM
	VALUES ("71ce16cc-35bd-4dec-a4fc-9902743e213c",
	"031efdba-e4fd-4f49-a706-41adaee562a2",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("8bcadfc8-90ba-40cd-88b8-2d87434e9e20",
	"031efdba-e4fd-4f49-a706-41adaee562a2",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"71ce16cc-35bd-4dec-a4fc-9902743e213c",
	'');
INSERT INTO PE_PE
	VALUES ("031efdba-e4fd-4f49-a706-41adaee562a2",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("1aa08c2b-b96c-4c66-8c25-c079950eef10",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'transform',
	'',
	0,
	'../transform.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("9092a4a9-91f5-4e59-984b-3ca72917240d",
	'tool-core',
	1,
	'../../tool-core.xtuml');
