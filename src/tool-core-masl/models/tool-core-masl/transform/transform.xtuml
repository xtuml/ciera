-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"ff182108-eff3-4cdc-81dd-efdc6098874b",
	"ff182108-eff3-4cdc-81dd-efdc6098874b",
	'transform',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("47e4b6ea-f0f7-485f-ac79-7dc65833956f",
	112,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'',
	'tool-core-masl::transform');
INSERT INTO DIM_DIA
	VALUES ("47e4b6ea-f0f7-485f-ac79-7dc65833956f",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("4c867d76-54b3-4504-9e60-e54f73be10c2",
	"00000000-0000-0000-0000-000000000000",
	'transformDomain',
	'',
	'domain = param.domain;

if (param.pass == 1)

  // create the file
  create object instance file of File;
  file.name = ::camelCaseName(name:domain.name, start_lower:false);
  file.path = param.path;
  file.package = ::pathToPackage(path:file.path);
  file.extension = ".java";
  file.exclude = false;

  // create the component definition object
  create object instance comp_def of ComponentDefinition;
  relate comp_def to file across R401;
  comp_def.extends = "Component<" + comp_def.name + ">";
  comp_def.version = "";
  comp_def.version_date = "";
  
  // set version information TODO
  component_version = "";
  
  // TODO translate domain elements
  
  // transform services
  select many domain_services related by domain->DomainService[R5303];
  for each domain_service in domain_services
    ::transformDomainService(domain_service:domain_service, comp_def:comp_def);
  end for;

  // transform terminators
  select many terms related by domain->DomainTerminator[R5304];
  for each term in terms
    ::transformDomainTerminator(domain_terminator:term, comp_def:comp_def, path:file.path + "/" + T::sub(format:"l", s:term.name));
  end for;
  
  // transform objects
  select many object_declarations related by domain->ObjectDeclaration[R5805];
  for each object_declaration in object_declarations
    ::transformObject(object_declaration:object_declaration, comp_def:comp_def);
  end for;

  // transform instance population selectors
  select many objs related by comp_def->Class[R408];
  for each obj in objs
    create object instance inst_pop_selector of InstancePopulationSelector;
    inst_pop_selector.name = obj.name + "_instances";
    relate inst_pop_selector to comp_def across R447;
    relate inst_pop_selector to obj across R449;
  end for;
 
  // create import block
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.application.IApplication", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.application.IRunContext", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.components.Component", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.IModelInstance", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL);

  ::addStringToImports(file:file, s:"java.util.Map", type:ImportType::IMPL);
  ::addStringToImports(file:file, s:"java.util.TreeMap", type:ImportType::IMPL);
  
  if ("" != component_version)
    ::addStringToImports(file:file, s:"java.io.IOException", type:ImportType::IMPL);
    ::addStringToImports(file:file, s:"java.util.Properties", type:ImportType::IMPL);
  end if;

elif (param.pass == 2)

  select any file from instances of File where (selected.name == ::camelCaseName(name:domain.name, start_lower:false) and selected.package == ::pathToPackage(path:param.path));
  select one comp_def related by file->ComponentDefinition[R401];
  
  select many rels related by domain->RelationshipDeclaration[R6003];
  for each rel in rels
    ::transformRelationship(rel:rel, comp_def:comp_def);
  end for;

else

  select any file from instances of File where (selected.name == ::camelCaseName(name:domain.name, start_lower:false) and selected.package == ::pathToPackage(path:param.path));
  select one comp_def related by file->ComponentDefinition[R401];

  // transform selectors
  select many objs related by comp_def->Class[R408];
  for each obj in objs
    ::transformSelectors(obj:obj);
  end for;

  // transform relationship population selectors
  select many rels related by comp_def->Relationship[R448];
  for each rel in rels
    create object instance rel_pop_selector of RelationshipPopulationSelector;
    rel_pop_selector.name = rel.name + "s";
    relate rel_pop_selector to comp_def across R4571;
    relate rel_pop_selector to rel across R4572;
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	1);
INSERT INTO S_SPARM
	VALUES ("e060eb45-49af-4d1d-b4bb-880b8b10a937",
	"4c867d76-54b3-4504-9e60-e54f73be10c2",
	'domain',
	"d467079c-c61e-4b05-8498-3fe2f24782a6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d467079c-c61e-4b05-8498-3fe2f24782a6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Domain>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("2323d00b-3688-4778-bdd1-ed140fe79329",
	"4c867d76-54b3-4504-9e60-e54f73be10c2",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"e060eb45-49af-4d1d-b4bb-880b8b10a937",
	'');
INSERT INTO S_SPARM
	VALUES ("edc05e97-5ed4-4104-a130-64e0364e7841",
	"4c867d76-54b3-4504-9e60-e54f73be10c2",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2323d00b-3688-4778-bdd1-ed140fe79329",
	'');
INSERT INTO PE_PE
	VALUES ("4c867d76-54b3-4504-9e60-e54f73be10c2",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a273ac6b-7940-4d3d-8c41-b8c33c8c5922",
	"00000000-0000-0000-0000-000000000000",
	'transformMaslApplication',
	'',
	'// get application marks
select any app_name_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationName" );
select any app_pkg_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationPackage" );

// create the file
create object instance file of File;
if ( not_empty app_name_mark )
  file.name = app_name_mark.value;
else
  file.name = "UnnamedApplication";
end if;
if ( not_empty app_pkg_mark )
  file.package = app_pkg_mark.value;
  file.path = ::formatPath( path:file.package );
else
  file.path = "unnamedapplication";
  file.package = ::pathToPackage( path:file.path );
end if;
file.extension = ".java";
file.exclude = false;

// create the application object
create object instance app of Application;
relate app to file across R401;

// create application executors
index = 0;
while ( index < 1 ) // single executor for now
  create object instance executor of ApplicationExecutor;
  if ( app.async )
    executor.index = -1;
  else
    executor.index = index;
  end if;
  relate executor to app across R4027;
  index = index + 1;
end while;

// translate domains
select many domains from instances of Domain;
select any current_comp_inst from instances of ComponentInstantiation where false;
for each domain in domains
  ::transformDomain(domain:domain, path:file.path, pass:1);
  ::transformDomain(domain:domain, path:file.path, pass:2);
  ::transformDomain(domain:domain, path:file.path, pass:3);
  select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:domain.name, start_lower:false ) );
  create object instance comp_inst of ComponentInstantiation;
  relate  comp_def to app across R426 using comp_inst;
  select one comp_def_file related by comp_def->File[R401];
  ::addFileToImports( file:file, file_to_import:comp_def_file, type:ImportType::IMPL );
  select any executor related by app->ApplicationExecutor[R4027]; // single executor for now
  relate executor to comp_inst across R4028;
  if ( not_empty current_comp_inst )
    relate comp_inst to current_comp_inst across R4029.''follows'';
    comp_inst.index = current_comp_inst.index + 1;
  else
    comp_inst.index = 0;
  end if;
  current_comp_inst = comp_inst;
end for;

// create the import block
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.tasks.HaltExecutionTask", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.tasks.GenericExecutionTask", type:ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.Arrays", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.ApplicationExecutor", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.IApplication", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.ILogger", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.components.IComponent", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	2);
INSERT INTO PE_PE
	VALUES ("a273ac6b-7940-4d3d-8c41-b8c33c8c5922",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6337d8b4-4779-4670-be9f-e297eabcf5d1",
	"00000000-0000-0000-0000-000000000000",
	'transformDomainService',
	'',
	'domain_service = param.domain_service;
comp_def = param.comp_def;

select one service related by domain_service->Service[R5203];

// create function object
create object instance func of Function;
relate func to comp_def across R405;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = service.name;
invocable.parent_name = comp_def.name;
invocable.parent_package = comp_def.package;
relate func to invocable across R427;
//invocable.actions = s_sync.Action_Semantics_internal; // TODO

// link type TODO
type = ::TypeReference_getBuiltinTypeReference(name:"void");
relate type to invocable across R428;

/*
// create parameters
select any s_sparm related by s_sync->S_SPARM[R24];
prev_s_sparm = s_sparm;
// select first parameter
while ( not_empty prev_s_sparm )
  s_sparm = prev_s_sparm;
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
end while;
while ( not_empty s_sparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_sparm.Name;
  parm.by_ref = ( 1 == s_sparm.By_Ref );
  select one parm_dt related by s_sparm->S_DT[R26];
  select many s_dims related by s_sparm->S_DIM[R52];
  parm_type = ::TypeReference_getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
end while;

// see if this is an initializer function
select one c_c related by comp_def->C_C[R4573];
select one c_c_pe related by c_c->PE_PE[R8001];
select any init_function_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                             selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                             selected.feature_name == "InitFunction" );
if ( not_empty init_function_mark and func.name == init_function_mark.value )
  select any s_sparm related by s_sync->S_SPARM[R24];
  if ( empty s_sparm )
    select one init_function related by comp_def->Function[R4561];
    if ( empty init_function )
      relate func to comp_def across R4561;
    else
      // TODO bad
    end if;
  else
    // TODO bad
  end if;
end if;

// relate the body
select one act_act related by s_sync->ACT_FNB[R695]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
end if;
*/',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("5ee0efbd-acd2-4732-9a5f-db65dbabc35c",
	"6337d8b4-4779-4670-be9f-e297eabcf5d1",
	'domain_service',
	"ffebe79c-5289-41c4-9a6c-4c6b8346d989",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ffebe79c-5289-41c4-9a6c-4c6b8346d989",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<DomainService>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("6e4c46fe-109d-4d62-a11f-1a7070c44b2a",
	"6337d8b4-4779-4670-be9f-e297eabcf5d1",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"5ee0efbd-acd2-4732-9a5f-db65dbabc35c",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("109e90cb-1d66-46ee-88db-a568044879d0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/component/component.xtuml');
INSERT INTO PE_PE
	VALUES ("6337d8b4-4779-4670-be9f-e297eabcf5d1",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a167f7d5-3c79-4ff5-8b40-a091b9b1a31e",
	"00000000-0000-0000-0000-000000000000",
	'transformObject',
	'',
	'object_declaration = param.object_declaration;
comp_def = param.comp_def;
select one component_file related by comp_def->File[R401];
path = component_file.path + "/" + "classes";  // put all classes in one package called ''classes''

// get exclude mark
/* TODO
select one pe related by o_obj->PE_PE[R8001];
select any class_exclude_mark from instances of Mark where ( selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
                                                            selected.feature_name == "Exclude" );

// get mark for naming
select any class_name_mark from instances of Mark where ( selected.markable_name == "Model Class" and
																													selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
																													selected.feature_name == "UseKeyLettersForName" );
*/

// create the object file
create object instance file of File;
//if ( empty class_name_mark )
	file.name = ::camelCaseName(name:object_declaration.name, start_lower:false );
//else
//  file.name = o_obj.Key_Lett;
//end if;
file.path = path;
file.package = ::pathToPackage(path:file.path);
file.extension = ".java";
file.exclude = false;

// create the object
create object instance obj of Class;
relate obj to file across R401;
obj.key_letters = file.name;  // TODO key letters
obj.extends = "ModelInstance<" + obj.name + "," + comp_def.name + ">";

// add the class to the component
relate obj to comp_def across R408;

// connect to the arch model
relate obj to object_declaration across R8300;

// create the instance type
create object instance type of Type;
type.name = obj.name;
type.package = obj.package;
type.default_value = obj.name + "Impl.EMPTY_" + T::sub( format:"_u", s:obj.name );
relate type to obj across R407;

// transform attributes
select any maslattr related by object_declaration->AttributeDeclaration[R5802];
select one prev_attr related by maslattr->AttributeDeclaration[R5809.''succeeds''];
while (not_empty prev_attr)
  maslattr = prev_attr;
  select one prev_attr related by maslattr->AttributeDeclaration[R5809.''succeeds''];
end while;
index = 0;
while (not_empty maslattr)
  ::transformAttributeDeclaration(attr:maslattr, obj:obj, index:index);
	index = index + 1;
	select one maslattr related by maslattr->AttributeDeclaration[R5809.''precedes''];
end while;

// transform operations
select many object_services related by object_declaration->ObjectService[R5808];
for each object_service in object_services
	::transformObjectService(object_service:object_service, obj:obj);
end for;

// transform the state machine
/* TODO
select one sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
if ( not_empty sm )
	::transformStateMachine( sm_sm:sm, obj:obj );
	::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
	::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.IEvent", type:ImportType::IMPL );
	select any evt related by obj->StateMachine[R4750]->Event[R4752];
	if ( not_empty evt )
		::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.Event", type:ImportType::IMPL );
	end if;
end if;
*/

// transform the set object
::transformObjectSet(obj:obj, path:path);

// add to the containing component imports
select one set_file related by obj->ClassSet[R406]->File[R401];
::addFileToImports(file:component_file, file_to_import:file, type:ImportType::IMPL);
::addFileToImports(file:component_file, file_to_import:set_file, type:ImportType::IMPL);
::addStringToImports(file:component_file, s: ::pathToPackage( path:file.path ) + ".impl." + file.name + "Impl", type:ImportType::IMPL);
::addStringToImports(file:component_file, s: ::pathToPackage( path:set_file.path ) + ".impl." + set_file.name + "Impl", type:ImportType::IMPL);
::addStringToImports(file:component_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL);

// create the import block
::addFileToImports(file:file, file_to_import:component_file, type:ImportType::BOTH);

::addFileToImports(file:file, file_to_import:file, type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.application.IRunContext", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.InstanceIdentifier", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.IInstanceIdentifier", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.IModelInstance", type:ImportType::INT);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.ModelInstance", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.InstancePopulationException", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.IWhere", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.IXtumlType", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.UniqueId", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.instanceloading.InstanceCreatedDelta", type:ImportType::IMPL);',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	4);
INSERT INTO S_SPARM
	VALUES ("de3adfbb-18df-4417-8e71-9157b189c106",
	"a167f7d5-3c79-4ff5-8b40-a091b9b1a31e",
	'object_declaration',
	"ccbbc697-c60c-4034-8e31-7a46032151eb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ccbbc697-c60c-4034-8e31-7a46032151eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ObjectDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("192d3817-53e8-46de-a490-3b0072f3eafc",
	"a167f7d5-3c79-4ff5-8b40-a091b9b1a31e",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"de3adfbb-18df-4417-8e71-9157b189c106",
	'');
INSERT INTO PE_PE
	VALUES ("a167f7d5-3c79-4ff5-8b40-a091b9b1a31e",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c532c34c-bb46-42d3-8f7e-6798cb8d1e58",
	"00000000-0000-0000-0000-000000000000",
	'transformObjectSet',
	'',
	'obj = param.obj;

// create the object file
create object instance file of File;
file.name = obj.name + "Set";
file.path = param.path;
file.package = ::pathToPackage(path:file.path);
file.extension = ".java";
file.exclude = false;

// create the class set object
create object instance objset of ClassSet;
relate objset to obj across R406;
relate objset to file across R401;
objset.extends = "InstanceSet<" + objset.name + "," + obj.name + ">";
objset.comparator = "";

// set the comparator
/* TODO
select any comparator_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "SortComparator" );
if ( not_empty comparator_mark )
  select many attr_accessors related by objset->Class[R406]->Attribute[R410]->AttributeAccessor[R4510] where ( selected.accessor_type == AttributeAccessorType::GETTER );
  for each attr_accessor in attr_accessors
    if ( attr_accessor.getName() == comparator_mark.value )
      objset.comparator = comparator_mark.value;
      break;
    end if;
  end for;
end if;
*/

// create the instance type
create object instance type of Type;
type.name = objset.name;
type.package = objset.package;
type.default_value = "new " + objset.name + "Impl()";
relate type to objset across R407;

// create the import block
select one objfile related by obj->File[R401];
::addFileToImports(file:file, file_to_import:file, type: ImportType::IMPL);
::addFileToImports(file:file, file_to_import:objfile, type: ImportType::IMPL);
::addStringToImports(file:file, s:"java.util.Arrays", type:ImportType::IMPL);
::addStringToImports(file:file, s:"java.util.Comparator", type:ImportType::IMPL);
::addStringToImports(file:file, s:"java.util.List", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.InstanceSet", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.IInstanceSet", type:ImportType::INT);

select any attr related by objset->Class[R406]->Attribute[R410];
if (not_empty attr)
  ::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH);
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("7bb7660f-dc28-4ddd-a4e0-1789f3e863cd",
	"c532c34c-bb46-42d3-8f7e-6798cb8d1e58",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a519e323-b117-4a03-9435-b88e56c2443d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Inst>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/classes/classes.xtuml');
INSERT INTO S_SPARM
	VALUES ("a6420656-4132-4d4a-9adb-cd2e9f55405b",
	"c532c34c-bb46-42d3-8f7e-6798cb8d1e58",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"7bb7660f-dc28-4ddd-a4e0-1789f3e863cd",
	'');
INSERT INTO PE_PE
	VALUES ("c532c34c-bb46-42d3-8f7e-6798cb8d1e58",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("93597cc3-f7ca-44bf-86ff-6d3f3d9b6818",
	"00000000-0000-0000-0000-000000000000",
	'transformDomainTerminator',
	'',
	'domain_terminator = param.domain_terminator;
comp_def = param.comp_def;

// create the port file
create object instance port_file of File;
port_file.name = comp_def.name + ::camelCaseName(name:domain_terminator.name, start_lower:false);
port_file.path = param.path;
port_file.package = ::pathToPackage(path:port_file.path);
port_file.extension = ".java";
port_file.exclude = false;

// create the interface package object
create object instance port of Port;
relate port to port_file across R401;
port.port_name = ::camelCaseName(name:domain_terminator.name, start_lower:false);

// set base class
select any base_class_mark from instances of Mark where false;
/* TODO
select any base_class_mark from instances of Mark where ( selected.markable_name == "Port" and
                                                          selected.path == ::containerMarkingPath( pe:pe ) + "::" + c_c.Name + "::" + c_po.Name and
                                                          selected.feature_name == "BaseClass" );
*/

if (not_empty base_class_mark)
  port.base_class = base_class_mark.value;
  ::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.interfaces." + base_class_mark.value, type:ImportType::IMPL);
else
  port.base_class = "Port";
  ::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.interfaces.Port", type:ImportType::IMPL);
end if;

// add extra for http port
/* TODO
if ("HttpPort" == port.base_class)
  select one c_c related by c_po->C_C[R4010];
  select one pe related by c_c->PE_PE[R8001];
  select any http_endpoint_mark from instances of Mark where ( selected.markable_name == "Port" and
                                                               selected.path == ::containerMarkingPath( pe:pe ) + "::" + c_c.Name + "::" + c_po.Name and
                                                               selected.feature_name == "HttpEndpoint" );
  port.endpoint = http_endpoint_mark.value;
end if;
*/

// set port as requirer
port.provider = false;

// relate to other component
relate port to comp_def across R417;

// create the interface file
create object instance iface_file of File;
iface_file.name = "I" + ::camelCaseName(name:domain_terminator.name, start_lower:false);
iface_file.path = param.path;
iface_file.package = ::pathToPackage( path:iface_file.path );
iface_file.extension = ".java";
iface_file.exclude = false;

// create the interface package object
create object instance iface of Interface;
relate iface to iface_file across R401;
relate port to iface across R418;

// transform terminator services
select many terminator_services related by domain_terminator->DomainTerminatorService[R5306];
index = 1;
for each terminator_service in terminator_services
	::transformDomainTerminatorService(terminator_service:terminator_service, iface:iface, port:port, index:index);
	index = index + 1;
end for;

// add to component file
select one component_file related by comp_def->File[R401];
::addFileToImports(file:component_file, file_to_import:port_file, type:ImportType::IMPL);

// add imports
::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL);
::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL);
::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.interfaces.IMessage", type:ImportType::IMPL);
::addStringToImports(file:port_file, s:"io.ciera.runtime.summit.interfaces.IPort", type:ImportType::IMPL);
::addFileToImports(file:port_file, file_to_import:component_file, type:ImportType::IMPL);
::addFileToImports(file:port_file, file_to_import:iface_file, type:ImportType::IMPL);',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	5);
INSERT INTO S_SPARM
	VALUES ("eb52c79f-0717-4418-894d-a0b1e2376de0",
	"93597cc3-f7ca-44bf-86ff-6d3f3d9b6818",
	'domain_terminator',
	"d32c0dae-6ff9-4154-9607-21e8f5db2bb8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d32c0dae-6ff9-4154-9607-21e8f5db2bb8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<DomainTerminator>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("75ae6a28-2f7c-47fb-8c94-54e2ed02bc7f",
	"93597cc3-f7ca-44bf-86ff-6d3f3d9b6818",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"eb52c79f-0717-4418-894d-a0b1e2376de0",
	'');
INSERT INTO S_SPARM
	VALUES ("d94d9f11-d275-46ee-bd4b-007a40971ec3",
	"93597cc3-f7ca-44bf-86ff-6d3f3d9b6818",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"75ae6a28-2f7c-47fb-8c94-54e2ed02bc7f",
	'');
INSERT INTO PE_PE
	VALUES ("93597cc3-f7ca-44bf-86ff-6d3f3d9b6818",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("004b6365-0d67-4a5a-9f29-ec2b21938c21",
	"00000000-0000-0000-0000-000000000000",
	'transformDomainTerminatorService',
	'',
	'terminator_service = param.terminator_service;
select one service related by terminator_service->Service[R5203];
iface = param.iface;
index = param.index;

// create message object
create object instance msg of Message;
msg.name = service.name;
msg.to_provider = true;
msg.id = index;
relate msg to iface across R419;

select one iface_file related by iface->File[R401];
::addStringToImports( file:iface_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:iface_file, s:"io.ciera.runtime.summit.interfaces.Message", type:ImportType::IMPL );

port = param.port;
select one port_file related by port->File[R401];

// create port message
create object instance port_msg of PortMessage;
relate port to msg across R420 using port_msg;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = msg.name;
invocable.parent_name = port.name;
invocable.parent_package = port.package;
relate port_msg to invocable across R427;

// populate the OAL
//invocable.actions = "";  TODO

// link type TODO
type = ::TypeReference_getBuiltinTypeReference(name:"void");
relate type to invocable across R428;

// create parameters
/* TODO
select any c_pp related by c_ep->C_PP[R4006];
prev_c_pp = c_pp;
// select first parameter
while ( not_empty prev_c_pp )
  c_pp = prev_c_pp;
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
end while;
while ( not_empty c_pp )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + c_pp.Name;
  parm.by_ref = ( 1 == c_pp.By_Ref );
  select one parm_dt related by c_pp->S_DT[R4007];
  select many s_dims related by c_pp->S_DIM[R4017];
  parm_type_ref = ::TypeReference_getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type_ref to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
  if ((msg.to_provider and port.provider) or (not msg.to_provider and not port.provider))
    if ( "boolean" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.BooleanUtil", type:ImportType::IMPL );
    elif ( "int" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IntegerUtil", type:ImportType::IMPL );
    elif ( "double" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.RealUtil", type:ImportType::IMPL );
    elif ( "String" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.StringUtil", type:ImportType::IMPL );
    else
      select one parm_type related by parm_type_ref->Type[R3800];
      ::addTypeToImports( file:file, type_to_import:parm_type, type:ImportType::IMPL );
    end if;
  end if;
end while;
*/

// relate the body
/* TODO
if ( not_empty act_act )
  relate act_act to invocable across R432;
else
*/',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	6);
INSERT INTO S_SPARM
	VALUES ("52d90d59-5ad7-4837-b360-2b6196ac6741",
	"004b6365-0d67-4a5a-9f29-ec2b21938c21",
	'terminator_service',
	"1f9d3f63-cc27-4669-8de9-5252b9fcf08b",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("1f9d3f63-cc27-4669-8de9-5252b9fcf08b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<DomainTerminatorService>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/domain/domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("d3e4b9a3-faf0-4293-b987-c0ea8ba0a858",
	"004b6365-0d67-4a5a-9f29-ec2b21938c21",
	'iface',
	"003d869d-0580-4a1f-b1c8-e1657cc0248c",
	0,
	'',
	"52d90d59-5ad7-4837-b360-2b6196ac6741",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("003d869d-0580-4a1f-b1c8-e1657cc0248c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Iface>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("4129176a-2b25-4e95-a495-c11796d7248e",
	"004b6365-0d67-4a5a-9f29-ec2b21938c21",
	'port',
	"d29fe14e-2574-4613-ac57-716ebd8e905c",
	0,
	'',
	"d3e4b9a3-faf0-4293-b987-c0ea8ba0a858",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d29fe14e-2574-4613-ac57-716ebd8e905c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("a0f09456-2189-496f-979d-cb3a27b9dc40",
	"004b6365-0d67-4a5a-9f29-ec2b21938c21",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"4129176a-2b25-4e95-a495-c11796d7248e",
	'');
INSERT INTO PE_PE
	VALUES ("004b6365-0d67-4a5a-9f29-ec2b21938c21",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("14b42ff1-d03f-4557-bb85-e0d523c9f560",
	"00000000-0000-0000-0000-000000000000",
	'transformRelationship',
	'',
	'maslrel = param.rel;
comp_def = param.comp_def;
select one file related by comp_def->File[R401];

// get exclude mark
/* TODO
select one pe related by r_rel->PE_PE[R8001];
select any assoc_exclude_mark from instances of Mark where ( selected.markable_name == "Association" and
                                                             selected.path == ::containerMarkingPath( pe:pe ) + "::R" + STRING::itoa( i:r_rel.Numb ) and
                                                             selected.feature_name == "Exclude" );
*/

select any form_class from instances of Class where false;
form_phrase = "";
form_mult = Mult::ONE;
form_cond = Cond::UNCONDITIONAL;
select any part_class from instances of Class where false;
part_phrase = "";
part_mult = Mult::ONE;
part_cond = Cond::UNCONDITIONAL;

// determine if this is a simple relationship
select one normal related by maslrel->NormalRelationshipDeclaration[R6010];
if (not_empty normal)

	// get the formalizer and participant information
	select one half_rel_1 related by normal->HalfRelationship[R6007];
	select one half_rel_2 related by normal->HalfRelationship[R6008];
	select any ref1 related by half_rel_1->ObjectDeclaration[R6004]->AttributeDeclaration[R5802]
		->ReferentialAttributeDefinition[R5800.''is_referenced_by'']->RelationshipSpecification[R5811]->HalfRelationship[R6013]
		->NormalRelationshipDeclaration[R6007]->RelationshipDeclaration[R6010] where (selected.name == maslrel.name);
	select any ref2 related by half_rel_1->ObjectDeclaration[R6004]->AttributeDeclaration[R5802]
		->ReferentialAttributeDefinition[R5800.''is_referenced_by'']->RelationshipSpecification[R5811]->HalfRelationship[R6013]
		->NormalRelationshipDeclaration[R6008]->RelationshipDeclaration[R6010] where (selected.name == maslrel.name);
	if (not_empty ref1 or not_empty ref2)  // the first half is the participant
		select one form_class related by half_rel_2->ObjectDeclaration[R6004]->Class[R8300];
		form_phrase = half_rel_2.role;
		if (half_rel_2.multiplicity == Multiplicity2::many)
			form_mult = Mult::MANY;
		end if;
		if (half_rel_2.isconditional)
			form_cond = Cond::CONDITIONAL;
		end if;
		select one part_class related by half_rel_1->ObjectDeclaration[R6004]->Class[R8300];
		part_phrase = half_rel_1.role;
		if (half_rel_1.multiplicity == Multiplicity2::many)
			part_mult = Mult::MANY;
		end if;
		if (half_rel_1.isconditional)
			part_cond = Cond::CONDITIONAL;
		end if;
	else
		select one form_class related by half_rel_1->ObjectDeclaration[R6004]->Class[R8300];
		form_phrase = half_rel_1.role;
		if (half_rel_1.multiplicity == Multiplicity2::many)
			form_mult = Mult::MANY;
		end if;
		if (half_rel_1.isconditional)
			form_cond = Cond::CONDITIONAL;
		end if;
		select one part_class related by half_rel_2->ObjectDeclaration[R6004]->Class[R8300];
		part_phrase = half_rel_2.role;
		if (half_rel_2.multiplicity == Multiplicity2::many)
			part_mult = Mult::MANY;
		end if;
		if (half_rel_2.isconditional)
			part_cond = Cond::CONDITIONAL;
		end if;
	end if;

	// create the relationship
	create object instance rel of Relationship;
	name = maslrel.name + "_" + form_class.name + "_";
	if (part_phrase != "")
		name = name + T::sub(format:"_", s:part_phrase) + "_";
	end if;
	name = name + part_class.name;
	rel.name = name;
	rel.num = STRING::atoi(s:STRING::substr(s:maslrel.name, begin:1, end:-1));
	rel.form_phrase = form_phrase;
	rel.part_phrase = part_phrase;
	rel.form_mult = form_mult;
	rel.part_mult = part_mult;
	rel.form_cond = form_cond;
	rel.part_cond = part_cond;
	rel.rel_type = RelationshipType::Binary;
	relate rel to comp_def across R448;
	relate rel to form_class across R435;
	relate rel to part_class across R434;

	/* TODO get the ID number
	select any o_id related by r_simp->R_PART[R207]->R_RTO[R204]->O_ID[R109];
	if ( not_empty o_id )
		rel.id_num = o_id.Oid_ID + 1;
	else
		rel.id_num = 0;
	end if;
	*/

else
select one subsup related by maslrel->SubtypeRelationshipDeclaration[R6010];
if ( not_empty subsup )

	select one part_class related by subsup->ObjectDeclaration[R6017]->Class[R8300];
	select many sub_classes related by subsup->ObjectDeclaration[R6016]->Class[R8300];
	part_phrase = "is_a";
	for each form_class in sub_classes

		form_phrase = "is_a";
		form_cond = Cond::CONDITIONAL;

		// create the relationship
		create object instance rel of Relationship;
		name = maslrel.name + "_" + form_class.name + "_is_a_" + part_class.name;
		rel.name = name;
		rel.num = STRING::atoi(s:STRING::substr(s:maslrel.name, begin:1, end:-1));
		rel.form_phrase = form_phrase;
		rel.part_phrase = part_phrase;
		rel.form_mult = form_mult;
		rel.part_mult = part_mult;
		rel.form_cond = form_cond;
		rel.part_cond = part_cond;
		rel.rel_type = RelationshipType::SuperSubtype;
		relate rel to comp_def across R448;
		relate rel to form_class across R435;
		relate rel to part_class across R434;
		
		/* TODO get the ID number
		select one o_id related by r_subsup->R_SUPER[R212]->R_RTO[R204]->O_ID[R109];
		if ( not_empty o_id )
			rel.id_num = o_id.Oid_ID + 1;
		else
			rel.id_num = 0;
		end if;
		*/
	end for;

else
select one assoc related by maslrel->AssociativeRelationshipDeclaration[R6010];
if (not_empty assoc)
  
	select one half_rel_1 related by assoc->HalfRelationship[R6000];
	select one half_rel_2 related by assoc->HalfRelationship[R6002];
	
	// get the formalizer and participant information for the first relationship
	select one form_class related by assoc->ObjectDeclaration[R6001]->Class[R8300];
	form_phrase = half_rel_2.role;
	if (half_rel_2.multiplicity == Multiplicity2::many)
		form_mult = Mult::MANY;
	end if;
	if (half_rel_2.isconditional)
		form_cond = Cond::CONDITIONAL;
	end if;
	select one part_class related by half_rel_1->ObjectDeclaration[R6004]->Class[R8300];
	part_phrase = half_rel_1.role;
	if (half_rel_1.multiplicity == Multiplicity2::many)
		part_mult = Mult::MANY;
	end if;
	if (half_rel_1.isconditional)
		part_cond = Cond::CONDITIONAL;
	end if;

	// create the first relationship
	create object instance rel1 of Relationship;
	name1 = maslrel.name + "_" + form_class.name + "_";
	if (part_phrase != "")
		name1 = name1 + T::sub(format:"_", s:part_phrase) + "_";
	end if;
	name1 = name1 + part_class.name;
	rel1.name = name1;
	rel1.num = STRING::atoi(s:STRING::substr(s:maslrel.name, begin:1, end:-1));
	rel1.form_phrase = form_phrase;
	rel1.part_phrase = part_phrase;
	rel1.form_mult = form_mult;
	rel1.part_mult = part_mult;
	rel1.form_cond = form_cond;
	rel1.part_cond = part_cond;
	rel1.rel_type = RelationshipType::Associative;
	relate rel1 to comp_def across R448;
	relate rel1 to form_class across R435;
	relate rel1 to part_class across R434;

	/* TODO get the ID number
	select one o_id1 related by r_assoc->R_AONE[R209]->R_RTO[R204]->O_ID[R109];
	if ( not_empty o_id1 )
		rel1.id_num = o_id1.Oid_ID + 1;
	else
		rel1.id_num = 0;
	end if;
	*/

	// get the formalizer and participant information for the second relationship
	form_phrase = "";
	form_mult = Mult::ONE;
	form_cond = Cond::UNCONDITIONAL;
	part_phrase = "";
	part_cond = Cond::UNCONDITIONAL;

	select one form_class related by assoc->ObjectDeclaration[R6001]->Class[R8300];
	form_phrase = half_rel_1.role;
	if (half_rel_1.multiplicity == Multiplicity2::many)
		form_mult = Mult::MANY;
	end if;
	if (half_rel_1.isconditional)
		form_cond = Cond::CONDITIONAL;
	end if;
	select one part_class related by half_rel_2->ObjectDeclaration[R6004]->Class[R8300];
	part_phrase = half_rel_2.role;
	if (half_rel_2.multiplicity == Multiplicity2::many)
		part_mult = Mult::MANY;
	end if;
	if (half_rel_2.isconditional)
		part_cond = Cond::CONDITIONAL;
	end if;

	// create the second relationship
	create object instance rel2 of Relationship;
	name2 = maslrel.name + "_" + form_class.name + "_";
	if (part_phrase != "")
		name2 = name2 + T::sub(format:"_", s:part_phrase) + "_";
	end if;
	name2 = name2 + part_class.name;
	rel2.name = name2;
	rel2.num = STRING::atoi(s:STRING::substr(s:maslrel.name, begin:1, end:-1));
	rel2.form_phrase = form_phrase;
	rel2.part_phrase = part_phrase;
	rel2.form_mult = form_mult;
	rel2.part_mult = part_mult;
	rel2.form_cond = form_cond;
	rel2.part_cond = part_cond;
	rel2.rel_type = RelationshipType::Associative;
	relate rel2 to comp_def across R448;
	relate rel2 to form_class across R435;
	relate rel2 to part_class across R434;

  /* TODO
	select one o_id2 related by r_assoc->R_AOTH[R210]->R_RTO[R204]->O_ID[R109];
	if ( not_empty o_id2 )
		rel2.id_num = o_id2.Oid_ID + 1;
	else
		rel2.id_num = 0;
	end if;
	*/
	
	relate rel1 to rel2 across R436.''is one half of associative'';  // note these are a symmetric pair.
end if; end if; end if;

// add necessary imports
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.RelationshipSet", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.Relationship", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.classes.IRelationshipSet", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.ModelIntegrityException", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL);',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	7);
INSERT INTO S_SPARM
	VALUES ("873ac9c0-9196-4cdd-a01f-24cd999bc3f9",
	"14b42ff1-d03f-4557-bb85-e0d523c9f560",
	'rel',
	"fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc9b3839-3ca6-48c8-b09a-c036f8335a12",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<RelationshipDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("696819c1-b1a7-4a5a-a0f7-dbb08f6621d3",
	"14b42ff1-d03f-4557-bb85-e0d523c9f560",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"873ac9c0-9196-4cdd-a01f-24cd999bc3f9",
	'');
INSERT INTO PE_PE
	VALUES ("14b42ff1-d03f-4557-bb85-e0d523c9f560",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d13703e8-082b-41d8-9e21-0e3d97d6da31",
	"00000000-0000-0000-0000-000000000000",
	'transformAttributeDeclaration',
	'',
	'maslattr = param.attr;
obj = param.obj;

// create the attribute
create object instance attr of Attribute;
select many referentials related by maslattr->ReferentialAttributeDefinition[R5800.''refers_to''];
if (not_empty referentials)
  attr.name = "ref_" + maslattr.name;
else
  attr.name = "m_" + maslattr.name;
end if;
attr.base_name = maslattr.name;
attr.order = param.index;
attr.default_value = "";
relate attr to obj across R410;

// set part of identifier
attr.identifier = 0;
if maslattr.isPreferredIdentifier
  attr.identifier = 1;
end if;

// relate to masl class
relate attr to maslattr across R8301;

// set the type
/* TODO
select one s_dt related by o_attr->S_DT[R114];
if ( "same_as<Base_Attribute>" == s_dt.Name )
  select one s_dt related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
end if;
if ( empty s_dt )
  // TODO bad
end if;
select many s_dims related by o_attr->S_DIM[R120];
type = ::TypeReference_getInstance(s_dt:s_dt, s_dims:s_dims);
*/
type = ::TypeReference_getBuiltinTypeReference(name:"boolean");  // temp
select one array_type related by type->ArrayTypeReference[R3801];
relate type to attr across R424;

// set default value for unique id attributes
/* TODO handle unique IDs
if ( "UniqueId" == type.type_name )
  attr.default_value = "UniqueId.random()";
end if;
*/

// create accessors
create object instance getter of AttributeAccessor;
getter.accessor_type = AttributeAccessorType::GETTER;
relate getter to attr across R4510;
create object instance setter of AttributeAccessor;
setter.accessor_type = AttributeAccessorType::SETTER;
relate setter to attr across R4510;

// add import to object file
select one file related by obj->File[R401];
::addStringToImports(file:file, s:"io.ciera.runtime.instanceloading.AttributeChangedDelta", type:ImportType::IMPL);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH);
::addStringToImports(file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL);
/* TODO
if (not_empty array_type)
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.ArrayUtil", type:ImportType::IMPL );
elif ("String" == type.type_name and "" == type.type_package)
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.StringUtil", type:ImportType::IMPL );
end if;
*/',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	8);
INSERT INTO S_SPARM
	VALUES ("0634ff00-eab7-45e6-b893-1874b2a5c7e8",
	"d13703e8-082b-41d8-9e21-0e3d97d6da31",
	'attr',
	"bc9fb0af-6887-4a01-9bad-2412058db57c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bc9fb0af-6887-4a01-9bad-2412058db57c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<AttributeDeclaration>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("85724f64-796f-4d88-a420-3ce289a4b058",
	"d13703e8-082b-41d8-9e21-0e3d97d6da31",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"0634ff00-eab7-45e6-b893-1874b2a5c7e8",
	'');
INSERT INTO S_SPARM
	VALUES ("fc943558-6916-44c3-8857-8d46e5beb953",
	"d13703e8-082b-41d8-9e21-0e3d97d6da31",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"85724f64-796f-4d88-a420-3ce289a4b058",
	'');
INSERT INTO PE_PE
	VALUES ("d13703e8-082b-41d8-9e21-0e3d97d6da31",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ea574998-30fc-4373-a1c8-d4b289d85244",
	"00000000-0000-0000-0000-000000000000",
	'transformObjectService',
	'',
	'object_service = param.object_service;
select one service related by object_service->Service[R5203];
obj = param.obj;

// create operation object
create object instance op of Operation;
op.is_class_based = not object_service.isInstance;
relate op to obj across R416;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = service.name;
invocable.parent_name = op.class_name;
invocable.parent_package = op.class_package;
relate op to invocable across R427;
//invocable.actions = o_tfr.Action_Semantics_internal; TODO

// link type TODO
type = ::TypeReference_getBuiltinTypeReference(name:"void");
relate type to invocable across R428;

// create parameters
/* TODO
select any o_tparm related by o_tfr->O_TPARM[R117];
prev_o_tparm = o_tparm;
// select first parameter
while (not_empty prev_o_tparm)
  o_tparm = prev_o_tparm;
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
end while;
while (not_empty o_tparm)
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + o_tparm.Name;
  parm.by_ref = (1 == o_tparm.By_Ref);
  select one parm_dt related by o_tparm->S_DT[R118];
  select many s_dims related by o_tparm->S_DIM[R121];
  parm_type = ::TypeReference_getInstance(s_dt:parm_dt, s_dims:s_dims);
  relate parm_type to parm across R431;
  ::linkParameter(invocable:invocable, parameter:parm);
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
end while;
*/

// relate the body
/* TODO
select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
if (not_empty act_act)
  relate act_act to invocable across R432;
end if;
*/

// add imports
select one class_file related by obj->File[R401];
::addStringToImports(file:class_file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL);
if (op.is_class_based)
  ::addStringToImports(file:class_file, s:"io.ciera.runtime.summit.application.ActionHome", type:ImportType::IMPL);
end if;
::addStringToImports(file:class_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH);

// if this is an optional deferred operation, create a second operation for the supertype implementation
// TODO',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("ca074451-023a-420f-b508-78f978e97d7b",
	"ea574998-30fc-4373-a1c8-d4b289d85244",
	'object_service',
	"4ad9b822-f9c4-40b0-bfd6-44ed4fbaaf33",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4ad9b822-f9c4-40b0-bfd6-44ed4fbaaf33",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ObjectService>',
	'',
	'',
	'../../../../ooamasl/models/ooamasl/ooamasl/object/object.xtuml');
INSERT INTO S_SPARM
	VALUES ("a4f23ffc-c780-4de8-ac12-e8e66ba04067",
	"ea574998-30fc-4373-a1c8-d4b289d85244",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"ca074451-023a-420f-b508-78f978e97d7b",
	'');
INSERT INTO PE_PE
	VALUES ("ea574998-30fc-4373-a1c8-d4b289d85244",
	1,
	"e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("e57bc9b3-2b76-471e-8c8a-d7282e2c4fc0",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("ff182108-eff3-4cdc-81dd-efdc6098874b",
	'tool-core-masl',
	1,
	'../tool-core-masl.xtuml');
