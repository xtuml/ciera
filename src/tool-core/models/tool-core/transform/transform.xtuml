-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'transform',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("54ceecfe-b8b4-4268-a224-ad7862274528",
	112,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'',
	'tool-core::transform');
INSERT INTO GD_GE
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef",
	"54ceecfe-b8b4-4268-a224-ad7862274528",
	"f9a85e65-cedd-4444-aef5-bae5288e31bc",
	108,
	0,
	'tool-core::transform::expression');
INSERT INTO GD_SHP
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO GD_NCS
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO DIM_GE
	VALUES (0.000000,
	0.000000,
	"8da75311-8c4e-4898-bb26-fd492421a8ef",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40",
	"54ceecfe-b8b4-4268-a224-ad7862274528",
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	108,
	0,
	'tool-core::transform::statement');
INSERT INTO GD_SHP
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO GD_NCS
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO DIM_GE
	VALUES (220.000000,
	0.000000,
	"3de88190-5be5-4acb-9b45-023f70eaeb40",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_DIA
	VALUES ("54ceecfe-b8b4-4268-a224-ad7862274528",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("0307331a-f934-464c-a586-c201ec3f4b4d",
	"00000000-0000-0000-0000-000000000000",
	'resolveAssociativeSelections',
	'',
	'// This function selects all ACT_LNK instances which select directly from one to
// other or other to one on an associative relationship and turns it into two 
// links.

select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  
  select one r_rel related by act_lnk->R_REL[R681];
  select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
  select one r_assr related by r_rel->R_ASSOC[R206]->R_ASSR[R211];
  select one assr_obj related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
  
  select one target_obj related by act_lnk->O_OBJ[R678];
  select any prev_lnk from instances of ACT_LNK where false;
  select any v_int from instances of V_INT where false;
  select any v_ins from instances of V_INS where false;
  select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds'']; // previous link
  select one base_obj related by prev_lnk->O_OBJ[R678];
  if ( empty base_obj )
    select one v_int related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_IRF[R801]->V_VAR[R808]->V_INT[R814]; // instance reference
    select one base_obj related by v_int->O_OBJ[R818];
    if ( empty base_obj )
      select one v_ins related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_ISR[R801]->V_VAR[R809]->V_INS[R814]; // instance reference set
      select one base_obj related by v_ins->O_OBJ[R819];
    end if;
  end if;
  
  // if this is an associative selection in which the link class is _not_ involved, it must be split up
  if ( not_empty r_assr and target_obj.Obj_ID != r_assr.Obj_ID and base_obj.Obj_ID != r_assr.Obj_ID )
  
    // create the first intermediate link
    create object instance act_lnk1 of ACT_LNK;
    act_lnk1.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk1.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk1.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk1.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk1.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk1.phraseColumn = act_lnk.phraseColumn;
    act_lnk1.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    relate r_rel to act_lnk1 across R681;
    relate act_lnk1 to assr_obj across R678;
    if ( 1 == r_assr.Mult or ( not_empty prev_lnk and Multiplicity::Many == prev_lnk.Mult ) or not_empty v_ins )
      act_lnk1.Mult = Multiplicity::Many; // always many if the associative object has multiplicity many, or the starting point is multiplicity many
    else
      if ( target_obj.Obj_ID != base_obj.Obj_ID and r_aoth.Obj_ID == target_obj.Obj_ID ) or 
         ( target_obj.Obj_ID == base_obj.Obj_ID and r_aoth.Txt_Phrs == C_UTIL::stripTics( s:act_lnk.Rel_Phrase ) )  // one to other
        if ( 1 == r_aoth.Mult )
          act_lnk1.Mult = Multiplicity::Many;
        else
          act_lnk1.Mult = Multiplicity::One;
        end if;
      end if;
    end if;

    // create the second intermediate link
    create object instance act_lnk2 of ACT_LNK;
    act_lnk2.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk2.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk2.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk2.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk2.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk2.phraseColumn = act_lnk.phraseColumn;
    act_lnk2.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    act_lnk2.Mult = act_lnk.Mult; // the second link always gets the same multiplicity as the original link
    relate r_rel to act_lnk2 across R681;
    relate act_lnk2 to target_obj across R678;
    
    // link the two together and insert into the order
    relate act_lnk1 to act_lnk2 across R604.''precedes'';
    select one next_lnk related by act_lnk->ACT_LNK[R604.''precedes''];
    if ( not_empty next_lnk )
      unrelate act_lnk from next_lnk across R604.''precedes'';
      relate act_lnk2 to next_lnk across R604.''precedes'';
    end if;
    if ( not_empty prev_lnk )
      unrelate act_lnk from prev_lnk across R604.''succeeds'';
      relate act_lnk1 to prev_lnk across R604.''succeeds'';
    else // this is the starting point
      select one act_sel related by act_lnk->ACT_SEL[R637];
      unrelate act_lnk from act_sel across R637;
      relate act_lnk1 to act_sel across R637;
    end if;
    
    // dispose old link
    unrelate target_obj from act_lnk across R678;
    unrelate r_rel from act_lnk across R681;
    delete object instance act_lnk;
    
  end if;
  
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO PE_PE
	VALUES ("0307331a-f934-464c-a586-c201ec3f4b4d",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	"00000000-0000-0000-0000-000000000000",
	'transformApplication',
	'',
	'root_package = param.root_package;
select one s_sys related by root_package->S_SYS[R1405];

// get application marks
select any app_name_mark from instances of Mark where (selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationName");
select any app_pkg_mark from instances of Mark where (selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationPackage");

// create the file
create object instance file of File;
if (not_empty app_name_mark)
  file.name = app_name_mark.value;
else
  file.name = ::camelCaseName(name:s_sys.Name, start_lower:false) + "Application";
end if;
if (not_empty app_pkg_mark)
  file.package = app_pkg_mark.value;
  file.path = ::formatPath(path:file.package);
else
  file.path = T::sub(format:"l", s:T::sub(format:"r", s:s_sys.Name));
  file.package = ::pathToPackage(path:file.path);
end if;
file.extension = ".java";
file.exclude = false;

// create the application object
create object instance app of Application;
relate app to file across R401;

// add this application as an export of the module
select one mod related by root_package->S_SYS[R1405]->Module[R4760];
if not_empty mod
  relate app to mod across R5751;
else
  // TODO bad
end if;

// check simulated time
sim_time_mark = PROP::getProperty(key:"io.ciera.EnableSimulatedTime");
if (sim_time_mark != "")
  LOG::LogInfo(message:"Enabling simulated time");
  app.simulated_time = sim_time_mark;
end if;

// translate components references
select many c_cs related by root_package->PE_PE[R8000]->C_C[R8001];
select many cl_ics related by root_package->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
c_cs = c_cs | cl_ics;
select any current_comp_inst from instances of ComponentInstantiation where false;
for each c_c in c_cs
  select one comp_def related by c_c->ComponentDefinition[R4573];
  if empty comp_def
    ::transformComponentReference(c_c:c_c);
    select one comp_def related by c_c->ComponentDefinition[R4573];
  end if;
  if not_empty comp_def
    create object instance comp_inst of ComponentInstantiation;
    relate  comp_def to app across R426 using comp_inst;
    if (not_empty current_comp_inst)
      relate comp_inst to current_comp_inst across R4029.''follows'';
      comp_inst.index = current_comp_inst.index + 1;
    else
      comp_inst.index = 0;
    end if;
    current_comp_inst = comp_inst;
  else
    LOG::LogFailure(message:"Could not find translated component definition for: " + c_c.Name);
  end if;
end for;

// transform satisfactions
select many c_sfs related by root_package->PE_PE[R8000]->C_SF[R8001];
for each c_sf in c_sfs
  ::transformSatisfaction(c_sf:c_sf);
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("0740d1ad-fda7-4447-9a0f-169201702f1b",
	"db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	'root_package',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO S_SPARM
	VALUES ("5fd77cf9-a065-41bd-bc15-10904bbc96dc",
	"db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0740d1ad-fda7-4447-9a0f-169201702f1b",
	'');
INSERT INTO PE_PE
	VALUES ("db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	"00000000-0000-0000-0000-000000000000",
	'transformAssociation',
	'',
	'r_rel = param.r_rel;
containing_comp_def = param.containing_comp_def;
select one file related by containing_comp_def->File[R401];

// get exclude mark
select one pe related by r_rel->PE_PE[R8001];
select any assoc_exclude_mark from instances of Mark where ( selected.markable_name == "Association" and
                                                             selected.path == ::containerMarkingPath( pe:pe ) + "::R" + STRING::itoa( i:r_rel.Numb ) and
                                                             selected.feature_name == "Exclude" );
if ( empty assoc_exclude_mark )
  form_phrase = "";
  select any form_class from instances of Class where false;
  form_mult = Mult::ONE;
  part_mult = Mult::ONE;
  form_cond = Cond::UNCONDITIONAL;
  part_phrase = "";
  select any part_class from instances of Class where false;
  part_cond = Cond::UNCONDITIONAL;

  // determine if this is a simple relationship
  select one r_simp related by r_rel->R_SIMP[R206];
  if ( not_empty r_simp )

    select one r_form related by r_simp->R_FORM[R208];
    select one form_class related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class )
      select any r_part related by r_simp->R_PART[R207];
      select one part_class related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
      if ( not_empty part_class )
        form_phrase = r_form.Txt_Phrs;
        part_phrase = r_part.Txt_Phrs;
        if ( 0 != r_form.Mult )
          form_mult = Mult::MANY;
        end if;
        if ( 0 != r_part.Mult )
          part_mult = Mult::MANY;
        end if;
        if ( 0 != r_form.Cond )
          form_cond = Cond::CONDITIONAL;
        end if;
        if ( 0 != r_part.Cond )
          part_cond = Cond::CONDITIONAL;
        end if;
      else
        // TODO bad
      end if;
    else
      // Unformalized: no R_FORM supplied - use some rationale to select one of the two R_PARTS as ''''form''''.
      // If one - and only one - side is of multiplicity 1, then choose the other side as ''''form''''.
      // Otherwise use participating class name order to make a deterministic choice of ''''form'''' side.
      decided = false;
      select any r_part1 related by r_simp->R_PART[R207];
      select any r_part2 related by r_simp->R_PART[R207] 
       where ( selected.OIR_ID != r_part1.OIR_ID );
      // assume that r_part2 is a good choice for the ''''form'''' participant
      if ( r_part1.Mult != 0 )
      	if ( r_part2.Mult == 0 )	// bad gamble - but reverse will work, so swap sides
	      	a_part = r_part1;
	      	r_part1 = r_part2;
	      	r_part2 = a_part;
	      	decided = true;  // we have correctly identified a 1:M
      	end if;
      end if;
      select one part_class related by r_part1->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
      select one form_class related by r_part2->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
      if ( not_empty form_class and not_empty part_class )
      	if ( not decided )
        	if ( part_class.name > form_class.name )
		      	a_part = r_part1;
		      	r_part1 = r_part2;
		      	r_part2 = a_part;
		      	a_class = part_class;
		      	part_class = form_class;
		      	form_class = a_class;
        	end if;
        end if;
        LOG::LogInfo( message:"AM:: xformAssoc - form: " + form_class.name + " part: " + part_class.name );
      	form_phrase = r_part2.Txt_Phrs;
        part_phrase = r_part1.Txt_Phrs;
        if ( 0 != r_part2.Mult )
          form_mult = Mult::MANY;
        end if;
        if ( 0 != r_part1.Mult )
          part_mult = Mult::MANY;
        end if;
        if ( 0 != r_part2.Cond )
          form_cond = Cond::CONDITIONAL;
        end if;
        if ( 0 != r_part1.Cond )
          part_cond = Cond::CONDITIONAL;
        end if;
      else
        // TODO bad 
      end if;
    end if;

    // create the relationship
    create object instance rel of Relationship;
    name = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name = name + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name = name + part_class.name;
    rel.name = name;
    rel.num = r_rel.Numb;
    rel.form_phrase = form_phrase;
    rel.part_phrase = part_phrase;
    rel.form_mult = form_mult;
    rel.part_mult = part_mult;
    rel.form_cond = form_cond;
    rel.part_cond = part_cond;
    rel.rel_type = RelationshipType::Binary;
    relate rel to containing_comp_def across R448;
    relate rel to form_class across R435;
    relate rel to part_class across R434;

    select any o_id related by r_simp->R_PART[R207]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id )
      rel.id_num = o_id.Oid_ID + 1;
    else
      rel.id_num = 0;
    end if;

  else
  select one r_subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty r_subsup )

    select one part_class related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    select many sub_classes related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty part_class and not_empty sub_classes )
      part_phrase = "is_a";
      for each form_class in sub_classes

        form_phrase = "is_a";
        form_cond = Cond::CONDITIONAL;

        // create the relationship
        create object instance rel of Relationship;
        name = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
        if ( "" != part_phrase )
          name = name + part_phrase + "_";
        end if;
        name = name + part_class.name;
        rel.name = name;
        rel.num = r_rel.Numb;
        rel.form_phrase = form_phrase;
        rel.part_phrase = part_phrase;
        rel.form_mult = form_mult;
        rel.part_mult = part_mult;
        rel.form_cond = form_cond;
        rel.part_cond = part_cond;
        rel.rel_type = RelationshipType::SuperSubtype;
        relate rel to containing_comp_def across R448;
        relate rel to form_class across R435;
        relate rel to part_class across R434;
        
        select one o_id related by r_subsup->R_SUPER[R212]->R_RTO[R204]->O_ID[R109];
        if ( not_empty o_id )
          rel.id_num = o_id.Oid_ID + 1;
        else
          rel.id_num = 0;
        end if;

        // special case for EP_PKG instances... top level packages do not have a PE_PE instance
        if ( 8001 == rel.num and "EP_PKG" == rel.form_name )
          LOG::LogInfo( message:"  Special casing R8001 EP_PKG to PackageableElement" );
          rel.part_cond = Cond::CONDITIONAL;
        end if;

      end for;
    else
      // TODO bad
    end if;

  else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )

    select one r_assr related by r_assoc->R_ASSR[R211];
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];

    select one form_class related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    select one part_class related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class and not_empty part_class and not_empty r_aoth )
      form_phrase = r_aoth.Txt_Phrs;
      part_phrase = r_aone.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aoth.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aoth.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the first relationship
    create object instance rel1 of Relationship;
    name1 = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name1 = name1 + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name1 = name1 + part_class.name;
    rel1.name = name1;
    rel1.num = r_rel.Numb;
    rel1.form_phrase = form_phrase;
    rel1.part_phrase = part_phrase;
    rel1.form_mult = form_mult;
    rel1.part_mult = part_mult;
    rel1.form_cond = form_cond;
    rel1.part_cond = part_cond;
    rel1.rel_type = RelationshipType::Associative;
    relate rel1 to containing_comp_def across R448;
    relate rel1 to form_class across R435;
    relate rel1 to part_class across R434;

    select one o_id1 related by r_assoc->R_AONE[R209]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id1 )
      rel1.id_num = o_id1.Oid_ID + 1;
    else
      rel1.id_num = 0;
    end if;

    form_phrase = "";
    form_mult = Mult::ONE;
    form_cond = Cond::UNCONDITIONAL;
    part_phrase = "";
    part_cond = Cond::UNCONDITIONAL;

    select one part_class related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class and not_empty part_class and not_empty r_aone )
      form_phrase = r_aone.Txt_Phrs;
      part_phrase = r_aoth.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aone.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aone.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the second relationship
    create object instance rel2 of Relationship;
    name2 = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name2 = name2 + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name2 = name2 + part_class.name;
    rel2.name = name2;
    rel2.num = r_rel.Numb;
    rel2.form_phrase = form_phrase;
    rel2.part_phrase = part_phrase;
    rel2.form_mult = form_mult;
    rel2.part_mult = part_mult;
    rel2.form_cond = form_cond;
    rel2.part_cond = part_cond;
    rel2.rel_type = RelationshipType::Associative;
    relate rel2 to containing_comp_def across R448;
    relate rel2 to form_class across R435;
    relate rel2 to part_class across R434;

    select one o_id2 related by r_assoc->R_AOTH[R210]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id2 )
      rel2.id_num = o_id2.Oid_ID + 1;
    else
      rel2.id_num = 0;
    end if;
    
    relate rel1 to rel2 across R436.''is one half of associative'';  // note these are a symmetric pair.
  else
    // TODO bad
  end if; end if; end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("67b6f3bc-1eec-46d8-9fa9-401c41fbaccc",
	"562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("556c2a0f-e7fa-4a1e-9bd2-69b7279362d6",
	"562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"67b6f3bc-1eec-46d8-9fa9-401c41fbaccc",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("109e90cb-1d66-46ee-88db-a568044879d0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/component/component.xtuml');
INSERT INTO PE_PE
	VALUES ("562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bf960a33-3c3c-4839-89d3-7979cebc4f42",
	"00000000-0000-0000-0000-000000000000",
	'transformAttribute',
	'',
	'o_attr = param.o_attr;
obj = param.obj;

// create the attribute
create object instance attr of Attribute;
select one rattr related by o_attr->O_RATTR[R106];
if (not_empty rattr)
  attr.name = "ref_" + o_attr.Name;
else
  attr.name = "m_" + o_attr.Name;
end if;
attr.base_name = o_attr.Name;
attr.order = param.index;
attr.default_value = o_attr.DefaultValue;
relate attr to obj across R410;

// set part of identifier
attr.identifier = 0;
select many inst_ids related by o_attr->O_ID[R105];
for each inst_id in inst_ids
  if (inst_id.Oid_ID == 0)   attr.identifier = attr.identifier + 1;
  elif (inst_id.Oid_ID == 1) attr.identifier = attr.identifier + 2;
  elif (inst_id.Oid_ID == 2) attr.identifier = attr.identifier + 4;
  end if;
end for;

// set the type
select one s_dt related by o_attr->S_DT[R114];
if ("same_as<Base_Attribute>" == s_dt.Name)
  select one s_dt related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
end if;
if (empty s_dt)
  // TODO bad
end if;
select many s_dims related by o_attr->S_DIM[R120];
type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
relate type to attr across R424;

// check transient mark
select one o_obj related by obj->O_OBJ[R409];
select one o_obj_pe related by o_obj->PE_PE[R8001];
select any transient_mark from instances of Mark where (selected.markable_name == "Attribute" and
                                                        selected.path == ::containerMarkingPath(pe:o_obj_pe) + "::" + o_obj.Name  + "::" + o_attr.Name and
                                                        selected.feature_name == "Transient");
attr.transient = not_empty transient_mark or not type.serializable;

// set unique ID attributes to be unique
if (type.type_reference == "UniqueId")
  attr.is_unique = true;
end if;

// link OOA attribute
relate o_attr to attr across R414;

// create accessors
create object instance getter of AttributeAccessor;
getter.accessor_type = AttributeAccessorType::GETTER;
relate getter to attr across R4510;
create object instance setter of AttributeAccessor;
setter.accessor_type = AttributeAccessorType::SETTER;
relate setter to attr across R4510;

// transform derivation
select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
if (not_empty o_dbattr)
  create object instance deriv of AttributeDerivation;
  relate deriv to getter across R441;
  // create invocable
  create object instance invocable of InvocableObject;
  invocable.name = attr.name;
  invocable.parent_name = attr.class_name;
  invocable.parent_package = attr.class_package;
  relate deriv to invocable across R427;
  // link type
  relate type to invocable across R428;
  // relate the body
  select one act_act related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698];
  if (not_empty act_act)
    relate act_act to invocable across R432;
    ::setOriginalNames(invocable:invocable, label:act_act.Label);
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2e5a2176-6827-4c1c-94d2-f9b580870e77",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("60f99308-e7f2-4418-9f3c-a851d15b500e",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"2e5a2176-6827-4c1c-94d2-f9b580870e77",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a519e323-b117-4a03-9435-b88e56c2443d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Inst>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/classes/classes.xtuml');
INSERT INTO S_SPARM
	VALUES ("fc68f878-a11f-4847-b767-3532e44408f6",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"60f99308-e7f2-4418-9f3c-a851d15b500e",
	'');
INSERT INTO PE_PE
	VALUES ("bf960a33-3c3c-4839-89d3-7979cebc4f42",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ea25865c-d822-4d1f-b995-3569c5175acf",
	"00000000-0000-0000-0000-000000000000",
	'transformAttributeReferences',
	'',
	'obj = param.obj;
select many attrs related by obj->Attribute[R410];
for each attr in attrs
  select many o_refs related by attr->O_ATTR[R414]->O_RATTR[R106]->O_REF[R108];
  for each o_ref in o_refs
    select one r_rel related by o_ref->O_RTIDA[R111]->R_RTO[R110]->R_OIR[R203]->R_REL[R201];
    select one referred_to_attr related by o_ref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105]->Attribute[R414];
    select one referred_to_obj related by referred_to_attr->Class[R410];
    referred_to_phrase = ::oirGetPhrase( r_oir_id:o_ref.ROIR_ID );
    phrase = ::oirGetPhrase( r_oir_id:o_ref.OIR_ID );
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == obj.name and
                                                                   selected.part_name == referred_to_obj.name and
                                                                   ( selected.form_phrase == phrase or selected.part_phrase == referred_to_phrase ) );

    // create attribute reference
    create object instance attr_ref of AttributeReference;
    relate attr to referred_to_attr across R4506.''has value provided by'' using attr_ref;
    relate relationship to attr_ref across R4511;
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("399ecf70-c1df-4c59-8264-ed04cfd415ac",
	"ea25865c-d822-4d1f-b995-3569c5175acf",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ea25865c-d822-4d1f-b995-3569c5175acf",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("39485529-37f5-43d9-bbd1-92027e9dd6d6",
	"00000000-0000-0000-0000-000000000000",
	'transformClass',
	'',
	'o_obj = param.o_obj;
containing_comp_def = param.containing_comp_def;
path = param.path;
select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];

// get exclude mark
select one pe related by o_obj->PE_PE[R8001];
select any class_exclude_mark from instances of Mark where (selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath(pe:pe) + "::" + o_obj.Name and
                                                            selected.feature_name == "Exclude");
if (empty class_exclude_mark)
  // get mark for naming
  select any class_name_mark from instances of Mark where (selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath(pe:pe) + "::" + o_obj.Name and
                                                            selected.feature_name == "UseKeyLettersForName");
  // create the object file
  create object instance file of File;
  if (empty class_name_mark)
    file.name = ::camelCaseName(name:o_obj.Name, start_lower:false);
  else
    file.name = o_obj.Key_Lett;
  end if;
  file.path = path;
  file.package = ::pathToPackage(path:file.path);
  file.extension = ".java";
  file.exclude = false;

  // create the object
  create object instance obj of Class;
  relate obj to file across R401;
  obj.comparator = "";

  // add the class to the component
  relate obj to containing_comp_def across R408;

  // relate to the OOA class
  relate obj to o_obj across R409;

  // add to open package
  select one mod related by containing_comp_def->Module[R5752];
  select any open_package related by mod->OpenedPackage[R5754] where selected.name == obj.package;
  if empty open_package
    create object instance open_package of OpenedPackage;
    open_package.name = obj.package;
    relate open_package to mod across R5754;
  end if;

  // transform attributes
  select any o_attr related by o_obj->O_ATTR[R102];
  select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  while (not_empty prev_attr)
    o_attr = prev_attr;
    select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  end while;
  index = 0;
  while (not_empty o_attr)
    if ("current_state" != o_attr.Name)
      ::transformAttribute(o_attr:o_attr, obj:obj, index:index);
      index = index + 1;
    end if;
    select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
  end while;

  // set the comparator
  select any comparator_mark from instances of Mark where (selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "SortComparator");
  if (not_empty comparator_mark)
    select many attr_accessors related by obj->Attribute[R410]->AttributeAccessor[R4510] where (selected.accessor_type == AttributeAccessorType::GETTER);
    for each attr_accessor in attr_accessors
      if (attr_accessor.getName() == comparator_mark.value)
        obj.comparator = comparator_mark.value;
        break;
      end if;
    end for;
  end if;

  // transform operations
  select many o_tfrs related by o_obj->O_TFR[R115];
  for each o_tfr in o_tfrs
    ::transformOperation(o_tfr:o_tfr, obj:obj);
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("78d79a4b-aa7c-4f92-8c2b-c122c556f1af",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("96e1d0a0-83fa-41e1-8dd7-e063f484c257",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"78d79a4b-aa7c-4f92-8c2b-c122c556f1af",
	'');
INSERT INTO S_SPARM
	VALUES ("c865d293-ea6c-4aea-b9f2-d168c5534554",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"96e1d0a0-83fa-41e1-8dd7-e063f484c257",
	'');
INSERT INTO PE_PE
	VALUES ("39485529-37f5-43d9-bbd1-92027e9dd6d6",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	"00000000-0000-0000-0000-000000000000",
	'transformComponentDefinition',
	'',
	'c_c = param.c_c;
path = param.path + "/" + T::sub(format:"l", s:c_c.Name);

select any file from instances of File where
  selected.name == ::camelCaseName(name:c_c.Name, start_lower:false) and selected.package == ::pathToPackage(path:path);
select one comp_def related by file->ComponentDefinition[R401];

if (param.pass == 1)

  // create the file
  create object instance file of File;
  file.name = ::camelCaseName(name:c_c.Name, start_lower:false);
  file.path = path;
  file.package = ::pathToPackage(path:path);
  file.extension = ".java";
  file.exclude = false;

  // create the component definition object
  create object instance comp_def of ComponentDefinition;
  relate comp_def to file across R401;
  relate c_c to comp_def across R4573;
  
  // check the transient mark
  select one c_c_pe related by c_c->PE_PE[R8001];
  select any transient_mark from instances of Mark where (selected.markable_name == "Component" and
                                                         selected.path == ::containerMarkingPath(pe:c_c_pe) + "::" + c_c.Name and
                                                         selected.feature_name == "Transient");
  comp_def.transient = not_empty transient_mark;
  
  // add this component as an export of the module
  select one mod related by c_c->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
  if not_empty mod
    relate comp_def to mod across R5752;
  else
    // TODO bad
  end if;
  
elif (param.pass == 3)

  // transform ports
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    ::transformPort(c_po:c_po, comp_def:comp_def, path:file.path, exclude:false);
  end for;

end if;

// transform inner packages
select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
for each ep_pkg in ep_pkgs
  ::transformPackage(ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path, pass:param.pass);
end for;

// transform inner components
select many inner_c_cs related by c_c->PE_PE[R8003]->C_C[R8001];
for each inner_c_c in inner_c_cs
  ::transformComponentDefinition(c_c:inner_c_c, containing_comp_def:comp_def, path:file.path, pass:param.pass);
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("ebb9b275-e504-4702-b6d7-9e3d0c1b097f",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("e3aed8de-e794-4e78-a0d2-4a887930b499",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"ebb9b275-e504-4702-b6d7-9e3d0c1b097f",
	'');
INSERT INTO S_SPARM
	VALUES ("f5644135-5f9c-4d77-8ad3-1ff0d224ed6b",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e3aed8de-e794-4e78-a0d2-4a887930b499",
	'');
INSERT INTO S_SPARM
	VALUES ("0d391156-81cc-4fd9-8306-5d01a455c493",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"f5644135-5f9c-4d77-8ad3-1ff0d224ed6b",
	'');
INSERT INTO PE_PE
	VALUES ("a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a114d22b-91d1-4024-bd80-b10fccabec0f",
	"00000000-0000-0000-0000-000000000000",
	'transformEnumeratedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = param.exclude;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = "null";
create object instance edt of EnumeratedType;
relate type to edt across R407;
relate type to s_dt across R423;

// create the user defined type
create object instance udt of UserDefinedType;
relate udt to file across R401;
relate type to udt across R3803;

// transform enumerators
select any enumer related by s_dt->S_EDT[R17]->S_ENUM[R27];
select one prev_enumer related by enumer->S_ENUM[R56.''succeeds''];
while ( not_empty prev_enumer )
  enumer = prev_enumer;
  select one prev_enumer related by enumer->S_ENUM[R56.''succeeds''];
end while;
value = 0;
while ( not_empty enumer )
  create object instance e of Enumerator;
  e.name = T::sub( format:"u", s:enumer.Name );
  e.value = value;
  e.comment = enumer.Descrip;
  value = value + 1;
  relate e to edt across R415;
  select one enumer related by enumer->S_ENUM[R56.''precedes''];
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("52ce9b0d-3a5e-4b00-a118-31e4fea357d2",
	"a114d22b-91d1-4024-bd80-b10fccabec0f",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("8fd7666c-7b37-49cb-acac-245fe7a4c18e",
	"a114d22b-91d1-4024-bd80-b10fccabec0f",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"52ce9b0d-3a5e-4b00-a118-31e4fea357d2",
	'');
INSERT INTO PE_PE
	VALUES ("a114d22b-91d1-4024-bd80-b10fccabec0f",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("343165b5-e8e6-4162-90f5-1e68da66120f",
	"00000000-0000-0000-0000-000000000000",
	'transformEvent',
	'',
	'sm_evt = param.sm_evt;
obj = param.obj;

// create event
create object instance evt of Event;
relate evt to obj across R4752;
select many existing_evts from instances of Event;
evt.id = cardinality existing_evts;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = T::sub( format:"c_", s:sm_evt.Mning );
invocable.parent_name = obj.name;
invocable.parent_package = obj.package;
relate evt to invocable across R427;

// link type
type = ::getBasicTypeReferenceByName( name:"void" );
relate type to invocable across R428;

// create parameters
select any sm_evtdi related by sm_evt->SM_EVTDI[R532];
prev_sm_evtdi = sm_evtdi;
// select first parameter
while ( not_empty prev_sm_evtdi )
  sm_evtdi = prev_sm_evtdi;
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
end while;
while ( not_empty sm_evtdi )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + sm_evtdi.Name;
  parm.by_ref = false;
  select one parm_dt related by sm_evtdi->S_DT[R524];
  select many s_dims related by sm_evtdi->S_DIM[R531];
  parm_type = ::getTypeReferenceForS_DTWithDims( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
end while;

// link to ooa event
relate evt to sm_evt across R4759;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("493c7cbb-1d0d-4b72-bd54-0fbecbccce06",
	"343165b5-e8e6-4162-90f5-1e68da66120f",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("33eebb24-8068-410b-a905-37c4e5cc2fdb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("16f2d993-8ce0-4bcc-8a98-d09fbf34d15e",
	"343165b5-e8e6-4162-90f5-1e68da66120f",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"493c7cbb-1d0d-4b72-bd54-0fbecbccce06",
	'');
INSERT INTO PE_PE
	VALUES ("343165b5-e8e6-4162-90f5-1e68da66120f",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3775f12f-f551-4b87-b37b-bcdae037314c",
	"00000000-0000-0000-0000-000000000000",
	'transformFunction',
	'',
	's_sync = param.s_sync;
comp_def = param.comp_def;

// create function object
create object instance func of Function;
relate func to comp_def across R405;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_sync.Name;
invocable.parent_name = comp_def.name;
invocable.parent_package = comp_def.package;
relate func to invocable across R427;

// link type
select one s_dt related by s_sync->S_DT[R25];
select many s_dims related by s_sync->S_DIM[R51];
type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
relate type to invocable across R428;

// create parameters
select any s_sparm related by s_sync->S_SPARM[R24];
prev_s_sparm = s_sparm;
// select first parameter
while ( not_empty prev_s_sparm )
  s_sparm = prev_s_sparm;
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
end while;
while ( not_empty s_sparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_sparm.Name;
  parm.by_ref = ( 1 == s_sparm.By_Ref );
  select one parm_dt related by s_sparm->S_DT[R26];
  select many s_dims related by s_sparm->S_DIM[R52];
  parm_type = ::getTypeReferenceForS_DTWithDims( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
end while;

// see if this is an initializer function
select one c_c related by comp_def->C_C[R4573];
select one c_c_pe related by c_c->PE_PE[R8001];
select any init_function_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                             selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                             selected.feature_name == "InitFunction" );
if ( not_empty init_function_mark and func.name == init_function_mark.value )
  select any s_sparm related by s_sync->S_SPARM[R24];
  if ( empty s_sparm )
    relate func to comp_def across R4561;
  else
    // TODO bad
  end if;
end if;

// relate the body
select one act_act related by s_sync->ACT_FNB[R695]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
  ::setOriginalNames(invocable:invocable, label:act_act.Label);
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("0276ebf3-d52f-404b-96b5-6b47740fee58",
	"3775f12f-f551-4b87-b37b-bcdae037314c",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("572dad4b-a620-48cf-ade7-fd0b6514a723",
	"3775f12f-f551-4b87-b37b-bcdae037314c",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"0276ebf3-d52f-404b-96b5-6b47740fee58",
	'');
INSERT INTO PE_PE
	VALUES ("3775f12f-f551-4b87-b37b-bcdae037314c",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f8603c94-90cc-4b20-9c6e-f665ce733d20",
	"00000000-0000-0000-0000-000000000000",
	'transformInterface',
	'',
	'c_i = param.c_i;
containing_comp_def = param.containing_comp_def;
select one iface related by c_i->Interface[R421];
if ( empty iface )

  // create the file
  create object instance file of File;
  file.name = "I" + ::camelCaseName( name:c_i.Name, start_lower:false );
  file.path = param.path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = param.exclude;

  // create the interface package object
  create object instance iface of Interface;
  relate iface to file across R401;

  // relate to the c_i
  relate iface to c_i across R421;

  // transform messages
  // sort by name to assure consistent translation
  select many c_eps related by c_i->C_EP[R4003];
  index = 1;
  for each c_ep in c_eps
    ::transformMessage( c_ep:c_ep, iface:iface, index:index );
    index = index + 1;
  end for;

  // add to export package
  select one iface related by c_i->Interface[R421];
  if not param.exclude and not_empty iface and empty containing_comp_def
    select one mod related by c_i->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
    select any export_package related by mod->ExportedPackage[R5750] where selected.name == iface.package;
    if empty export_package
      create object instance export_package of ExportedPackage;
      export_package.name = iface.package;
      relate export_package to mod across R5750;
    end if;
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9fda5ab1-f5ea-49cf-a065-4acac8ccbb18",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("80698720-cc57-44ba-8aa5-600c524db338",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("3d1e527a-9091-4e1b-a000-daf06870359d",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9fda5ab1-f5ea-49cf-a065-4acac8ccbb18",
	'');
INSERT INTO S_SPARM
	VALUES ("b67ed16a-244f-4d20-a42a-3a518f61005a",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"3d1e527a-9091-4e1b-a000-daf06870359d",
	'');
INSERT INTO S_SPARM
	VALUES ("a7838204-71df-4011-bae6-75fe5a1953c8",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"b67ed16a-244f-4d20-a42a-3a518f61005a",
	'');
INSERT INTO PE_PE
	VALUES ("f8603c94-90cc-4b20-9c6e-f665ce733d20",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	"00000000-0000-0000-0000-000000000000",
	'transformMessage',
	'',
	'c_ep = param.c_ep;
iface = param.iface;
index = param.index;
select one c_as related by c_ep->C_AS[R4004];
select one c_io related by c_ep->C_IO[R4004];

// create message object
create object instance msg of Message;
msg.name = c_ep.Name;
msg.to_provider = true;
msg.id = index;
msg.async = not_empty c_as;
if ( not_empty c_as )
  msg.to_provider = ( c_as.Direction == IFDirectionType::ClientServer );
elif ( not_empty c_io )
  msg.to_provider = ( c_io.Direction == IFDirectionType::ClientServer );
end if;
relate msg to iface across R419;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("5e4ab653-700e-40a0-a9bf-dafd8ca2a598",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("7ac5a473-81e4-4e54-83d2-4d8ab8cf5711",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'iface',
	"003d869d-0580-4a1f-b1c8-e1657cc0248c",
	0,
	'',
	"5e4ab653-700e-40a0-a9bf-dafd8ca2a598",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("003d869d-0580-4a1f-b1c8-e1657cc0248c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Iface>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("7dc75e7c-1b93-4967-9fd1-e4a9d973edce",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"7ac5a473-81e4-4e54-83d2-4d8ab8cf5711",
	'');
INSERT INTO PE_PE
	VALUES ("2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("74257fe5-db1d-468b-b7b2-b0405455e5ac",
	"00000000-0000-0000-0000-000000000000",
	'transformOperation',
	'',
	'o_tfr = param.o_tfr;
obj = param.obj;

// create operation object
create object instance op of Operation;
op.is_class_based = Scope::Class == o_tfr.Instance_Based;
relate op to obj across R416;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = o_tfr.Name;
if op.is_class_based
  invocable.name = "_" + obj.name + "_" + invocable.name;
end if;
invocable.parent_name = op.class_name;
invocable.parent_package = op.class_package;
relate op to invocable across R427;
select one o_obj related by o_tfr->O_OBJ[R115];

// link type
select one s_dt related by o_tfr->S_DT[R116];
select many s_dims related by o_tfr->S_DIM[R122];
type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
relate type to invocable across R428;

// create parameters
select any o_tparm related by o_tfr->O_TPARM[R117];
prev_o_tparm = o_tparm;
// select first parameter
while (not_empty prev_o_tparm)
  o_tparm = prev_o_tparm;
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
end while;
while (not_empty o_tparm)
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + o_tparm.Name;
  parm.by_ref = (1 == o_tparm.By_Ref);
  select one parm_dt related by o_tparm->S_DT[R118];
  select many s_dims related by o_tparm->S_DIM[R121];
  parm_type = ::getTypeReferenceForS_DTWithDims(s_dt:parm_dt, s_dims:s_dims);
  relate parm_type to parm across R431;
  ::linkParameter(invocable:invocable, parameter:parm);
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
end while;

// relate the body
select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
if (not_empty act_act)
  relate act_act to invocable across R432;
  ::setOriginalNames(invocable:invocable, label:act_act.Label);
end if;

// if this is an optional deferred operation, create a second operation for the supertype implementation
select one o_def related by o_tfr->O_DEF[R126];
if (not_empty o_def and o_def.required == 1)

  // create operation object
  create object instance op of Operation;
  op.is_class_based = Scope::Class == o_tfr.Instance_Based;
  relate op to obj across R416;
  
  // create invocable
  create object instance invocable of InvocableObject;
  invocable.name = "_supertype_" + o_tfr.Name;
  invocable.parent_name = op.class_name;
  invocable.parent_package = op.class_package;
  relate op to invocable across R427;
  
  // link type
  select one s_dt related by o_tfr->S_DT[R116];
  select many s_dims related by o_tfr->S_DIM[R122];
  type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
  relate type to invocable across R428;
  
  // create parameters
  select any o_tparm related by o_tfr->O_TPARM[R117];
  prev_o_tparm = o_tparm;
  // select first parameter
  while (not_empty prev_o_tparm)
    o_tparm = prev_o_tparm;
    select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  end while;
  while (not_empty o_tparm)
    // create parameter
    create object instance parm of FormalParameter;
    parm.name = "p_" + o_tparm.Name;
    parm.by_ref = (1 == o_tparm.By_Ref);
    select one parm_dt related by o_tparm->S_DT[R118];
    select many s_dims related by o_tparm->S_DIM[R121];
    parm_type = ::getTypeReferenceForS_DTWithDims(s_dt:parm_dt, s_dims:s_dims);
    relate parm_type to parm across R431;
    ::linkParameter(invocable:invocable, parameter:parm);
    select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  end while;
  
  // relate the body
  select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
  if (not_empty act_act)
    relate act_act to invocable across R432;
    ::setOriginalNames(invocable:invocable, label:act_act.Label);
  end if;
  
// if this is an required deferred operation with no body (unparsed), create an empty body
// so that the deferral will get created correctly
elif (not_empty o_def and o_def.required == 0 and empty act_act)
  create object instance act_act of ACT_ACT;
  create object instance act_opb of ACT_OPB;
  relate act_act to act_opb across R698;
  relate act_opb to o_tfr across R696;
  relate act_act to invocable across R432;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("33e8c652-ca5f-4d36-a0c9-f60ddeef159e",
	"74257fe5-db1d-468b-b7b2-b0405455e5ac",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("870faa2c-f3c4-4326-b164-18a2f8a53d80",
	"74257fe5-db1d-468b-b7b2-b0405455e5ac",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"33e8c652-ca5f-4d36-a0c9-f60ddeef159e",
	'');
INSERT INTO PE_PE
	VALUES ("74257fe5-db1d-468b-b7b2-b0405455e5ac",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11092e02-9199-4c08-81fd-85b4884f4d66",
	"00000000-0000-0000-0000-000000000000",
	'transformPackage',
	'',
	'ep_pkg = param.ep_pkg;
path = param.path;

containing_comp_def = param.containing_comp_def;
select one mod related by ep_pkg->S_SYS[R1405]->Module[R4760];

sub_path = T::sub(format:"rl", s:ep_pkg.Name);
if path != ""
  sub_path = path + "/" + sub_path;
end if;
pkg_name = ::pathToPackage(path:sub_path);

// get all packageable elements
select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
if (not_empty referred_ep_pkg)
  ep_pkg = referred_ep_pkg;
end if;
select many pe_pes related by ep_pkg->PE_PE[R8000];
select one pkg_mod related by ep_pkg->S_SYS[R1405]->Module[R4760];

if (param.pass == 1)

  // transform datatypes
  select many s_dts related by pe_pes->S_DT[R8001]->S_EDT[R17]->S_DT[R17];
  for each s_dt in s_dts
    ::transformDataType(s_dt:s_dt, exclude:pkg_mod != mod, containing_comp_def:containing_comp_def);
  end for;

elif (param.pass == 2)
  
  // transform interfaces
  select many c_is related by pe_pes->C_I[R8001];
  for each c_i in c_is
    ::transformInterface(c_i:c_i, path:sub_path, exclude:pkg_mod != mod, containing_comp_def:containing_comp_def);
  end for;

  // don''t transform these elements unless they appear in the context of a component
  if not_empty containing_comp_def

    // transform functions
    select many s_syncs related by pe_pes->S_SYNC[R8001];
    for each s_sync in s_syncs
      ::transformFunction(s_sync:s_sync, comp_def:containing_comp_def);
    end for;

    // transform EEs
    select many s_ees related by pe_pes->S_EE[R8001];
    for each s_ee in s_ees
      ::transformUtility(s_ee:s_ee, ep_pkg:ep_pkg, containing_comp_def:containing_comp_def, exclude:false, path:sub_path);
    end for;

    // transform classes
    select many o_objs related by pe_pes->O_OBJ[R8001];
    for each o_obj in o_objs
      ::transformClass(o_obj:o_obj, containing_comp_def:containing_comp_def, path:sub_path);
    end for;
  
  end if;

elif (param.pass == 3)

  // don''t transform these elements unless they appear in the context of a component
  if not_empty containing_comp_def

    // transform associations
    select many r_rels related by pe_pes->R_REL[R8001];
    for each r_rel in r_rels
      ::transformAssociation(r_rel:r_rel, containing_comp_def:containing_comp_def);
    end for;
    
    // transform instance state machines
    select many objs related by pe_pes->O_OBJ[R8001]->Class[R409];
    for each obj in objs
      select one ism related by obj->O_OBJ[R409]->SM_ISM[R518]->SM_SM[R517];
      if not_empty ism
        ::transformStateMachine(sm_sm:ism, obj:obj, is_instance:true);
      else
        select one asm related by obj->O_OBJ[R409]->SM_ASM[R519]->SM_SM[R517];
        if not_empty asm
          ::transformStateMachine(sm_sm:asm, obj:obj, is_instance:false);
        end if;
      end if;
    end for;
  
  end if;

else

  // transform selectors and attribute references
  select many objs related by pe_pes->O_OBJ[R8001]->Class[R409];
  for each obj in objs
    ::transformSelectors(obj:obj);
    ::transformAttributeReferences(obj:obj);
  end for;

end if;

// transform components
select many c_cs related by pe_pes->C_C[R8001];
for each c_c in c_cs
  ::transformComponentDefinition(c_c:c_c, containing_comp_def:containing_comp_def, path:sub_path, pass:param.pass);
end for;

// transform packages
select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
for each inner_ep_pkg in inner_ep_pkgs
  ::transformPackage(ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:sub_path, pass:param.pass);
end for;

',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("75df983d-83b9-42ea-87dc-411170ddf3df",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("912f8c19-5d8d-4eb7-be1a-89c22e6e2dc6",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"75df983d-83b9-42ea-87dc-411170ddf3df",
	'');
INSERT INTO S_SPARM
	VALUES ("2bd3da6f-20bb-4a2e-9598-1051478b2655",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"912f8c19-5d8d-4eb7-be1a-89c22e6e2dc6",
	'');
INSERT INTO S_SPARM
	VALUES ("65ed5781-bcb1-45ed-8c9c-db97c8db733b",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"2bd3da6f-20bb-4a2e-9598-1051478b2655",
	'');
INSERT INTO PE_PE
	VALUES ("11092e02-9199-4c08-81fd-85b4884f4d66",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dc54cc56-f3a1-40ce-9622-5b72536da732",
	"00000000-0000-0000-0000-000000000000",
	'transformPort',
	'',
	'c_po = param.c_po;
comp_def = param.comp_def;
select one c_c related by c_po->C_C[R4010];
select one pe related by c_c->PE_PE[R8001];

// create the file
create object instance file of File;
file.name = comp_def.name + ::camelCaseName(name:c_po.Name, start_lower:false);
file.path = param.path;
file.package = ::pathToPackage(path:file.path);
file.extension = ".java";
file.exclude = param.exclude;

// create the interface package object
create object instance port of Port;
relate port to file across R401;
relate port to c_po across R422;
port.port_name = ::camelCaseName(name:c_po.Name, start_lower:false);

// set port as provider or requirer
select any c_p related by c_po->C_IR[R4016]->C_P[R4009];
port.provider = not_empty c_p;

// relate to other component
relate port to comp_def across R417;

if not param.exclude

  // relate to iface if the iface is there
  select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
  select one iface related by c_i->Interface[R421];
  if empty iface
    select one ep_pkg related by c_i->PE_PE[R8001]->EP_PKG[R8000];
    select any empty_comp_def from instances of ComponentDefinition where false;
    ::transformInterface(c_i:c_i, path: ::ep_pkgToPath(ep_pkg:ep_pkg), exclude:true, containing_comp_def:empty_comp_def);
    select one iface related by c_i->Interface[R421];
  end if;
  if not_empty iface
    relate port to iface across R418;
    select many msgs related by iface->Message[R419];
    for each msg in msgs
      ::transformPortMessage(port:port, msg:msg);
    end for;
  else
    // TODO bad
  end if;

  // add module dependency if necessary
  select one main_mod related by c_po->C_C[R4010]->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
  select one mod related by c_i->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
  if mod != main_mod
    select any dependency related by main_mod->Dependency[R5753.''requires''] where selected.required_module_name == mod.name;
    if empty dependency
      create object instance dependency of Dependency;
      relate mod to main_mod across R5753.''required by'' using dependency;
    end if;
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("d90ff16c-7b5a-4cfc-bd1f-cb7f61a8f5ea",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("2416fad3-aefa-4b39-be26-3377fa98d171",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"d90ff16c-7b5a-4cfc-bd1f-cb7f61a8f5ea",
	'');
INSERT INTO S_SPARM
	VALUES ("5ca8d895-7b79-4c44-b608-ee46576c1d51",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2416fad3-aefa-4b39-be26-3377fa98d171",
	'');
INSERT INTO S_SPARM
	VALUES ("dd2ee594-07e2-4670-9d88-0fd7d211e6ae",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"5ca8d895-7b79-4c44-b608-ee46576c1d51",
	'');
INSERT INTO PE_PE
	VALUES ("dc54cc56-f3a1-40ce-9622-5b72536da732",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	"00000000-0000-0000-0000-000000000000",
	'transformPortMessage',
	'',
	'port = param.port;
msg = param.msg;
select one file related by port->File[R401];

select any c_ep related by msg->Interface[R419]->C_I[R421]->C_EP[R4003] where ( selected.Name == msg.name );
select one c_po related by port->C_PO[R422];

// create port message
create object instance port_msg of PortMessage;
relate port to msg across R420 using port_msg;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = msg.name;
invocable.parent_name = port.name;
invocable.parent_package = port.package;
relate port_msg to invocable across R427;

// populate the OAL
select any act_act from instances of ACT_ACT where false;
select any spr_rep related by c_po->C_IR[R4016]->C_R[R4009]->SPR_REP[R4500] where ( selected.ExecutableProperty_Id == c_ep.Id );
select one spr_ro related by spr_rep->SPR_RO[R4502];
if ( not_empty spr_ro )
  select one act_act related by spr_ro->ACT_ROB[R685]->ACT_ACT[R698];
else
  select one spr_rs related by spr_rep->SPR_RS[R4502];
  if ( not_empty spr_rs )
    select one act_act related by spr_rs->ACT_RSB[R684]->ACT_ACT[R698];
  else
    select any spr_pep related by c_po->C_IR[R4016]->C_P[R4009]->SPR_PEP[R4501] where ( selected.ExecutableProperty_Id == c_ep.Id );
    select one spr_po related by spr_pep->SPR_PO[R4503];
    if ( not_empty spr_po )
      select one act_act related by spr_po->ACT_POB[R687]->ACT_ACT[R698];
    else
      select one spr_ps related by spr_pep->SPR_PS[R4503];
      if ( not_empty spr_ps )
        select one act_act related by spr_ps->ACT_PSB[R686]->ACT_ACT[R698];
      end if;
    end if;
  end if;
end if;

// link type
type = ::getBasicTypeReferenceByName(name:"void");
select one s_dt related by c_ep->C_IO[R4004]->S_DT[R4008];
select many s_dims related by c_ep->C_IO[R4004]->S_DIM[R4018];
if not_empty s_dt
  type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
end if;
relate type to invocable across R428;

// create parameters
select any c_pp related by c_ep->C_PP[R4006];
prev_c_pp = c_pp;
// select first parameter
while ( not_empty prev_c_pp )
  c_pp = prev_c_pp;
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
end while;
while ( not_empty c_pp )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + c_pp.Name;
  parm.by_ref = ( 1 == c_pp.By_Ref );
  select one parm_dt related by c_pp->S_DT[R4007];
  select many s_dims related by c_pp->S_DIM[R4017];
  parm_type_ref = ::getTypeReferenceForS_DTWithDims( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type_ref to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
end while;

// relate the body
if ( not_empty act_act )
  relate act_act to invocable across R432;
  ::setOriginalNames(invocable:invocable, label:act_act.Label);
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("4a996a1b-1671-4519-b30e-8e417f450dd9",
	"41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	'port',
	"d29fe14e-2574-4613-ac57-716ebd8e905c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d29fe14e-2574-4613-ac57-716ebd8e905c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("eeeff60a-c20e-402e-9400-be4d292ac084",
	"41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	'msg',
	"af93d414-e2e8-430c-b266-a77360256015",
	0,
	'',
	"4a996a1b-1671-4519-b30e-8e417f450dd9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("af93d414-e2e8-430c-b266-a77360256015",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Message>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/interfaces/interfaces.xtuml');
INSERT INTO PE_PE
	VALUES ("41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0e170f43-da9c-4938-b403-530f03b013de",
	"00000000-0000-0000-0000-000000000000",
	'transformSatisfaction',
	'',
	'c_sf = param.c_sf;
select one provider related by c_sf->C_P[R4002]->C_IR[R4009]->C_PO[R4016]->Port[R422];
select one requirer related by c_sf->C_R[R4002]->C_IR[R4009]->C_PO[R4016]->Port[R422];
relate provider to requirer across R4160.''satisfies required'';',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("df6caa72-bba2-4448-8b3a-3f9cc54d18ea",
	"0e170f43-da9c-4938-b403-530f03b013de",
	'c_sf',
	"cb87cce2-556b-41ae-85e4-d8813981c372",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cb87cce2-556b-41ae-85e4-d8813981c372",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Satisfaction>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("0e170f43-da9c-4938-b403-530f03b013de",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c04fde8e-f58c-4d2b-87a7-8393b796f271",
	"00000000-0000-0000-0000-000000000000",
	'transformState',
	'',
	'sm_state = param.sm_state;
sm = param.sm;

// create state
create object instance state of State;
relate state to sm across R4751;
state.final = sm_state.Final == 1;
select many existing_states related by sm->State[R4751];
state.number = cardinality existing_states;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = T::sub( format:"_u", s:sm_state.Name );
invocable.parent_name = sm.name;
invocable.parent_package = sm.package;
relate state to invocable across R427;
select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];

// relate the body
select one act_act related by sm_act->ACT_SAB[R691]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
  ::setOriginalNames(invocable:invocable, label:act_act.Label);
end if;

// link type
type = ::getBasicTypeReferenceByName( name:"void" );
relate type to invocable across R428;

// link to ooa state
relate state to sm_state across R4758;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e075ca53-4cf3-4ba1-92c2-60e8754317fd",
	"c04fde8e-f58c-4d2b-87a7-8393b796f271",
	'sm_state',
	"ce86dade-b263-4245-8001-19dd4123f4f9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ce86dade-b263-4245-8001-19dd4123f4f9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine State>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("efcf7b2b-956d-4ff6-86b6-769109cbcdbf",
	"c04fde8e-f58c-4d2b-87a7-8393b796f271",
	'sm',
	"e26cd508-1f72-4f47-bc3a-f80c2afd819a",
	0,
	'',
	"e075ca53-4cf3-4ba1-92c2-60e8754317fd",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e26cd508-1f72-4f47-bc3a-f80c2afd819a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/statemachine/statemachine.xtuml');
INSERT INTO PE_PE
	VALUES ("c04fde8e-f58c-4d2b-87a7-8393b796f271",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	"00000000-0000-0000-0000-000000000000",
	'transformStateMachine',
	'',
	'sm_sm = param.sm_sm;
obj = param.obj;

// return early if the state machine has already been translated
select one sm related by obj->StateMachine[R4750];
if not_empty sm
  return;
end if;

// assure than any supertype state machines are translated first
select many supertype_rels related by sm->Class[R4750]->Relationship[R435] where selected.rel_type == RelationshipType::SuperSubtype;
select many supertype_objs related by supertype_rels->Class[R434];
for each supertype_obj in supertype_objs
  select one supertype_sm_sm related by supertype_obj->O_OBJ[R409]->SM_ISM[R518]->SM_SM[R517];
  if not_empty supertype_sm_sm
    ::transformStateMachine(sm_sm:supertype_sm_sm, obj:supertype_obj, is_instance:true);
  end if;
end for;

// create the state machine file
create object instance file of File;
file.name = obj.name + "StateMachine";
file.path = ::formatPath(path:obj.package);
file.package = obj.package;
file.extension = ".java";
file.exclude = false;

// create the object
create object instance sm of StateMachine;
relate sm to file across R401;
relate sm to obj across R4750;
sm.is_instance = param.is_instance;

// transform states
select many sm_states related by sm_sm->SM_STATE[R501] where SORT::ascending(attr:"Numb");
for each sm_state in sm_states
  ::transformState(sm_state:sm_state, sm:sm);
end for;

if (sm.is_instance)
  // create the default initial state
  create object instance uninitialized of State;
  relate uninitialized to sm across R4751;
  uninitialized.final = false;
  uninitialized.number = 0;
  
  // create invocable for non-existent state
  create object instance invocable of InvocableObject;
  invocable.name = "UNINITIALIZED";
  invocable.parent_name = sm.name;
  invocable.parent_package = sm.package;
  relate uninitialized to invocable across R427;
  
  // link type
  type = ::getBasicTypeReferenceByName(name:"void");
  relate type to invocable across R428;
end if;

// transform events
select many sm_levts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526]->SM_SEVT[R526]->SM_EVT[R525];
select many sm_pevts related by sm_sm->SM_EVT[R502]->SM_PEVT[R525]->SM_EVT[R525];
sm_evts = sm_levts + sm_pevts;
for each sm_evt in sm_evts
  ::transformEvent(sm_evt:sm_evt, obj:obj);
end for;

// transform transition table
select many states related by sm->State[R4751];
for each state in states

  // create a row for this start state
  create object instance row of TransitionTableRow;
  relate row to sm across R4753;
  relate row to state across R4754;
  row.index = state.number;
  
  // transform local events
  select many evts related by obj->Event[R4752];
  for each evt in evts
    ::transformStateEventMatrixEntry(row:row, evt:evt);
  end for;
  
  // transform polymorphic events
  select many poly_evts from instances of Event where false;
  select many supertype_rels related by sm->Class[R4750]->Relationship[R435] where selected.rel_type == RelationshipType::SuperSubtype;
  select many supertype_objs related by supertype_rels->Class[R434];
  while not_empty supertype_objs
    select many evts related by supertype_objs->Event[R4752]->SM_EVT[R4759]->SM_PEVT[R525]->SM_EVT[R525]->Event[R4759];
    poly_evts = poly_evts + evts;
    select many supertype_rels related by supertype_objs->Relationship[R435] where selected.rel_type == RelationshipType::SuperSubtype;
    select many supertype_objs related by supertype_rels->Class[R434];
  end while;
  for each evt in poly_evts
    ::transformStateEventMatrixEntry(row:row, evt:evt);
  end for;
  
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("52462f5f-c541-4d6a-884e-fcfacb4de247",
	"cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("5f45583f-5aa4-4ba1-a0db-bef2a7a9a239",
	"cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"52462f5f-c541-4d6a-884e-fcfacb4de247",
	'');
INSERT INTO S_SPARM
	VALUES ("cccbaa19-5470-4691-8f15-61a4263572b6",
	"cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	'is_instance',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"5f45583f-5aa4-4ba1-a0db-bef2a7a9a239",
	'');
INSERT INTO PE_PE
	VALUES ("cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d02e7000-869b-4743-9418-85576a503800",
	"00000000-0000-0000-0000-000000000000",
	'transformUserDefinedType',
	'',
	'/* TODO
s_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = param.exclude;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = "new " + type.name + "()";
create object instance udt of UserDefinedType;
relate type to udt across R407;
relate udt to file across R401;
relate type to file across R3803;
*/',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("78c72c79-4b9b-423f-926e-db02292501ed",
	"d02e7000-869b-4743-9418-85576a503800",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("51281b01-7727-4521-8775-195558d0ebc9",
	"d02e7000-869b-4743-9418-85576a503800",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"78c72c79-4b9b-423f-926e-db02292501ed",
	'');
INSERT INTO PE_PE
	VALUES ("d02e7000-869b-4743-9418-85576a503800",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	"00000000-0000-0000-0000-000000000000",
	'transformUtility',
	'',
	's_ee = param.s_ee;
containing_comp_def = param.containing_comp_def;

// create the file
create object instance file of File;
file.name = ::camelCaseName(name:s_ee.Key_Lett, start_lower:false);
file.path = param.path;
file.package = ::pathToPackage(path:file.path);
file.extension = ".java";
file.exclude = param.exclude;

// create the utility object
create object instance utility of Utility;
relate utility to file across R401;

// relate the containing component
if (not_empty containing_comp_def)
  create object instance util_ref of UtilityInComponent;
  relate utility to containing_comp_def across R4558 using util_ref;
end if;

// transform each utility function
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  ::transformUtilityFunction(s_brg:s_brg, utility:utility);
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("4ec862c4-7311-4839-9230-77e6cff9ec1c",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	's_ee',
	"fc04695e-75c8-413e-a409-6dbc6465e011",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc04695e-75c8-413e-a409-6dbc6465e011",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<External Entity>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("e5acec51-5918-4996-ada8-33baf8c87865",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"c0d939f0-c1c0-4220-a02c-3bfc91900773",
	'');
INSERT INTO S_SPARM
	VALUES ("5078c5f9-c41e-4561-9c18-464a2137b800",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e5acec51-5918-4996-ada8-33baf8c87865",
	'');
INSERT INTO S_SPARM
	VALUES ("c0d939f0-c1c0-4220-a02c-3bfc91900773",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"4ec862c4-7311-4839-9230-77e6cff9ec1c",
	'');
INSERT INTO S_SPARM
	VALUES ("65c10430-7eed-4271-b373-73fc7b6d5994",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5078c5f9-c41e-4561-9c18-464a2137b800",
	'');
INSERT INTO PE_PE
	VALUES ("13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7987d2a8-0081-4942-a0f1-09509ae9f755",
	"00000000-0000-0000-0000-000000000000",
	'transformUtilityFunction',
	'',
	's_brg = param.s_brg;
utility = param.utility;

// create utility function object
create object instance util_func of UtilityFunction;
relate util_func to utility across R4559;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_brg.Name;
invocable.parent_name = utility.name;
invocable.parent_package = utility.package;
relate util_func to invocable across R427;
select one s_ee related by s_brg->S_EE[R19];

// link type
select one s_dt related by s_brg->S_DT[R20];
select many s_dims related by s_brg->S_DIM[R50];
type = ::getTypeReferenceForS_DTWithDims(s_dt:s_dt, s_dims:s_dims);
relate type to invocable across R428;

// create parameters
select any s_bparm related by s_brg->S_BPARM[R21];
prev_s_bparm = s_bparm;
// select first parameter
while (not_empty prev_s_bparm)
  s_bparm = prev_s_bparm;
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
end while;
while (not_empty s_bparm)
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_bparm.Name;
  parm.by_ref = (1 == s_bparm.By_Ref);
  select one parm_dt related by s_bparm->S_DT[R22];
  select many s_dims related by s_bparm->S_DIM[R49];
  parm_type = ::getTypeReferenceForS_DTWithDims(s_dt:parm_dt, s_dims:s_dims);
  relate parm_type to parm across R431;
  ::linkParameter(invocable:invocable, parameter:parm);
  select one s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
end while;

// relate bridge
relate s_brg to util_func across R4570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("42373b64-8fb9-4a71-b28d-d88fab9d5a5e",
	"7987d2a8-0081-4942-a0f1-09509ae9f755",
	'utility',
	"05845c9d-7216-4905-8b60-6bf9f95f42e7",
	0,
	'',
	"4cfc6825-9d26-4a1b-a502-e85f0e527e1f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("05845c9d-7216-4905-8b60-6bf9f95f42e7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Utility>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/component/component.xtuml');
INSERT INTO S_SPARM
	VALUES ("4cfc6825-9d26-4a1b-a502-e85f0e527e1f",
	"7987d2a8-0081-4942-a0f1-09509ae9f755",
	's_brg',
	"ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("7987d2a8-0081-4942-a0f1-09509ae9f755",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("59873bd4-3180-4bda-a03f-0df9c6b6b4e8",
	"00000000-0000-0000-0000-000000000000",
	'transformStateEventMatrixEntry',
	'',
	'row = param.row;
evt = param.evt;

select one sm_evt related by evt->SM_EVT[R4759];
select one state related by row->State[R4754];
select one sm_state related by state->SM_STATE[R4758];
select one sm related by state->StateMachine[R4751];

// create a cell for this event
create object instance cell of TransitionTableCell;
relate cell to row across R4755;
relate cell to evt across R4756;
select many existing_cells related by row->TransitionTableCell[R4755];
cell.index = cardinality existing_cells;

// handle non-existent start state
if (state.number == 0)

  select one sm_crtxn related by sm_evt->SM_SEVT[R525]->SM_LEVT[R526]->SM_CRTXN[R509];
  if (not_empty sm_crtxn)

    // create transition
    create object instance txn of Transition;
    select one sm_txn related by sm_crtxn->SM_TXN[R507];
    select one dest_sm_state related by sm_txn->SM_STATE[R506];
    select one dest_state related by dest_sm_state->State[R4758];
    relate dest_state to cell across R4757 using txn;
    cell.transition_type = TransitionType::TRANSITION;

    // create invocable
    create object instance invocable of InvocableObject;
    invocable.name = state.name + "TxnTo" + dest_state.name;
    invocable.parent_name = sm.name;
    invocable.parent_package = sm.package;
    relate txn to invocable across R427;
    select one sm_act related by sm_txn->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
    
    // relate the body
    select one act_act related by sm_act->ACT_TAB[R688]->ACT_ACT[R698];
    if (not_empty act_act)
      relate act_act to invocable across R432;
      ::setOriginalNames(invocable:invocable, label:act_act.Label);
    end if;
    
    // link type
    type = ::getBasicTypeReferenceByName(name:"void");
    relate type to invocable across R428;

  else
    
    // default to ignore for polymorphic events that are passed down to subtype state machines
    select one sm_pevt related by sm_evt->SM_PEVT[R525];
    if not_empty sm_pevt
      cell.transition_type = TransitionType::IGNORE;
    
    // default to cannot happen for any other event
    else
      cell.transition_type = TransitionType::CANT_HAPPEN;

    end if;

  end if;

else

  select any sm_seme related by sm_evt->SM_SEVT[R525]->SM_SEME[R503] where (selected.SMstt_ID == sm_state.SMstt_ID);
  if empty sm_seme
    select any sm_nlevt related by sm_evt->SM_PEVT[R525]->SM_NLEVT[R527] where selected.SM_ID == sm_state.SM_ID;
    select any sm_seme related by sm_nlevt->SM_SEVT[R526]->SM_SEME[R503] where (selected.SMstt_ID == sm_state.SMstt_ID);
  end if;
  if (not_empty sm_seme)

    // handle cannot happen
    select one cant_happen related by sm_seme->SM_CH[R504];
    if (not_empty cant_happen)
      cell.transition_type = TransitionType::CANT_HAPPEN;
    else

      // handle event ignored
      select one event_ignored related by sm_seme->SM_EIGN[R504];
      if (not_empty event_ignored)
        cell.transition_type = TransitionType::IGNORE;
      
      // handle new state transition
      else

        // create transition
        create object instance txn of Transition;
        select one sm_txn related by sm_seme->SM_NSTXN[R504]->SM_TXN[R507];
        select one dest_sm_state related by sm_txn->SM_STATE[R506];
        select one dest_state related by dest_sm_state->State[R4758];
        relate dest_state to cell across R4757 using txn;
        cell.transition_type = TransitionType::TRANSITION;

        // create invocable
        create object instance invocable of InvocableObject;
        invocable.name = state.name + "TxnTo" + dest_state.name;
        invocable.parent_name = sm.name;
        invocable.parent_package = sm.package;
        relate txn to invocable across R427;
        select one sm_act related by sm_txn->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
        
        // relate the body
        select one act_act related by sm_act->ACT_TAB[R688]->ACT_ACT[R698];
        if (not_empty act_act)
          relate act_act to invocable across R432;
          ::setOriginalNames(invocable:invocable, label:act_act.Label);
        end if;
        
        // link type
        type = ::getBasicTypeReferenceByName(name:"void");
        relate type to invocable across R428;

      end if;
    end if;
  else
    // default to ignore for polymorphic events that are passed down to subtype state machines
    select one sm_pevt related by sm_evt->SM_PEVT[R525];
    if not_empty sm_pevt
      cell.transition_type = TransitionType::IGNORE;
    
    else
      // TODO bad
    end if;
  end if;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	3);
INSERT INTO S_SPARM
	VALUES ("eb5b6eef-cb8d-4fcd-b63f-9267f2af8c08",
	"59873bd4-3180-4bda-a03f-0df9c6b6b4e8",
	'evt',
	"6f9d5490-60e9-489c-a2c7-507dc913da72",
	0,
	'',
	"a329a57a-5f94-4d8a-a6b3-87a05cd9464a",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6f9d5490-60e9-489c-a2c7-507dc913da72",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Event>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/statemachine/statemachine.xtuml');
INSERT INTO S_SPARM
	VALUES ("a329a57a-5f94-4d8a-a6b3-87a05cd9464a",
	"59873bd4-3180-4bda-a03f-0df9c6b6b4e8",
	'row',
	"582e47a7-1515-43bf-9880-d436a4d880de",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("582e47a7-1515-43bf-9880-d436a4d880de",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Transition Table Row>',
	'',
	'',
	'../../../../core-architecture/models/core-architecture/architecture/statemachine/statemachine.xtuml');
INSERT INTO PE_PE
	VALUES ("59873bd4-3180-4bda-a03f-0df9c6b6b4e8",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1cfd3671-5013-4535-986f-f3f6ff283140",
	"00000000-0000-0000-0000-000000000000",
	'transformDataType',
	'',
	's_dt = param.s_dt;
containing_comp_def = param.containing_comp_def;

select one s_edt related by s_dt->S_EDT[R17];
if not_empty s_edt
  ::transformEnumeratedType(s_dt:s_dt, exclude:param.exclude);
else
  select one s_udt related by s_dt->S_UDT[R17];
  if not_empty s_udt
    ::transformUserDefinedType(s_dt:s_dt, exclude:param.exclude);
  end if;
end if;

// TODO structured data types

// add to export package
select one type related by s_dt->Type[R423];
if not param.exclude and not_empty type and empty containing_comp_def
  select one mod related by s_dt->PE_PE[R8001]->EP_PKG[R8000]->S_SYS[R1405]->Module[R4760];
  select any export_package related by mod->ExportedPackage[R5750] where selected.name == type.package;
  if empty export_package
    create object instance export_package of ExportedPackage;
    export_package.name = type.package;
    relate export_package to mod across R5750;
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	4);
INSERT INTO S_SPARM
	VALUES ("e07e1f55-b86f-4df3-ac9e-6c366c5dd5db",
	"1cfd3671-5013-4535-986f-f3f6ff283140",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5f4ecdf8-8e48-447c-b430-73691e06ab39",
	"1cfd3671-5013-4535-986f-f3f6ff283140",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e07e1f55-b86f-4df3-ac9e-6c366c5dd5db",
	'');
INSERT INTO S_SPARM
	VALUES ("c2facdb5-456c-443e-8deb-938b8246ccf7",
	"1cfd3671-5013-4535-986f-f3f6ff283140",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"5f4ecdf8-8e48-447c-b430-73691e06ab39",
	'');
INSERT INTO PE_PE
	VALUES ("1cfd3671-5013-4535-986f-f3f6ff283140",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0b1e28c3-bc08-473f-9b52-7e1852fdda24",
	"00000000-0000-0000-0000-000000000000",
	'transformComponentReference',
	'',
	'c_c = param.c_c;
select one ep_pkg related by c_c->PE_PE[R8001]->EP_PKG[R8000];
path = ::ep_pkgToPath(ep_pkg:ep_pkg) + "/" + T::sub(format:"l", s:c_c.Name);

// create the file
create object instance file of File;
file.name = ::camelCaseName(name:c_c.Name, start_lower:false);
file.path = path;
file.package = ::pathToPackage(path:path);
file.extension = ".java";
file.exclude = true;

// create the component definition object
create object instance comp_def of ComponentDefinition;
relate comp_def to file across R401;
relate c_c to comp_def across R4573;

select many c_pos related by c_c->C_PO[R4010];
for each c_po in c_pos
  ::transformPort(c_po:c_po, comp_def:comp_def, path:file.path, exclude:true);
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("d924cc1a-cfc9-4143-8c47-1ff3f2c399e7",
	"0b1e28c3-bc08-473f-9b52-7e1852fdda24",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("0b1e28c3-bc08-473f-9b52-7e1852fdda24",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0ef8060d-9493-4354-8f6e-aea7c5cc1479",
	"00000000-0000-0000-0000-000000000000",
	'transformModule',
	'',
	's_sys = param.s_sys;

// create a file
create object instance file of File;
file.name = s_sys.Name;
file.exclude = not param.main_module;

// special cases for built in modules
if s_sys.Name == "runtime-util"
  file.name = "io.ciera.runtime.util";
end if;

// create the module object
create object instance mod of Module;
relate mod to file across R401;
mod.main_module = param.main_module;
relate s_sys to mod across R4760;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	5);
INSERT INTO S_SPARM
	VALUES ("787c7dc2-6786-42f2-bc1e-ec7e2cb73ddf",
	"0ef8060d-9493-4354-8f6e-aea7c5cc1479",
	's_sys',
	"4b886601-55ee-4d42-a1f8-f5c45d459db2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4b886601-55ee-4d42-a1f8-f5c45d459db2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<System Model>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("29086176-dd71-45ca-82f1-1441c510fe69",
	"0ef8060d-9493-4354-8f6e-aea7c5cc1479",
	'main_module',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"787c7dc2-6786-42f2-bc1e-ec7e2cb73ddf",
	'');
INSERT INTO PE_PE
	VALUES ("0ef8060d-9493-4354-8f6e-aea7c5cc1479",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("9092a4a9-91f5-4e59-984b-3ca72917240d",
	'tool-core',
	1,
	'../tool-core.xtuml');
