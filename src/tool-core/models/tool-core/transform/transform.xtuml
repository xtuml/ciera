-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'transform',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("54ceecfe-b8b4-4268-a224-ad7862274528",
	112,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	200,
	150,
	0,
	'',
	'tool-core::transform');
INSERT INTO GD_GE
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef",
	"54ceecfe-b8b4-4268-a224-ad7862274528",
	"f9a85e65-cedd-4444-aef5-bae5288e31bc",
	108,
	0,
	'tool-core::transform::expression');
INSERT INTO GD_SHP
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO GD_NCS
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"8da75311-8c4e-4898-bb26-fd492421a8ef");
INSERT INTO DIM_GE
	VALUES (0.000000,
	0.000000,
	"8da75311-8c4e-4898-bb26-fd492421a8ef",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("8da75311-8c4e-4898-bb26-fd492421a8ef",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO GD_GE
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40",
	"54ceecfe-b8b4-4268-a224-ad7862274528",
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	108,
	0,
	'tool-core::transform::statement');
INSERT INTO GD_SHP
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO GD_NCS
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO DIM_ND
	VALUES (200.000000,
	150.000000,
	"3de88190-5be5-4acb-9b45-023f70eaeb40");
INSERT INTO DIM_GE
	VALUES (220.000000,
	0.000000,
	"3de88190-5be5-4acb-9b45-023f70eaeb40",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("3de88190-5be5-4acb-9b45-023f70eaeb40",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_DIA
	VALUES ("54ceecfe-b8b4-4268-a224-ad7862274528",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("d3efe646-3858-48ad-b388-1f77f25d98d8",
	"00000000-0000-0000-0000-000000000000",
	'linkParameter',
	'',
	'invocable = param.invocable;
parm = param.parameter;
// link parameter
select any last_parm related by invocable->FormalParameter[R429];
select one next_parm related by last_parm->FormalParameter[R404.''precedes''];
while ( not_empty next_parm )
  last_parm = next_parm;
  select one next_parm related by last_parm->FormalParameter[R404.''precedes''];
end while;
if ( not_empty last_parm )
  relate parm to last_parm across R404.''follows'';
end if;
relate parm to invocable across R429;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("5cca3304-f498-4e8d-b80e-083481d65cfa",
	"d3efe646-3858-48ad-b388-1f77f25d98d8",
	'invocable',
	"3ab44839-4426-4754-b12a-0a00ce4dae1a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3ab44839-4426-4754-b12a-0a00ce4dae1a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocable Object>',
	'',
	'',
	'../architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("9e29165a-1f80-475b-a6f0-ecb98974f15f",
	"d3efe646-3858-48ad-b388-1f77f25d98d8",
	'parameter',
	"4f106c1b-2473-4622-9798-816c7eb93613",
	0,
	'',
	"5cca3304-f498-4e8d-b80e-083481d65cfa",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4f106c1b-2473-4622-9798-816c7eb93613",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Formal Parameter>',
	'',
	'',
	'../architecture/invocable/invocable.xtuml');
INSERT INTO PE_PE
	VALUES ("d3efe646-3858-48ad-b388-1f77f25d98d8",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0307331a-f934-464c-a586-c201ec3f4b4d",
	"00000000-0000-0000-0000-000000000000",
	'resolveAssociativeSelections',
	'',
	'// This function selects all ACT_LNK instances which select directly from one to
// other or other to one on an associative relationship and turns it into two 
// links.

select many act_lnks from instances of ACT_LNK;
for each act_lnk in act_lnks
  
  select one r_rel related by act_lnk->R_REL[R681];
  select one r_aoth related by r_rel->R_ASSOC[R206]->R_AOTH[R210];
  select one r_assr related by r_rel->R_ASSOC[R206]->R_ASSR[R211];
  select one assr_obj related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];
  
  select one target_obj related by act_lnk->O_OBJ[R678];
  select any prev_lnk from instances of ACT_LNK where false;
  select any v_int from instances of V_INT where false;
  select any v_ins from instances of V_INS where false;
  select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds'']; // previous link
  select one base_obj related by prev_lnk->O_OBJ[R678];
  if ( empty base_obj )
    select one v_int related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_IRF[R801]->V_VAR[R808]->V_INT[R814]; // instance reference
    select one base_obj related by v_int->O_OBJ[R818];
    if ( empty base_obj )
      select one v_ins related by act_lnk->ACT_SEL[R637]->V_VAL[R613]->V_ISR[R801]->V_VAR[R809]->V_INS[R814]; // instance reference set
      select one base_obj related by v_ins->O_OBJ[R819];
    end if;
  end if;
  
  // if this is an associative selection in which the link class is _not_ involved, it must be split up
  if ( not_empty r_assr and target_obj.Obj_ID != r_assr.Obj_ID and base_obj.Obj_ID != r_assr.Obj_ID )
  
    // create the first intermediate link
    create object instance act_lnk1 of ACT_LNK;
    act_lnk1.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk1.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk1.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk1.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk1.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk1.phraseColumn = act_lnk.phraseColumn;
    act_lnk1.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    relate r_rel to act_lnk1 across R681;
    relate act_lnk1 to assr_obj across R678;
    if ( 1 == r_assr.Mult or ( not_empty prev_lnk and Multiplicity::Many == prev_lnk.Mult ) or not_empty v_ins )
      act_lnk1.Mult = Multiplicity::Many; // always many if the associative object has multiplicity many, or the starting point is multiplicity many
    else
      if ( target_obj.Obj_ID != base_obj.Obj_ID and r_aoth.Obj_ID == target_obj.Obj_ID ) or 
         ( target_obj.Obj_ID == base_obj.Obj_ID and r_aoth.Txt_Phrs == C_UTIL::stripTics( s:act_lnk.Rel_Phrase ) )  // one to other
        if ( 1 == r_aoth.Mult )
          act_lnk1.Mult = Multiplicity::Many;
        else
          act_lnk1.Mult = Multiplicity::One;
        end if;
      end if;
    end if;

    // create the second intermediate link
    create object instance act_lnk2 of ACT_LNK;
    act_lnk2.modelClassKeyLettersLineNumber = act_lnk.modelClassKeyLettersLineNumber;
    act_lnk2.modelClassKeyLettersColumn = act_lnk.modelClassKeyLettersColumn;
    act_lnk2.associationNumberLineNumber = act_lnk.associationNumberLineNumber;
    act_lnk2.associationNumberColumn = act_lnk.associationNumberColumn;
    act_lnk2.phraseLineNumber = act_lnk.phraseLineNumber;
    act_lnk2.phraseColumn = act_lnk.phraseColumn;
    act_lnk2.Rel_Phrase = act_lnk.Rel_Phrase; // use the same rel phrase
    act_lnk2.Mult = act_lnk.Mult; // the second link always gets the same multiplicity as the original link
    relate r_rel to act_lnk2 across R681;
    relate act_lnk2 to target_obj across R678;
    
    // link the two together and insert into the order
    relate act_lnk1 to act_lnk2 across R604.''precedes'';
    select one next_lnk related by act_lnk->ACT_LNK[R604.''precedes''];
    if ( not_empty next_lnk )
      unrelate act_lnk from next_lnk across R604.''precedes'';
      relate act_lnk2 to next_lnk across R604.''precedes'';
    end if;
    if ( not_empty prev_lnk )
      unrelate act_lnk from prev_lnk across R604.''succeeds'';
      relate act_lnk1 to prev_lnk across R604.''succeeds'';
    else // this is the starting point
      select one act_sel related by act_lnk->ACT_SEL[R637];
      unrelate act_lnk from act_sel across R637;
      relate act_lnk1 to act_sel across R637;
    end if;
    
    // dispose old link
    unrelate target_obj from act_lnk across R678;
    unrelate r_rel from act_lnk across R681;
    delete object instance act_lnk;
    
  end if;
  
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("0307331a-f934-464c-a586-c201ec3f4b4d",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e3faac76-ad13-45c6-a913-77b47aaf7255",
	"00000000-0000-0000-0000-000000000000",
	'resolveTypeImports',
	'',
	'select many types from instances of Type;
for each type in types
  select many impl_files from instances of File where false;
  select many both_files from instances of File where false;

  // find files
  select many files related by type->TypeReference[R3800]->Attribute[R424]->Class[R410]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Attribute[R424]->Class[R410]->ClassSet[R406]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Function[R427]->ComponentDefinition[R405]->File[R401];
  both_files = both_files | files;

  select many inst_ops related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Operation[R427] where ( not selected.is_class_based );
  select many files related by inst_ops->Class[R416]->File[R401];
  both_files = both_files | files;

  select many class_ops related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Operation[R427] where ( selected.is_class_based );
  select many files related by class_ops->Class[R416]->File[R401];
  impl_files = impl_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->PortMessage[R427]->Message[R420]->Interface[R419]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->PortMessage[R427]->Port[R420]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->UtilityFunction[R427]->Utility[R4559]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Event[R427]->TransitionTableCell[R4756]->State[R4757]->StateMachine[R4751]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->FormalParameter[R431]->InvocableObject[R429]->Event[R427]->StateMachine[R4752]->Class[R4750]->File[R401];
  impl_files = impl_files | files;

  select many inst_ops related by type->TypeReference[R3800]->InvocableObject[R428]->Operation[R427] where ( not selected.is_class_based );
  select many files related by inst_ops->Class[R416]->File[R401];
  both_files = both_files | files;

  select many class_ops related by type->TypeReference[R3800]->InvocableObject[R428]->Operation[R427] where ( selected.is_class_based );
  select many files related by class_ops->Class[R416]->File[R401];
  impl_files = impl_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428]->PortMessage[R427]->Message[R420]->Interface[R419]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428]->PortMessage[R427]->Port[R420]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->InvocableObject[R428]->UtilityFunction[R427]->Utility[R4559]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Selector[R446]->InstanceSelector[R445]->Class[R442]->File[R401];
  both_files = both_files | files;

  select many files related by type->TypeReference[R3800]->Selector[R446]->SetSelector[R445]->ClassSet[R444]->File[R401];
  both_files = both_files | files;

  // add to imports
  for each file in impl_files
    type.addToImports( file:file, type:ImportType::IMPL );
  end for;
  for each file in both_files
    type.addToImports( file:file, type:ImportType::BOTH );
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("e3faac76-ad13-45c6-a913-77b47aaf7255",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1e4dbe35-ab3b-43bc-bbad-3e469d39d295",
	"00000000-0000-0000-0000-000000000000",
	'resolveUserDefinedTypes',
	'',
	'select many udts from instances of UserDefinedType;
for each udt in udts

  select one type related by udt->Type[R407];
  select one base_type related by type->S_DT[R423]->S_UDT[R17]->S_DT[R18]->Type[R423];
  if ( empty base_type )
    // TODO bad
  end if;
  
  relate udt to base_type across R3802;
  
  // add to imports
  select one file related by udt->File[R401];
  ::addTypeToImports( file:file, type_to_import:base_type, type:ImportType::IMPL );

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("1e4dbe35-ab3b-43bc-bbad-3e469d39d295",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	"00000000-0000-0000-0000-000000000000",
	'transformApplication',
	'',
	'root_package = param.root_package;
select one s_sys related by root_package->S_SYS[R1405];

// get application marks
select any app_name_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationName" );
select any app_pkg_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "ApplicationPackage" );

// create the file
create object instance file of File;
if ( not_empty app_name_mark )
  file.name = app_name_mark.value;
else
  file.name = ::camelCaseName( name:s_sys.Name, start_lower:false ) + "Application";
end if;
if ( not_empty app_pkg_mark )
  file.package = app_pkg_mark.value;
  file.path = ::formatPath( path:file.package );
else
  file.path = T::sub( format:"l", s:T::sub( format:"r", s:s_sys.Name ) );
  file.package = ::pathToPackage( path:file.path );
end if;
file.extension = ".java";
file.exclude = false;

// create the application object
create object instance app of Application;
relate app to file across R401;

// see if this needs to be generated as an asynchronous application
select any async_app_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "AsyncApplication" );
app.async = not_empty async_app_mark;

// create application executors
index = 0;
while ( index < 1 ) // single executor for now
  create object instance executor of ApplicationExecutor;
  if ( app.async )
    executor.index = -1;
  else
    executor.index = index;
  end if;
  relate executor to app across R4027;
  index = index + 1;
end while;

// translate components definitions
select many c_cs related by root_package->PE_PE[R8000]->C_C[R8001];
select many cl_ics related by root_package->PE_PE[R8000]->CL_IC[R8001]->C_C[R4201];
c_cs = c_cs | cl_ics;
select any empty_comp_def from instances of ComponentDefinition where false;
select any current_comp_inst from instances of ComponentInstantiation where false;
for each c_c in c_cs
  select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  if ( empty comp_def )
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:1 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:2 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:empty_comp_def, path:param.path, pass:3 );
    select any comp_def from instances of ComponentDefinition where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) );
  end if;
  create object instance comp_inst of ComponentInstantiation;
  relate  comp_def to app across R426 using comp_inst;
  select one comp_def_file related by comp_def->File[R401];
  ::addFileToImports( file:file, file_to_import:comp_def_file, type:ImportType::IMPL );
  select any executor related by app->ApplicationExecutor[R4027]; // single executor for now
  relate executor to comp_inst across R4028;
  if ( not_empty current_comp_inst )
    relate comp_inst to current_comp_inst across R4029.''follows'';
    comp_inst.index = current_comp_inst.index + 1;
  else
    comp_inst.index = 0;
  end if;

  // apply instance loading
  select one c_c_pe related by c_c->PE_PE[R8001];
  select any inst_loading_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                              selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                              selected.feature_name == "InstanceLoading" );
  if (not_empty inst_loading_mark)
    comp_inst.instance_loading = inst_loading_mark.value;
    ::addStringToImports( file:file, s:comp_inst.comp_package + "." + comp_inst.comp_name + inst_loading_mark.value + "Loader", type:ImportType::IMPL );
  end if;

  select any sim_time_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                          selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                          selected.feature_name == "EnableSimulatedTime" );
  if (not_empty sim_time_mark)
    LOG::LogInfo(message:"Enabling simulated time for componenent: " + comp_inst.comp_name);
    comp_inst.simulated_time = true;
  end if;

  current_comp_inst = comp_inst;
end for;

// transform satisfactions
select many c_sfs related by root_package->PE_PE[R8000]->C_SF[R8001];
for each c_sf in c_sfs
  ::transformSatisfaction( c_sf:c_sf );
end for;

// create the import block
if ( app.async )
  ::addStringToImports( file:file, s:"java.io.File", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.io.IOException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.lang.reflect.InvocationTargetException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.lang.reflect.Method", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.util.Scanner", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"org.json.JSONObject", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.tasks.ReceivedMessageTask", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.IPort", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.Message", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.util.CommandLine", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.instanceloading.IChangeLog", type:ImportType::IMPL );
else
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.tasks.HaltExecutionTask", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.tasks.GenericExecutionTask", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.util.Arrays", type:ImportType::IMPL );
end if;
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.ApplicationExecutor", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.IApplication", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.ILogger", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.components.IComponent", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("0740d1ad-fda7-4447-9a0f-169201702f1b",
	"db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	'root_package',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9939c670-a721-4742-a824-ed4b0df4acd6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Package>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Element Packaging/Element Packaging.xtuml');
INSERT INTO S_SPARM
	VALUES ("5fd77cf9-a065-41bd-bc15-10904bbc96dc",
	"db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"0740d1ad-fda7-4447-9a0f-169201702f1b",
	'');
INSERT INTO PE_PE
	VALUES ("db8d2223-e46f-4bec-9094-0c4cf2a6ff7a",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	"00000000-0000-0000-0000-000000000000",
	'transformAssociation',
	'',
	'r_rel = param.r_rel;
containing_comp_def = param.containing_comp_def;
select one file related by containing_comp_def->File[R401];

// get exclude mark
select one pe related by r_rel->PE_PE[R8001];
select any assoc_exclude_mark from instances of Mark where ( selected.markable_name == "Association" and
                                                             selected.path == ::containerMarkingPath( pe:pe ) + "::R" + STRING::itoa( i:r_rel.Numb ) and
                                                             selected.feature_name == "Exclude" );
if ( empty assoc_exclude_mark )
  form_phrase = "";
  select any form_class from instances of Class where false;
  form_mult = Mult::ONE;
  part_mult = Mult::ONE;
  form_cond = Cond::UNCONDITIONAL;
  part_phrase = "";
  select any part_class from instances of Class where false;
  part_cond = Cond::UNCONDITIONAL;

  // create the relationsip subtype
  select one r_simp related by r_rel->R_SIMP[R206];
  if ( not_empty r_simp )

    // If there is no R_FORM and the multiplicity of both is ONE, one is chosen arbitrarily to be the formalizer
    select one r_form related by r_simp->R_FORM[R208];
    select one form_class related by r_form->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class )
      select any r_part related by r_simp->R_PART[R207];
      select one part_class related by r_part->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
      if ( not_empty part_class )
        form_phrase = r_form.Txt_Phrs;
        part_phrase = r_part.Txt_Phrs;
        if ( 0 != r_form.Mult )
          form_mult = Mult::MANY;
        end if;
        if ( 0 != r_part.Mult )
          part_mult = Mult::MANY;
        end if;
        if ( 0 != r_form.Cond )
          form_cond = Cond::CONDITIONAL;
        end if;
        if ( 0 != r_part.Cond )
          part_cond = Cond::CONDITIONAL;
        end if;
      else
        // TODO bad
      end if;
    else
      select any r_part1 related by r_simp->R_PART[R207] where ( selected.Mult == 0 );
      if ( empty r_part1 )
        select any r_part1 related by r_simp->R_PART[R207]; // for many to many unformalized, select one randomly
      end if;
      if ( not_empty r_part1 )
        select one part_class related by r_part1->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
        select any r_part2 related by r_simp->R_PART[R207] where ( selected.OIR_ID != r_part1.OIR_ID );
        select one form_class related by r_part2->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
        if ( not_empty form_class and not_empty part_class )
          form_phrase = r_part2.Txt_Phrs;
          part_phrase = r_part1.Txt_Phrs;
          if ( 0 != r_part2.Mult )
            form_mult = Mult::MANY;
          end if;
          if ( 0 != r_part1.Mult )
            part_mult = Mult::MANY;
          end if;
          if ( 0 != r_part2.Cond )
            form_cond = Cond::CONDITIONAL;
          end if;
          if ( 0 != r_part1.Cond )
            part_cond = Cond::CONDITIONAL;
          end if;
        else
          // TODO bad
        end if;
      else
        // TODO bad unformalized many to many binary associations not supported
      end if;
    end if;

    // create the relationship
    create object instance rel of Relationship;
    name = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name = name + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name = name + part_class.name;
    rel.name = name;
    rel.num = r_rel.Numb;
    rel.form_phrase = form_phrase;
    rel.part_phrase = part_phrase;
    rel.form_mult = form_mult;
    rel.part_mult = part_mult;
    rel.form_cond = form_cond;
    rel.part_cond = part_cond;
    relate rel to containing_comp_def across R448;
    relate rel to form_class across R435;
    relate rel to part_class across R434;

    select any o_id related by r_simp->R_PART[R207]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id )
      rel.id_num = o_id.Oid_ID + 1;
    else
      rel.id_num = 0;
    end if;

  else
  select one r_subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty r_subsup )

    select one part_class related by r_subsup->R_SUPER[R212]->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    select many sub_classes related by r_subsup->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty part_class and not_empty sub_classes )
      part_phrase = "is_a";
      for each form_class in sub_classes

        form_phrase = "is_a";
        form_cond = Cond::CONDITIONAL;

        // create the relationship
        create object instance rel of Relationship;
        name = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
        if ( "" != part_phrase )
          name = name + part_phrase + "_";
        end if;
        name = name + part_class.name;
        rel.name = name;
        rel.num = r_rel.Numb;
        rel.form_phrase = form_phrase;
        rel.part_phrase = part_phrase;
        rel.form_mult = form_mult;
        rel.part_mult = part_mult;
        rel.form_cond = form_cond;
        rel.part_cond = part_cond;
        relate rel to containing_comp_def across R448;
        relate rel to form_class across R435;
        relate rel to part_class across R434;
        
        select one o_id related by r_subsup->R_SUPER[R212]->R_RTO[R204]->O_ID[R109];
        if ( not_empty o_id )
          rel.id_num = o_id.Oid_ID + 1;
        else
          rel.id_num = 0;
        end if;

        // special case for EP_PKG instances... top level packages do not have a PE_PE instance
        if ( 8001 == rel.num and "EP_PKG" == rel.form_name )
          LOG::LogInfo( message:"  Special casing R8001 EP_PKG to PackageableElement" );
          rel.part_cond = Cond::CONDITIONAL;
        end if;

      end for;
    else
      // TODO bad
    end if;

  else
  select one r_assoc related by r_rel->R_ASSOC[R206];
  if ( not_empty r_assoc )

    select one r_assr related by r_assoc->R_ASSR[R211];
    select one r_aone related by r_assoc->R_AONE[R209];
    select one r_aoth related by r_assoc->R_AOTH[R210];

    select one form_class related by r_assr->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    select one part_class related by r_aone->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class and not_empty part_class and not_empty r_aoth )
      form_phrase = r_aoth.Txt_Phrs;
      part_phrase = r_aone.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aoth.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aoth.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the first relationship
    create object instance rel1 of Relationship;
    name1 = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name1 = name1 + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name1 = name1 + part_class.name;
    rel1.name = name1;
    rel1.num = r_rel.Numb;
    rel1.form_phrase = form_phrase;
    rel1.part_phrase = part_phrase;
    rel1.form_mult = form_mult;
    rel1.part_mult = part_mult;
    rel1.form_cond = form_cond;
    rel1.part_cond = part_cond;
    relate rel1 to containing_comp_def across R448;
    relate rel1 to form_class across R435;
    relate rel1 to part_class across R434;

    select one o_id1 related by r_assoc->R_AONE[R209]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id1 )
      rel1.id_num = o_id1.Oid_ID + 1;
    else
      rel1.id_num = 0;
    end if;

    form_phrase = "";
    form_mult = Mult::ONE;
    form_cond = Cond::UNCONDITIONAL;
    part_phrase = "";
    part_cond = Cond::UNCONDITIONAL;

    select one part_class related by r_aoth->R_RTO[R204]->R_OIR[R203]->O_OBJ[R201]->Class[R409];
    if ( not_empty form_class and not_empty part_class and not_empty r_aone )
      form_phrase = r_aone.Txt_Phrs;
      part_phrase = r_aoth.Txt_Phrs;
      if ( 0 != r_assr.Mult or 0 != r_aone.Mult )
        form_mult = Mult::MANY;
      end if;
      if ( 0 != r_aone.Cond )
        form_cond = Cond::CONDITIONAL;
      end if;
    else
      // TODO bad
    end if;

    // create the second relationship
    create object instance rel2 of Relationship;
    name2 = "R" + STRING::itoa( i:r_rel.Numb ) + "_" + form_class.name + "_";
    if ( "" != part_phrase )
      name2 = name2 + T::sub( format:"_", s:part_phrase ) + "_";
    end if;
    name2 = name2 + part_class.name;
    rel2.name = name2;
    rel2.num = r_rel.Numb;
    rel2.form_phrase = form_phrase;
    rel2.part_phrase = part_phrase;
    rel2.form_mult = form_mult;
    rel2.part_mult = part_mult;
    rel2.form_cond = form_cond;
    rel2.part_cond = part_cond;
    relate rel2 to containing_comp_def across R448;
    relate rel2 to form_class across R435;
    relate rel2 to part_class across R434;

    select one o_id2 related by r_assoc->R_AOTH[R210]->R_RTO[R204]->O_ID[R109];
    if ( not_empty o_id2 )
      rel2.id_num = o_id2.Oid_ID + 1;
    else
      rel2.id_num = 0;
    end if;

  else
    // TODO bad
  end if; end if; end if;

  // add necessary imports
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.RelationshipSet", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.Relationship", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.IRelationshipSet", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.ModelIntegrityException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("67b6f3bc-1eec-46d8-9fa9-401c41fbaccc",
	"562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	'r_rel',
	"4480b008-8c74-4f57-9256-08b7365520bc",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4480b008-8c74-4f57-9256-08b7365520bc",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Association>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Association/Association.xtuml');
INSERT INTO S_SPARM
	VALUES ("556c2a0f-e7fa-4a1e-9bd2-69b7279362d6",
	"562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"67b6f3bc-1eec-46d8-9fa9-401c41fbaccc",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("109e90cb-1d66-46ee-88db-a568044879d0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO PE_PE
	VALUES ("562178d0-24c9-4c87-b3f3-6e3e8c68106e",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bf960a33-3c3c-4839-89d3-7979cebc4f42",
	"00000000-0000-0000-0000-000000000000",
	'transformAttribute',
	'',
	'o_attr = param.o_attr;
obj = param.obj;

// create the attribute
create object instance attr of Attribute;
select one rattr related by o_attr->O_RATTR[R106];
if ( not_empty rattr )
  attr.name = "ref_" + o_attr.Name;
else
  attr.name = "m_" + o_attr.Name;
end if;
attr.base_name = o_attr.Name;
attr.order = param.index;
attr.default_value = "";
relate attr to obj across R410;

// set part of identifier
attr.identifier = 0;
select many inst_ids related by o_attr->O_ID[R105];
for each inst_id in inst_ids
  if ( inst_id.Oid_ID == 0 )   attr.identifier = attr.identifier + 1;
  elif ( inst_id.Oid_ID == 1 ) attr.identifier = attr.identifier + 2;
  elif ( inst_id.Oid_ID == 2 ) attr.identifier = attr.identifier + 4;
  end if;
end for;

// set the type
select one s_dt related by o_attr->S_DT[R114];
if ( "same_as<Base_Attribute>" == s_dt.Name )
  select one s_dt related by o_attr->O_RATTR[R106]->O_BATTR[R113]->O_ATTR[R106]->S_DT[R114];
end if;
if ( empty s_dt )
  // TODO bad
end if;
select many s_dims related by o_attr->S_DIM[R120];
type = TypeReference::getInstance(s_dt:s_dt, s_dims:s_dims);
select one array_type related by type->ArrayTypeReference[R3801];
relate type to attr across R424;

// set default value for unique id attributes
if ( "UniqueId" == type.type_name )
  attr.default_value = "UniqueId.random()";
end if;

// link OOA attribute
relate o_attr to attr across R414;

// create accessors
create object instance getter of AttributeAccessor;
getter.accessor_type = AttributeAccessorType::GETTER;
relate getter to attr across R4510;
create object instance setter of AttributeAccessor;
setter.accessor_type = AttributeAccessorType::SETTER;
relate setter to attr across R4510;

// transform derivation
select one o_dbattr related by o_attr->O_BATTR[R106]->O_DBATTR[R107];
if ( not_empty o_dbattr )
  create object instance deriv of AttributeDerivation;
  relate deriv to getter across R441;
  // create invocable
  create object instance invocable of InvocableObject;
  invocable.name = attr.name;
  invocable.parent_name = attr.class_name;
  invocable.parent_package = attr.class_package;
  relate deriv to invocable across R427;
  invocable.oal = o_dbattr.Action_Semantics_internal;
  // link type
  relate type to invocable across R428;
  // relate the body
  select one act_act related by o_dbattr->ACT_DAB[R693]->ACT_ACT[R698];
  if ( not_empty act_act )
    relate act_act to invocable across R432;
  end if;
end if;

// add import to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"io.ciera.runtime.instanceloading.AttributeChangedDelta", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );
if (not_empty array_type)
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.ArrayUtil", type:ImportType::IMPL );
elif ("String" == type.type_name and "" == type.type_package)
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.StringUtil", type:ImportType::IMPL );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("2e5a2176-6827-4c1c-94d2-f9b580870e77",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'o_attr',
	"579b8247-e153-481d-8926-384cdc722464",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("579b8247-e153-481d-8926-384cdc722464",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Attribute>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("60f99308-e7f2-4418-9f3c-a851d15b500e",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"2e5a2176-6827-4c1c-94d2-f9b580870e77",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a519e323-b117-4a03-9435-b88e56c2443d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Inst>',
	'',
	'',
	'../architecture/classes/classes.xtuml');
INSERT INTO S_SPARM
	VALUES ("fc68f878-a11f-4847-b767-3532e44408f6",
	"bf960a33-3c3c-4839-89d3-7979cebc4f42",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"60f99308-e7f2-4418-9f3c-a851d15b500e",
	'');
INSERT INTO PE_PE
	VALUES ("bf960a33-3c3c-4839-89d3-7979cebc4f42",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ea25865c-d822-4d1f-b995-3569c5175acf",
	"00000000-0000-0000-0000-000000000000",
	'transformAttributeReferences',
	'',
	'obj = param.obj;
select many attrs related by obj->Attribute[R410];
for each attr in attrs
  select many o_refs related by attr->O_ATTR[R414]->O_RATTR[R106]->O_REF[R108];
  for each o_ref in o_refs
    select one r_rel related by o_ref->O_RTIDA[R111]->R_RTO[R110]->R_OIR[R203]->R_REL[R201];
    select one referred_to_attr related by o_ref->O_RTIDA[R111]->O_OIDA[R110]->O_ATTR[R105]->Attribute[R414];
    select one referred_to_obj related by referred_to_attr->Class[R410];
    referred_to_phrase = ::oirGetPhrase( r_oir_id:o_ref.ROIR_ID );
    phrase = ::oirGetPhrase( r_oir_id:o_ref.OIR_ID );
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == obj.name and
                                                                   selected.part_name == referred_to_obj.name and
                                                                   ( selected.form_phrase == phrase or selected.part_phrase == referred_to_phrase ) );

    // create attribute reference
    create object instance attr_ref of AttributeReference;
    relate attr to referred_to_attr across R4506.''has value provided by'' using attr_ref;
    relate relationship to attr_ref across R4511;
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("399ecf70-c1df-4c59-8264-ed04cfd415ac",
	"ea25865c-d822-4d1f-b995-3569c5175acf",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ea25865c-d822-4d1f-b995-3569c5175acf",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ed7a4352-3f59-49f9-8726-fe8b6e7b65a1",
	"00000000-0000-0000-0000-000000000000",
	'transformBuiltinTypes',
	'',
	'select many s_dts from instances of S_DT;
for each s_dt in s_dts

  if ( ::s_dtIsBuiltin( s_dt:s_dt ) )

    type_name = "";
    type_package = "";
    type_primitive = false;
    type_unique = false;
    type_inst = false;
    type_instset = false;
    type_default_value = "";
    if ( "boolean" == s_dt.Name )
      type_name = "boolean";
      type_primitive = true;
      type_default_value = "false";
    elif ( "component_ref" == s_dt.Name )
      type_name = "IComponent";
      type_package = "io.ciera.runtime.summit.components";
      type_default_value = "null";
    elif ( "date" == s_dt.Name )
      type_name = "Date";
      type_package = "io.ciera.runtime.summit.types";
      type_default_value = "new Date()";
    elif ( "inst<Event>" == s_dt.Name )
      type_name = "EventHandle";
      type_package = "io.ciera.runtime.summit.statemachine";
      type_default_value = "new EventHandle()";
    elif ( "inst_ref<Timer>" == s_dt.Name )
      type_name = "TimerHandle";
      type_package = "io.ciera.runtime.summit.time";
      type_default_value = "new TimerHandle()";
    elif ( "integer" == s_dt.Name )
      type_name = "int";
      type_primitive = true;
      type_default_value = "0";
    elif ( "real" == s_dt.Name )
      type_name = "double";
      type_primitive = true;
      type_default_value = "0d";
    elif ( "string" == s_dt.Name )
      type_name = "String";
      type_package = "";
      type_default_value = STRING::quote() + STRING::quote();
    elif ( "timestamp" == s_dt.Name )
      type_name = "long";
      type_primitive = true;
      type_default_value = "0L";
    elif ( "unique_id" == s_dt.Name )
      type_name = "UniqueId";
      type_package = "io.ciera.runtime.summit.types";
      type_unique = true;
      type_default_value = "new UniqueId()";
    elif ( "void" == s_dt.Name )
      type_name = "void";
      type_primitive = true;
      type_default_value = "";
    elif ( "inst_ref_set<Object>" == s_dt.Name )
      type_name = "IInstanceSet";
      type_package = "io.ciera.runtime.summit.classes";
      type_instset = true;
      type_default_value = "null";
    elif ( "inst_ref<Object>" == s_dt.Name )
      type_name = "IModelInstance";
      type_package = "io.ciera.runtime.summit.classes";
      type_inst = true;
      type_default_value = "null";
    elif ( "inst_ref<Mapping>" == s_dt.Name ) // TODO
      type_name = "InstRefMapping";
      type_package = "io.ciera.runtime.summit.types";
      type_default_value = "null";
    elif ( "inst<Mapping>" == s_dt.Name ) // TODO
      type_name = "InstMapping";
      type_package = "io.ciera.runtime.summit.types";
      type_default_value = "null";
    end if;

    if ( "" != type_name )
      create object instance type of Type;
      type.name = type_name;
      type.package = type_package;
      type.default_value = type_default_value;
      type.resolve( s_dt:s_dt );
      create object instance builtin of BuiltInType;
      relate builtin to type across R407;
      builtin.primitive = type_primitive;
      builtin.unique = type_unique;
      builtin.inst = type_inst;
      builtin.instset = type_instset;
    end if;

  end if;

end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("ed7a4352-3f59-49f9-8726-fe8b6e7b65a1",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("39485529-37f5-43d9-bbd1-92027e9dd6d6",
	"00000000-0000-0000-0000-000000000000",
	'transformClass',
	'',
	'o_obj = param.o_obj;
containing_comp_def = param.containing_comp_def;
path = param.path;
select one ep_pkg related by o_obj->PE_PE[R8001]->EP_PKG[R8000];

// get exclude mark
select one pe related by o_obj->PE_PE[R8001];
select any class_exclude_mark from instances of Mark where ( selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
                                                            selected.feature_name == "Exclude" );
if ( empty class_exclude_mark )
  // get mark for naming
  select any class_name_mark from instances of Mark where ( selected.markable_name == "Model Class" and
                                                            selected.path == ::containerMarkingPath( pe:pe ) + "::" + o_obj.Name and
                                                            selected.feature_name == "UseKeyLettersForName" );
  // create the object file
  create object instance file of File;
  if ( empty class_name_mark )
    file.name = ::camelCaseName( name:o_obj.Name, start_lower:false );
  else
    file.name = o_obj.Key_Lett;
  end if;
  file.path = path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the object
  create object instance obj of Class;
  relate obj to file across R401;
  obj.key_letters = o_obj.Key_Lett;
  obj.extends = "ModelInstance<" + obj.name + "," + containing_comp_def.name + ">";

  // add the class to the component
  relate obj to containing_comp_def across R408;

  // create the instance type
  create object instance type of Type;
  type.name = obj.name;
  type.package = obj.package;
  select any s_irdt related by o_obj->S_IRDT[R123] where ( not selected.isSet );
  select one s_dt related by s_irdt->S_DT[R17];
  if ( not_empty s_dt )
    type.resolve( s_dt:s_dt );
  else
    // TODO bad
  end if;
  type.default_value = obj.name + "Impl.EMPTY_" + T::sub( format:"_u", s:obj.name );
  relate type to obj across R407;

  // relate to the OOA class
  relate obj to o_obj across R409;

  // transform attributes
  select any o_attr related by o_obj->O_ATTR[R102];
  select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  while ( not_empty prev_attr )
    o_attr = prev_attr;
    select one prev_attr related by o_attr->O_ATTR[R103.''succeeds''];
  end while;
  index = 0;
  while ( not_empty o_attr )
    if ( "current_state" != o_attr.Name )
      ::transformAttribute( o_attr:o_attr, obj:obj, index:index );
      index = index + 1;
    end if;
    select one o_attr related by o_attr->O_ATTR[R103.''precedes''];
  end while;

  // transform operations
  select many o_tfrs related by o_obj->O_TFR[R115];
  for each o_tfr in o_tfrs
    ::transformOperation( o_tfr:o_tfr, obj:obj );
  end for;
  
  // transform the state machine
  select one sm related by o_obj->SM_ISM[R518]->SM_SM[R517];
  if ( not_empty sm )
    ::transformStateMachine( sm_sm:sm, obj:obj );
    ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
    ::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.IEvent", type:ImportType::IMPL );
    select any evt related by obj->StateMachine[R4750]->Event[R4752];
    if ( not_empty evt )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.Event", type:ImportType::IMPL );
    end if;
  end if;

  // transform the set object
  ::transformClassSet( obj:obj, ep_pkg:ep_pkg, path:path );

  // add to the containing component imports
  select one component_file related by containing_comp_def->File[R401];
  select one set_file related by obj->ClassSet[R406]->File[R401];
  ::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );
  ::addFileToImports( file:component_file, file_to_import:set_file, type:ImportType::IMPL );
  ::addStringToImports( file:component_file, s: ::pathToPackage( path:file.path ) + ".impl." + file.name + "Impl", type:ImportType::IMPL );
  ::addStringToImports( file:component_file, s: ::pathToPackage( path:set_file.path ) + ".impl." + set_file.name + "Impl", type:ImportType::IMPL );
  ::addStringToImports( file:component_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );

  // create the import block
  ::addFileToImports( file:file, file_to_import:component_file, type:ImportType::BOTH );

  ::addFileToImports( file:file, file_to_import:file, type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.IRunContext", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.InstanceIdentifier", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.IInstanceIdentifier", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.IModelInstance", type:ImportType::INT );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.ModelInstance", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.InstancePopulationException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IWhere", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IXtumlType", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.UniqueId", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.instanceloading.InstanceCreatedDelta", type:ImportType::IMPL );
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("78d79a4b-aa7c-4f92-8c2b-c122c556f1af",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'o_obj',
	"63f4ff99-f127-443b-a678-30ace41da702",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("63f4ff99-f127-443b-a678-30ace41da702",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Model Class>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("96e1d0a0-83fa-41e1-8dd7-e063f484c257",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"78d79a4b-aa7c-4f92-8c2b-c122c556f1af",
	'');
INSERT INTO S_SPARM
	VALUES ("c865d293-ea6c-4aea-b9f2-d168c5534554",
	"39485529-37f5-43d9-bbd1-92027e9dd6d6",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"96e1d0a0-83fa-41e1-8dd7-e063f484c257",
	'');
INSERT INTO PE_PE
	VALUES ("39485529-37f5-43d9-bbd1-92027e9dd6d6",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8bc831e7-b772-4237-b2a5-e423d381379b",
	"00000000-0000-0000-0000-000000000000",
	'transformClassSet',
	'',
	'obj = param.obj;

// create the object file
create object instance file of File;
file.name = obj.name + "Set";
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the class set object
create object instance objset of ClassSet;
relate objset to obj across R406;
relate objset to file across R401;
objset.extends = "InstanceSet<" + objset.name + "," + obj.name + ">";
objset.comparator = "";

// set the comparator
select any comparator_mark from instances of Mark where ( selected.markable_name == "*" and selected.path == "*" and selected.feature_name == "SortComparator" );
if ( not_empty comparator_mark )
  select many attr_accessors related by objset->Class[R406]->Attribute[R410]->AttributeAccessor[R4510] where ( selected.accessor_type == AttributeAccessorType::GETTER );
  for each attr_accessor in attr_accessors
    if ( attr_accessor.getName() == comparator_mark.value )
      objset.comparator = comparator_mark.value;
      break;
    end if;
  end for;
end if;

// create the instance type
create object instance type of Type;
type.name = objset.name;
type.package = objset.package;
select any s_irdt related by obj->O_OBJ[R409]->S_IRDT[R123] where ( selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( not_empty s_dt )
  type.resolve( s_dt:s_dt );
else
  // TODO bad
end if;
type.default_value = "new " + objset.name + "Impl()";
relate type to objset across R407;

// create the import block
select one objfile related by obj->File[R401];
::addFileToImports( file:file, file_to_import:file, type: ImportType::IMPL );
::addFileToImports( file:file, file_to_import:objfile, type: ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.Arrays", type:ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.Comparator", type:ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.List", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.InstanceSet", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.IInstanceSet", type:ImportType::INT );

select any attr related by objset->Class[R406]->Attribute[R410];
if ( not_empty attr )
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("8ed3e4d3-66bd-4a27-bbd4-8ed9c0496aa7",
	"8bc831e7-b772-4237-b2a5-e423d381379b",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a3108481-ac1e-4978-b55f-e7904a2b234b",
	"8bc831e7-b772-4237-b2a5-e423d381379b",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"8ed3e4d3-66bd-4a27-bbd4-8ed9c0496aa7",
	'');
INSERT INTO S_SPARM
	VALUES ("78e96da2-cc85-4688-aa2e-24323899ec51",
	"8bc831e7-b772-4237-b2a5-e423d381379b",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a3108481-ac1e-4978-b55f-e7904a2b234b",
	'');
INSERT INTO PE_PE
	VALUES ("8bc831e7-b772-4237-b2a5-e423d381379b",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	"00000000-0000-0000-0000-000000000000",
	'transformComponentDefinition',
	'',
	'c_c = param.c_c;

if ( 1 == param.pass )

  // create the file
  create object instance file of File;
  file.name = ::camelCaseName( name:c_c.Name, start_lower:false );
  file.path = param.path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the component definition object
  create object instance comp_def of ComponentDefinition;
  relate comp_def to file across R401;
  comp_def.extends = "Component<" + comp_def.name + ">";
  relate c_c to comp_def across R4573;
  comp_def.version = "";
  comp_def.version_date = "";
  
  // set version information
  component_version = "";
  select one c_c_pe related by c_c->PE_PE[R8001];
  select any version_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                                  selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                                  selected.feature_name == "Version" );
  if ( not_empty version_mark )
    component_version = version_mark.value;
 else
    ciera = CIERA::getDefaultInstance();
    component_version = ciera.version;
  end if;
  if ("" != component_version)
    comp_def.version = component_version;
    current_date = TIM::current_date();
    year_string = STRING::itoa( i:TIM::get_year( date:current_date ) );
    month_string = STRING::itoa( i:TIM::get_month( date:current_date ) );
    if ( STRING::strlen( s:month_string ) < 2 )
      month_string = "0" + month_string;
    end if;
    day_string = STRING::itoa( i:TIM::get_day( date:current_date ) );
    if ( STRING::strlen( s:day_string ) < 2 )
      day_string = "0" + day_string;
    end if;
    hour_string = STRING::itoa( i:TIM::get_hour( date:current_date ) );
    if ( STRING::strlen( s:hour_string ) < 2 )
      hour_string = "0" + hour_string;
    end if;
    minute_string = STRING::itoa( i:TIM::get_minute( date:current_date ) );
    if ( STRING::strlen( s:minute_string ) < 2 )
      minute_string = "0" + minute_string;
    end if;
    second_string = STRING::itoa( i:TIM::get_second( date:current_date ) );
    if ( STRING::strlen( s:second_string ) < 2 )
      second_string = "0" + second_string;
    end if;
    comp_def.version_date = year_string + "-" + month_string + "-" + day_string + " " + hour_string + ":" + minute_string + ":" + second_string;
  end if;

  // transform ports
  select many c_pos related by c_c->C_PO[R4010];
  for each c_po in c_pos
    ::transformPort( c_po:c_po, comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ) );
  end for;

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:param.pass );
  end for;

  // transform inner components
  select many inner_c_cs related by c_c->PE_PE[R8003]->C_C[R8001];
  for each inner_c_c in inner_c_cs
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:1 );
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:2 );
    ::transformComponentDefinition( c_c:inner_c_c, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:3 );
  end for;

  // transform instance population selectors
  select many objs related by comp_def->Class[R408];
  for each obj in objs
    create object instance inst_pop_selector of InstancePopulationSelector;
    inst_pop_selector.name = obj.name + "_instances";
    relate inst_pop_selector to comp_def across R447;
    relate inst_pop_selector to obj across R449;
  end for;
  
  if ("" != component_version)
    // create version file
    create object instance prop_file of File;
    prop_file.name = file.name + "Properties";
    prop_file.path = file.path;
    prop_file.package = file.package;
    prop_file.extension = ".properties";
    prop_file.exclude = false;
    create object instance gen_file of GeneralFile;
    relate gen_file to prop_file across R401;
    comp_def.render_version();
    gen_file.contents = T::body();
    T::clear();
  end if;
  
  // create import block
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.IApplication", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.application.IRunContext", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.components.Component", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.classes.IModelInstance", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );

  ::addStringToImports( file:file, s:"java.util.Map", type:ImportType::IMPL );
  ::addStringToImports( file:file, s:"java.util.TreeMap", type:ImportType::IMPL );
  
  if ("" != component_version)
    ::addStringToImports( file:file, s:"java.io.IOException", type:ImportType::IMPL );
    ::addStringToImports( file:file, s:"java.util.Properties", type:ImportType::IMPL );
  end if;

elif ( 2 == param.pass )

  select any file from instances of File where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) and selected.package == ::pathToPackage( path:param.path ) );
  select one comp_def related by file->ComponentDefinition[R401];

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:param.pass );
  end for;

else

  select any file from instances of File where ( selected.name == ::camelCaseName( name:c_c.Name, start_lower:false ) and selected.package == ::pathToPackage( path:param.path ) );
  select one comp_def related by file->ComponentDefinition[R401];

  // transform inner packages
  select many ep_pkgs related by c_c->PE_PE[R8003]->EP_PKG[R8001];
  for each ep_pkg in ep_pkgs
    ::transformPackage( ep_pkg:ep_pkg, containing_comp_def:comp_def, path:file.path + "/" + T::sub( format:"l", s:c_c.Name ), pass:param.pass );
  end for;

  // transform relationship population selectors
  select many rels related by comp_def->Relationship[R448];
  for each rel in rels
    create object instance rel_pop_selector of RelationshipPopulationSelector;
    rel_pop_selector.name = rel.name + "s";
    relate rel_pop_selector to comp_def across R4571;
    relate rel_pop_selector to rel across R4572;
  end for;
  
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("ebb9b275-e504-4702-b6d7-9e3d0c1b097f",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'c_c',
	"67f93d18-1045-4c6c-b0d5-a692023c471c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("67f93d18-1045-4c6c-b0d5-a692023c471c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("e3aed8de-e794-4e78-a0d2-4a887930b499",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"ebb9b275-e504-4702-b6d7-9e3d0c1b097f",
	'');
INSERT INTO S_SPARM
	VALUES ("f5644135-5f9c-4d77-8ad3-1ff0d224ed6b",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"e3aed8de-e794-4e78-a0d2-4a887930b499",
	'');
INSERT INTO S_SPARM
	VALUES ("0d391156-81cc-4fd9-8306-5d01a455c493",
	"a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"f5644135-5f9c-4d77-8ad3-1ff0d224ed6b",
	'');
INSERT INTO PE_PE
	VALUES ("a7bd05ac-267a-4a86-9304-9ad3a75f22b5",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a114d22b-91d1-4024-bd80-b10fccabec0f",
	"00000000-0000-0000-0000-000000000000",
	'transformEnumeratedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = type.name + ".UNINITIALIZED_ENUM";
type.resolve( s_dt:s_dt );
create object instance edt of EnumeratedType;
relate type to edt across R407;
relate edt to file across R401;

// transform enumerators
select any enumer related by s_dt->S_EDT[R17]->S_ENUM[R27];
select one prev_enumer related by enumer->S_ENUM[R56.''succeeds''];
while ( not_empty prev_enumer )
  enumer = prev_enumer;
  select one prev_enumer related by enumer->S_ENUM[R56.''succeeds''];
end while;
value = 0;
while ( not_empty enumer )
  create object instance e of Enumerator;
  e.name = T::sub( format:"u", s:enumer.Name );
  e.value = value;
  value = value + 1;
  relate e to edt across R415;
  select one enumer related by enumer->S_ENUM[R56.''precedes''];
end while;

// add to imports
::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IXtumlType", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.regex.Pattern", type:ImportType::IMPL );
::addStringToImports( file:file, s:"java.util.regex.Matcher", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("52ce9b0d-3a5e-4b00-a118-31e4fea357d2",
	"a114d22b-91d1-4024-bd80-b10fccabec0f",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Data Type>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("a114d22b-91d1-4024-bd80-b10fccabec0f",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("343165b5-e8e6-4162-90f5-1e68da66120f",
	"00000000-0000-0000-0000-000000000000",
	'transformEvent',
	'',
	'sm_evt = param.sm_evt;
sm = param.sm;
id = param.id;

// create event
create object instance evt of Event;
relate evt to sm across R4752;
evt.id = id;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = T::sub( format:"_", s:sm_evt.Mning );
invocable.parent_name = sm.name;
invocable.parent_package = sm.package;
relate evt to invocable across R427;
invocable.oal = "";

// link type
type = TypeReference::getBuiltinTypeReference( name:"void" );
relate type to invocable across R428;

// create parameters
select any sm_evtdi related by sm_evt->SM_EVTDI[R532];
prev_sm_evtdi = sm_evtdi;
// select first parameter
while ( not_empty prev_sm_evtdi )
  sm_evtdi = prev_sm_evtdi;
  select one prev_sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''succeeds''];
end while;
while ( not_empty sm_evtdi )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + sm_evtdi.Name;
  parm.by_ref = false;
  select one parm_dt related by sm_evtdi->S_DT[R524];
  select many s_dims related by sm_evtdi->S_DIM[R531];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one sm_evtdi related by sm_evtdi->SM_EVTDI[R533.''precedes''];
end while;

// link to ooa event
relate evt to sm_evt across R4759;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("493c7cbb-1d0d-4b72-bd54-0fbecbccce06",
	"343165b5-e8e6-4162-90f5-1e68da66120f",
	'sm_evt',
	"33eebb24-8068-410b-a905-37c4e5cc2fdb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("33eebb24-8068-410b-a905-37c4e5cc2fdb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine Event>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("16f2d993-8ce0-4bcc-8a98-d09fbf34d15e",
	"343165b5-e8e6-4162-90f5-1e68da66120f",
	'sm',
	"e26cd508-1f72-4f47-bc3a-f80c2afd819a",
	0,
	'',
	"493c7cbb-1d0d-4b72-bd54-0fbecbccce06",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e26cd508-1f72-4f47-bc3a-f80c2afd819a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../architecture/statemachine/statemachine.xtuml');
INSERT INTO S_SPARM
	VALUES ("f8130cfc-0034-4512-b4d2-5c8c6d629280",
	"343165b5-e8e6-4162-90f5-1e68da66120f",
	'id',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"16f2d993-8ce0-4bcc-8a98-d09fbf34d15e",
	'');
INSERT INTO PE_PE
	VALUES ("343165b5-e8e6-4162-90f5-1e68da66120f",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3775f12f-f551-4b87-b37b-bcdae037314c",
	"00000000-0000-0000-0000-000000000000",
	'transformFunction',
	'',
	's_sync = param.s_sync;
comp_def = param.comp_def;

// create function object
create object instance func of Function;
relate func to comp_def across R405;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_sync.Name;
invocable.parent_name = comp_def.name;
invocable.parent_package = comp_def.package;
relate func to invocable across R427;
invocable.oal = s_sync.Action_Semantics_internal;

// link type
select one s_dt related by s_sync->S_DT[R25];
select many s_dims related by s_sync->S_DIM[R51];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any s_sparm related by s_sync->S_SPARM[R24];
prev_s_sparm = s_sparm;
// select first parameter
while ( not_empty prev_s_sparm )
  s_sparm = prev_s_sparm;
  select one prev_s_sparm related by s_sparm->S_SPARM[R54.''succeeds''];
end while;
while ( not_empty s_sparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_sparm.Name;
  parm.by_ref = ( 1 == s_sparm.By_Ref );
  select one parm_dt related by s_sparm->S_DT[R26];
  select many s_dims related by s_sparm->S_DIM[R52];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_sparm related by s_sparm->S_SPARM[R54.''precedes''];
end while;

// see if this is an initializer function
select one c_c related by comp_def->C_C[R4573];
select one c_c_pe related by c_c->PE_PE[R8001];
select any init_function_mark from instances of Mark where ( selected.markable_name == "Component" and
                                                             selected.path == ::containerMarkingPath( pe:c_c_pe ) + "::" + c_c.Name and
                                                             selected.feature_name == "InitFunction" );
if ( not_empty init_function_mark and func.name == init_function_mark.value )
  select any s_sparm related by s_sync->S_SPARM[R24];
  if ( empty s_sparm )
    select one init_function related by comp_def->Function[R4561];
    if ( empty init_function )
      relate func to comp_def across R4561;
    else
      // TODO bad
    end if;
  else
    // TODO bad
  end if;
end if;

// relate the body
select one act_act related by s_sync->ACT_FNB[R695]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("0276ebf3-d52f-404b-96b5-6b47740fee58",
	"3775f12f-f551-4b87-b37b-bcdae037314c",
	's_sync',
	"60690409-5a69-45db-896b-5a63a9103c18",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60690409-5a69-45db-896b-5a63a9103c18",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("572dad4b-a620-48cf-ade7-fd0b6514a723",
	"3775f12f-f551-4b87-b37b-bcdae037314c",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"0276ebf3-d52f-404b-96b5-6b47740fee58",
	'');
INSERT INTO PE_PE
	VALUES ("3775f12f-f551-4b87-b37b-bcdae037314c",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("194b8d45-3d39-4bab-ba2c-c3f10ade50d6",
	"00000000-0000-0000-0000-000000000000",
	'transformInstanceReferenceTypes',
	'',
	'// make sure an instance reference type is created for every class
select many o_objs from instances of O_OBJ;
for each o_obj in o_objs
  select one packageableElem related by o_obj->PE_PE[R8001];
  select one pkg related by packageableElem->EP_PKG[R8000];

  // Make sure the IRDTs don''t already exist before creating new ones.  Check
  // the single and set version and create whatever does not exist.
  select any existing_irdt related by o_obj->S_IRDT[R123] where selected.isSet == false;
  if (empty existing_irdt)
    create object instance pe of PE_PE;
    relate pe to pkg across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt of S_DT;
    relate pe to dt across R8001;
    create object instance irdt of S_IRDT;
    irdt.isSet = false;
    relate dt to irdt across R17;
    dt.Name = "inst_ref<" + o_obj.Name + ">" ;
    relate o_obj to irdt across R123;
  end if;

  select any existing_irdt_set related by o_obj->S_IRDT[R123] where selected.isSet == true;
  if (empty existing_irdt_set)
    create object instance pe of PE_PE;
    relate pe to pkg across R8000;
    pe.Visibility = Visibility::Public;
    pe.type = ElementTypeConstants::DATATYPE;
    create object instance dt2 of S_DT;
    relate pe to dt2 across R8001;
    create object instance irsdt of S_IRDT;
    irsdt.isSet = true;
    relate irsdt to dt2 across R17;
    dt2.Name = "inst_ref_set<" + o_obj.Name + ">" ;
    relate o_obj to irsdt across R123;
  end if;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO PE_PE
	VALUES ("194b8d45-3d39-4bab-ba2c-c3f10ade50d6",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f8603c94-90cc-4b20-9c6e-f665ce733d20",
	"00000000-0000-0000-0000-000000000000",
	'transformInterface',
	'',
	'c_i = param.c_i;
select one iface related by c_i->Interface[R421];
if ( empty iface )

  // create the file
  create object instance file of File;
  file.name = "I" + ::camelCaseName( name:c_i.Name, start_lower:false );
  file.path = param.path;
  file.package = ::pathToPackage( path:file.path );
  file.extension = ".java";
  file.exclude = false;

  // create the interface package object
  create object instance iface of Interface;
  relate iface to file across R401;

  // relate to the c_i
  relate iface to c_i across R421;

  // transform messages
  // sort by name to assure consistent translation
  select many c_eps related by c_i->C_EP[R4003];
  index = 1;
  for each c_ep in c_eps
    ::transformMessage( c_ep:c_ep, iface:iface, index:index );
    index = index + 1;
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("9fda5ab1-f5ea-49cf-a065-4acac8ccbb18",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'c_i',
	"80698720-cc57-44ba-8aa5-600c524db338",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("80698720-cc57-44ba-8aa5-600c524db338",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Interface>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("3d1e527a-9091-4e1b-a000-daf06870359d",
	"f8603c94-90cc-4b20-9c6e-f665ce733d20",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"9fda5ab1-f5ea-49cf-a065-4acac8ccbb18",
	'');
INSERT INTO PE_PE
	VALUES ("f8603c94-90cc-4b20-9c6e-f665ce733d20",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	"00000000-0000-0000-0000-000000000000",
	'transformMessage',
	'',
	'c_ep = param.c_ep;
iface = param.iface;
index = param.index;
select one c_as related by c_ep->C_AS[R4004];
select one c_io related by c_ep->C_IO[R4004];

if ( not_empty c_as )  // TODO currently only support signals

// create message object
create object instance msg of Message;
msg.name = c_ep.Name;
msg.to_provider = true;
msg.id = index;
if ( not_empty c_as )
  msg.to_provider = ( c_as.Direction == IFDirectionType::ClientServer );
elif ( not_empty c_io )
  msg.to_provider = ( c_io.Direction == IFDirectionType::ClientServer );
end if;
relate msg to iface across R419;

end if;

select one file related by iface->File[R401];
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.Message", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("5e4ab653-700e-40a0-a9bf-dafd8ca2a598",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'c_ep',
	"5441230d-b4d6-495f-9e87-84acf5819d26",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5441230d-b4d6-495f-9e87-84acf5819d26",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Executable Property>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("7ac5a473-81e4-4e54-83d2-4d8ab8cf5711",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'iface',
	"003d869d-0580-4a1f-b1c8-e1657cc0248c",
	0,
	'',
	"5e4ab653-700e-40a0-a9bf-dafd8ca2a598",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("003d869d-0580-4a1f-b1c8-e1657cc0248c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Iface>',
	'',
	'',
	'../architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("7dc75e7c-1b93-4967-9fd1-e4a9d973edce",
	"2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	'index',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"7ac5a473-81e4-4e54-83d2-4d8ab8cf5711",
	'');
INSERT INTO PE_PE
	VALUES ("2ecf0cc9-3779-4c01-93d7-ec971834a5f2",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("74257fe5-db1d-468b-b7b2-b0405455e5ac",
	"00000000-0000-0000-0000-000000000000",
	'transformOperation',
	'',
	'o_tfr = param.o_tfr;
obj = param.obj;

// create operation object
create object instance op of Operation;
op.is_class_based = Scope::Class == o_tfr.Instance_Based;
relate op to obj across R416;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = o_tfr.Name;
invocable.parent_name = op.class_name;
invocable.parent_package = op.class_package;
relate op to invocable across R427;
invocable.oal = o_tfr.Action_Semantics_internal;

// link type
select one s_dt related by o_tfr->S_DT[R116];
select many s_dims related by o_tfr->S_DIM[R122];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any o_tparm related by o_tfr->O_TPARM[R117];
prev_o_tparm = o_tparm;
// select first parameter
while ( not_empty prev_o_tparm )
  o_tparm = prev_o_tparm;
  select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
end while;
while ( not_empty o_tparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + o_tparm.Name;
  parm.by_ref = ( 1 == o_tparm.By_Ref );
  select one parm_dt related by o_tparm->S_DT[R118];
  select many s_dims related by o_tparm->S_DIM[R121];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
end while;

// relate the body
select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
end if;

// add imports
select one class_file related by obj->File[R401];
::addStringToImports( file:class_file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );
if ( op.is_class_based )
  ::addStringToImports( file:class_file, s:"io.ciera.runtime.summit.application.ActionHome", type:ImportType::IMPL );
end if;
::addStringToImports( file:class_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH );

// if this is an optional deferred operation, create a second operation for the supertype implementation
select one o_def related by o_tfr->O_DEF[R126];
if (not_empty o_def and o_def.required == 1)

  // create operation object
  create object instance op of Operation;
  op.is_class_based = Scope::Class == o_tfr.Instance_Based;
  relate op to obj across R416;
  
  // create invocable
  create object instance invocable of InvocableObject;
  invocable.name = "_supertype_" + o_tfr.Name;
  invocable.parent_name = op.class_name;
  invocable.parent_package = op.class_package;
  relate op to invocable across R427;
  invocable.oal = o_tfr.Action_Semantics_internal;
  
  // link type
  select one s_dt related by o_tfr->S_DT[R116];
  select many s_dims related by o_tfr->S_DIM[R122];
  type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
  relate type to invocable across R428;
  
  // create parameters
  select any o_tparm related by o_tfr->O_TPARM[R117];
  prev_o_tparm = o_tparm;
  // select first parameter
  while ( not_empty prev_o_tparm )
    o_tparm = prev_o_tparm;
    select one prev_o_tparm related by o_tparm->O_TPARM[R124.''succeeds''];
  end while;
  while ( not_empty o_tparm )
    // create parameter
    create object instance parm of FormalParameter;
    parm.name = "p_" + o_tparm.Name;
    parm.by_ref = ( 1 == o_tparm.By_Ref );
    select one parm_dt related by o_tparm->S_DT[R118];
    select many s_dims related by o_tparm->S_DIM[R121];
    parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
    relate parm_type to parm across R431;
    ::linkParameter( invocable:invocable, parameter:parm );
    select one o_tparm related by o_tparm->O_TPARM[R124.''precedes''];
  end while;
  
  // relate the body
  select one act_act related by o_tfr->ACT_OPB[R696]->ACT_ACT[R698];
  if ( not_empty act_act )
    relate act_act to invocable across R432;
  end if;
  
  // add imports
  select one class_file related by obj->File[R401];
  ::addStringToImports( file:class_file, s:"io.ciera.runtime.summit.exceptions.EmptyInstanceException", type:ImportType::IMPL );
  if ( op.is_class_based )
    ::addStringToImports( file:class_file, s:"io.ciera.runtime.summit.application.ActionHome", type:ImportType::IMPL );
  end if;

// if this is an required deferred operation with no body (unparsed), create an empty body
// so that the deferral will get created correctly
elif (not_empty o_def and o_def.required == 0 and empty act_act)
  create object instance act_act of ACT_ACT;
  create object instance act_opb of ACT_OPB;
  relate act_act to act_opb across R698;
  relate act_opb to o_tfr across R696;
  relate act_act to invocable across R432;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("33e8c652-ca5f-4d36-a0c9-f60ddeef159e",
	"74257fe5-db1d-468b-b7b2-b0405455e5ac",
	'o_tfr',
	"5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5cb6d426-f094-4cad-8cdb-b16506c9f2e6",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("870faa2c-f3c4-4326-b164-18a2f8a53d80",
	"74257fe5-db1d-468b-b7b2-b0405455e5ac",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"33e8c652-ca5f-4d36-a0c9-f60ddeef159e",
	'');
INSERT INTO PE_PE
	VALUES ("74257fe5-db1d-468b-b7b2-b0405455e5ac",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11092e02-9199-4c08-81fd-85b4884f4d66",
	"00000000-0000-0000-0000-000000000000",
	'transformPackage',
	'',
	'ep_pkg = param.ep_pkg;
path = param.path;

if ( 1 == param.pass )

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform functions
  select many s_syncs related by pe_pes->S_SYNC[R8001];
  for each s_sync in s_syncs
    ::transformFunction( s_sync:s_sync, comp_def:containing_comp_def );
  end for;

  // transform constants

  // transform datatypes
  select many edts related by pe_pes->S_DT[R8001]->S_EDT[R17]->S_DT[R17];
  for each edt in edts
    ::transformEnumeratedType( s_dt:edt );
  end for;
  
  select many udts related by pe_pes->S_DT[R8001]->S_UDT[R17]->S_DT[R17];
  for each udt in udts
    ::transformUserDefinedType( s_dt:udt );
  end for;

  // transform EEs
  select many s_ees related by pe_pes->S_EE[R8001];
  for each s_ee in s_ees
    ::transformUtility( s_ee:s_ee, ep_pkg:ep_pkg, containing_comp_def:containing_comp_def, exclude:false, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ) );
  end for;

  // transform classes
  select many o_objs related by pe_pes->O_OBJ[R8001];
  for each o_obj in o_objs
    ::transformClass( o_obj:o_obj, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ) );
  end for;

  // transform components
  select many c_cs related by pe_pes->C_C[R8001];
  for each c_c in c_cs
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:1 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:2 );
    ::transformComponentDefinition( c_c:c_c, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:3 );
  end for;
  
  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:param.pass );
  end for;

elif ( 2 == param.pass )

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform associations
  select many r_rels related by pe_pes->R_REL[R8001];
  for each r_rel in r_rels
    ::transformAssociation( r_rel:r_rel, containing_comp_def:containing_comp_def );
  end for;

  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:param.pass );
  end for;
  
else

  // see if this is a package reference
  select one referred_ep_pkg related by ep_pkg->EP_PKG[R1402.''refers to''];
  if ( not_empty referred_ep_pkg )
    ep_pkg = referred_ep_pkg;
  end if;
  containing_comp_def = param.containing_comp_def;
  select many pe_pes related by ep_pkg->PE_PE[R8000];

  // transform selectors
  select many o_objs related by pe_pes->O_OBJ[R8001];
  select many objs related by o_objs->Class[R409];
  for each obj in objs
    ::transformSelectors( obj:obj );
  end for;

  // transform attribute references
  select many o_objs related by pe_pes->O_OBJ[R8001];
  select many objs related by o_objs->Class[R409];
  for each obj in objs
    ::transformAttributeReferences( obj:obj );
  end for;

  // transform packages
  select many inner_ep_pkgs related by pe_pes->EP_PKG[R8001];
  for each inner_ep_pkg in inner_ep_pkgs
    ::transformPackage( ep_pkg:inner_ep_pkg, containing_comp_def:containing_comp_def, path:path + "/" + T::sub( format:"rl", s:ep_pkg.Name ), pass:param.pass );
  end for;

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("75df983d-83b9-42ea-87dc-411170ddf3df",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("912f8c19-5d8d-4eb7-be1a-89c22e6e2dc6",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"75df983d-83b9-42ea-87dc-411170ddf3df",
	'');
INSERT INTO S_SPARM
	VALUES ("2bd3da6f-20bb-4a2e-9598-1051478b2655",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"912f8c19-5d8d-4eb7-be1a-89c22e6e2dc6",
	'');
INSERT INTO S_SPARM
	VALUES ("65ed5781-bcb1-45ed-8c9c-db97c8db733b",
	"11092e02-9199-4c08-81fd-85b4884f4d66",
	'pass',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"2bd3da6f-20bb-4a2e-9598-1051478b2655",
	'');
INSERT INTO PE_PE
	VALUES ("11092e02-9199-4c08-81fd-85b4884f4d66",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("dc54cc56-f3a1-40ce-9622-5b72536da732",
	"00000000-0000-0000-0000-000000000000",
	'transformPort',
	'',
	'c_po = param.c_po;
comp_def = param.comp_def;
select one c_c related by c_po->C_C[R4010];
select one pe related by c_c->PE_PE[R8001];

// create the file
create object instance file of File;
file.name = comp_def.name + ::camelCaseName( name:c_po.Name, start_lower:false );
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the interface package object
create object instance port of Port;
relate port to file across R401;
relate port to c_po across R422;
port.port_name = ::camelCaseName( name:c_po.Name, start_lower:false );

// set base class
select any base_class_mark from instances of Mark where ( selected.markable_name == "Port" and
                                                          selected.path == ::containerMarkingPath( pe:pe ) + "::" + c_c.Name + "::" + c_po.Name and
                                                          selected.feature_name == "BaseClass" );
if ( not_empty base_class_mark )
  port.base_class = base_class_mark.value;
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces." + base_class_mark.value, type:ImportType::IMPL );
else
  port.base_class = "Port";
  ::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.Port", type:ImportType::IMPL );
end if;

// set port as provider or requirer
select any c_p related by c_po->C_IR[R4016]->C_P[R4009];
port.provider = not_empty c_p;

// relate to other component
relate port to comp_def across R417;

// relate to iface if the iface is there
select any c_i related by c_po->C_IR[R4016]->C_I[R4012];
select one iface related by c_i->Interface[R421];
if ( empty iface and not_empty c_i )
  select one ep_pkg related by c_i->PE_PE[R8001]->EP_PKG[R8000];
  if ( not_empty ep_pkg )
    ::transformInterface( c_i:c_i, path: ::ep_pkgToPath( ep_pkg:ep_pkg ) );
  end if;
  select one iface related by c_i->Interface[R421];
end if;
if ( not_empty iface )
  relate port to iface across R418;
  select many msgs related by iface->Message[R419];
  for each msg in msgs
    ::transformPortMessage( port:port, msg:msg );
  end for;
  select one iface_file related by iface->File[R401];
  ::addFileToImports( file:file, file_to_import:iface_file, type:ImportType::IMPL );
else
  // TODO bad
end if;

// add to component file
select one component_file related by comp_def->File[R401];
::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );

// add imports
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.BadArgumentException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.IMessage", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.interfaces.IPort", type:ImportType::IMPL );
::addFileToImports( file:file, file_to_import:component_file, type:ImportType::IMPL );
select one iface_file related by iface->File[R401];
::addFileToImports( file:file, file_to_import:iface_file, type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("d90ff16c-7b5a-4cfc-bd1f-cb7f61a8f5ea",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'c_po',
	"7956bd81-f6de-4bc8-9851-92214668ced1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("7956bd81-f6de-4bc8-9851-92214668ced1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO S_SPARM
	VALUES ("2416fad3-aefa-4b39-be26-3377fa98d171",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"d90ff16c-7b5a-4cfc-bd1f-cb7f61a8f5ea",
	'');
INSERT INTO S_SPARM
	VALUES ("5ca8d895-7b79-4c44-b608-ee46576c1d51",
	"dc54cc56-f3a1-40ce-9622-5b72536da732",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2416fad3-aefa-4b39-be26-3377fa98d171",
	'');
INSERT INTO PE_PE
	VALUES ("dc54cc56-f3a1-40ce-9622-5b72536da732",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	"00000000-0000-0000-0000-000000000000",
	'transformPortMessage',
	'',
	'port = param.port;
msg = param.msg;
select one file related by port->File[R401];

select any c_ep related by msg->Interface[R419]->C_I[R421]->C_EP[R4003] where ( selected.Name == msg.name );
select one c_po related by port->C_PO[R422];

// create port message
create object instance port_msg of PortMessage;
relate port to msg across R420 using port_msg;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = msg.name;
invocable.parent_name = port.name;
invocable.parent_package = port.package;
relate port_msg to invocable across R427;

// populate the OAL
invocable.oal = "";
select any act_act from instances of ACT_ACT where false;
select any spr_rep related by c_po->C_IR[R4016]->C_R[R4009]->SPR_REP[R4500] where ( selected.ExecutableProperty_Id == c_ep.Id );
select one spr_ro related by spr_rep->SPR_RO[R4502];
if ( not_empty spr_ro )
  invocable.oal = spr_ro.Action_Semantics_internal;
  select one act_act related by spr_ro->ACT_ROB[R685]->ACT_ACT[R698];
else
  select one spr_rs related by spr_rep->SPR_RS[R4502];
  if ( not_empty spr_rs )
    invocable.oal = spr_rs.Action_Semantics_internal;
    select one act_act related by spr_rs->ACT_RSB[R684]->ACT_ACT[R698];
  else
    select any spr_pep related by c_po->C_IR[R4016]->C_P[R4009]->SPR_PEP[R4501] where ( selected.ExecutableProperty_Id == c_ep.Id );
    select one spr_po related by spr_pep->SPR_PO[R4503];
    if ( not_empty spr_po )
      invocable.oal = spr_po.Action_Semantics_internal;
      select one act_act related by spr_po->ACT_POB[R687]->ACT_ACT[R698];
    else
      select one spr_ps related by spr_pep->SPR_PS[R4503];
      if ( not_empty spr_ps )
        invocable.oal = spr_ps.Action_Semantics_internal;
        select one act_act related by spr_ps->ACT_PSB[R686]->ACT_ACT[R698];
      end if;
    end if;
  end if;
end if;

// link type
type = TypeReference::getBuiltinTypeReference( name:"void" );
relate type to invocable across R428;

// create parameters
select any c_pp related by c_ep->C_PP[R4006];
prev_c_pp = c_pp;
// select first parameter
while ( not_empty prev_c_pp )
  c_pp = prev_c_pp;
  select one prev_c_pp related by c_pp->C_PP[R4021.''succeeds''];
end while;
while ( not_empty c_pp )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + c_pp.Name;
  parm.by_ref = ( 1 == c_pp.By_Ref );
  select one parm_dt related by c_pp->S_DT[R4007];
  select many s_dims related by c_pp->S_DIM[R4017];
  parm_type_ref = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type_ref to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one c_pp related by c_pp->C_PP[R4021.''precedes''];
  if ((msg.to_provider and port.provider) or (not msg.to_provider and not port.provider))
    if ( "boolean" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.BooleanUtil", type:ImportType::IMPL );
    elif ( "int" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IntegerUtil", type:ImportType::IMPL );
    elif ( "double" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.RealUtil", type:ImportType::IMPL );
    elif ( "String" == parm_type_ref.type_name )
      ::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.StringUtil", type:ImportType::IMPL );
    else
      select one parm_type related by parm_type_ref->Type[R3800];
      ::addTypeToImports( file:file, type_to_import:parm_type, type:ImportType::IMPL );
    end if;
  end if;
end while;

// relate the body
if ( not_empty act_act )
  relate act_act to invocable across R432;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4a996a1b-1671-4519-b30e-8e417f450dd9",
	"41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	'port',
	"d29fe14e-2574-4613-ac57-716ebd8e905c",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d29fe14e-2574-4613-ac57-716ebd8e905c",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Port>',
	'',
	'',
	'../architecture/interfaces/interfaces.xtuml');
INSERT INTO S_SPARM
	VALUES ("eeeff60a-c20e-402e-9400-be4d292ac084",
	"41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	'msg',
	"af93d414-e2e8-430c-b266-a77360256015",
	0,
	'',
	"4a996a1b-1671-4519-b30e-8e417f450dd9",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("af93d414-e2e8-430c-b266-a77360256015",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Message>',
	'',
	'',
	'../architecture/interfaces/interfaces.xtuml');
INSERT INTO PE_PE
	VALUES ("41a2caee-c0d7-4723-8aaf-5b7aec8462ab",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0e170f43-da9c-4938-b403-530f03b013de",
	"00000000-0000-0000-0000-000000000000",
	'transformSatisfaction',
	'',
	'c_sf = param.c_sf;

select one provider related by c_sf->C_P[R4002]->C_IR[R4009]->C_PO[R4016]->Port[R422];
select one requirer related by c_sf->C_R[R4002]->C_IR[R4009]->C_PO[R4016]->Port[R422];

relate provider to requirer across R4160.''satisfies required'';',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("df6caa72-bba2-4448-8b3a-3f9cc54d18ea",
	"0e170f43-da9c-4938-b403-530f03b013de",
	'c_sf',
	"cb87cce2-556b-41ae-85e4-d8813981c372",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cb87cce2-556b-41ae-85e4-d8813981c372",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Satisfaction>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Component/Component.xtuml');
INSERT INTO PE_PE
	VALUES ("0e170f43-da9c-4938-b403-530f03b013de",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("70b77a96-efe5-4504-a7c8-6e3b43562e61",
	"00000000-0000-0000-0000-000000000000",
	'transformSelector',
	'',
	'obj = param.obj;
rel = param.rel;
other_obj = param.other_obj;

// This function creates selectors for the class and set for a single path
// through a relationship. For single instances, a selectOne or selectMany
// are created based on multiplicity. For sets, a selectMany and is always
// created.

name = "R" + STRING::itoa( i:rel.num ) + "_";
if ( "" != param.phrase )
  name = name + T::sub( format:"_", s:param.phrase ) + "_";
end if;
name = name + other_obj.name;

// create set selectors
select one obj_set related by obj->ClassSet[R406];

// create ''many'' selector
create object instance sel of Selector;
sel.parent_name = obj_set.name;
sel.parent_package = obj_set.package;
sel.name = name;
sel.multiplicity = param.mult;
relate rel to sel across R4512;
create object instance set_sel of SetSelector;
relate set_sel to sel across R445;
relate set_sel to obj_set across R444;

// link up type
select any set_irdt related by other_obj->O_OBJ[R409]->S_IRDT[R123] where ( selected.isSet );
select one set_dt related by set_irdt->S_DT[R17];
if ( empty set_dt )
  // TODO bad
end if;
select many s_dims from instances of S_DIM where false;
set_type = TypeReference::getInstance( s_dt:set_dt, s_dims:s_dims );
relate set_type to sel across R446;

select any s_irdt related by other_obj->O_OBJ[R409]->S_IRDT[R123] where ( not selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
if ( empty s_dt )
  // TODO bad
end if;
class_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );

// create the instance selectors
if ( Mult::ONE == param.mult )

  // create ''one'' selector
  create object instance sel of Selector;
  sel.parent_name = obj.name;
  sel.parent_package = obj.package;
  sel.name = name;
  sel.multiplicity = param.mult;
  relate rel to sel across R4512;
  create object instance inst_sel of InstanceSelector;
  inst_sel.rel_num = rel.num;
  inst_sel.conditionality = param.cond;
  inst_sel.formalizer = param.formalizer;
  relate inst_sel to sel across R445;
  relate inst_sel to obj across R442;
  relate inst_sel to set_sel across R4505;

  // link up type
  relate class_type to sel across R446;

else

  // create ''many'' selector
  create object instance sel of Selector;
  sel.parent_name = obj.name;
  sel.parent_package = obj.package;
  sel.name = name;
  sel.multiplicity = param.mult;
  relate rel to sel across R4512;
  create object instance inst_sel of InstanceSelector;
  inst_sel.rel_num = rel.num;
  inst_sel.conditionality = param.cond;
  inst_sel.formalizer = param.formalizer;
  relate inst_sel to sel across R445;
  relate inst_sel to obj across R442;
  relate inst_sel to set_sel across R4505;

  // link up type
  relate set_type to sel across R446;

end if;

// add imports to object file
select one file related by obj->File[R401];
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH );
if ( Cond::UNCONDITIONAL == param.cond or Mult::ONE == param.mult )
  //::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.ModelIntegrityException", type:ImportType::IMPL );
end if;
if ( Mult::MANY == param.mult )
  ::addStringToImports( file:file, s:set_type.type_package + ".impl." + set_type.type_name + "Impl", type:ImportType::IMPL );
  select one type related by class_type->Type[R3800];
  ::addTypeToImports( file:file, type_to_import:type, type:ImportType::BOTH );
else
  ::addStringToImports( file:file, s:class_type.type_package + ".impl." + class_type.type_name + "Impl", type:ImportType::IMPL );
end if;

// add imports to object set file
select one set_file related by obj_set->File[R401];
::addStringToImports( file:set_file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::BOTH );
::addStringToImports( file:set_file, s:set_type.type_package + ".impl." + set_type.type_name + "Impl", type:ImportType::IMPL );

// add imports to component file
select one comp_file related by obj->ComponentDefinition[R408]->File[R401];
if ( Mult::MANY != param.mult )
  ::addStringToImports( file:comp_file, s:class_type.type_package + ".impl." + class_type.type_name + "Impl", type:ImportType::IMPL );
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("53761c33-5050-41a9-8717-5b47cf72633a",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("815e671e-49ba-4290-b2a5-e089801f467b",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'rel',
	"b82caf35-37bb-463a-8633-3bf3bb615c43",
	0,
	'',
	"53761c33-5050-41a9-8717-5b47cf72633a",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b82caf35-37bb-463a-8633-3bf3bb615c43",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Class Relationship>',
	'',
	'',
	'../architecture/relationship/relationship.xtuml');
INSERT INTO S_SPARM
	VALUES ("6e16df8f-5ce9-422c-959c-422d3b24c82b",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'cond',
	"0a105e88-c4a7-4782-a19a-822614dc2d54",
	0,
	'',
	"815e671e-49ba-4290-b2a5-e089801f467b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0a105e88-c4a7-4782-a19a-822614dc2d54",
	"00000000-0000-0000-0000-000000000000",
	'Cond',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("6e393a7b-f0f2-4150-ace1-f631db376e7f",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'mult',
	"05a31d0a-15c4-4fe9-84b5-004baff831ec",
	0,
	'',
	"6e16df8f-5ce9-422c-959c-422d3b24c82b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("05a31d0a-15c4-4fe9-84b5-004baff831ec",
	"00000000-0000-0000-0000-000000000000",
	'Mult',
	'',
	'',
	'../types/types.xtuml');
INSERT INTO S_SPARM
	VALUES ("f32b91c5-08fb-40d1-8d14-eee526de6b03",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'other_obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"debd3552-909f-4af3-889f-7ba19518590b",
	'');
INSERT INTO S_SPARM
	VALUES ("f7102e2d-bf92-4885-8331-809899ca54c2",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'formalizer',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"6e393a7b-f0f2-4150-ace1-f631db376e7f",
	'');
INSERT INTO S_SPARM
	VALUES ("debd3552-909f-4af3-889f-7ba19518590b",
	"70b77a96-efe5-4504-a7c8-6e3b43562e61",
	'phrase',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"f7102e2d-bf92-4885-8331-809899ca54c2",
	'');
INSERT INTO PE_PE
	VALUES ("70b77a96-efe5-4504-a7c8-6e3b43562e61",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("f54fc649-5256-4bae-bb5d-c0a1c9a45cd5",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectors',
	'',
	'obj = param.obj;

// transform selectors for associations
// form to part
select many form_to_part_rels related by obj->Relationship[R435];
for each rel in form_to_part_rels
  select one part_obj related by rel->Class[R434];
  ::transformSelector( obj:obj, rel:rel, phrase:rel.part_phrase, cond:rel.part_cond,
                       mult:rel.part_mult, formalizer:true, other_obj:part_obj );
end for;
// part to form
select many part_to_form_rels related by obj->Relationship[R434];
for each rel in part_to_form_rels
  select one form_obj related by rel->Class[R435];
  ::transformSelector( obj:obj, rel:rel, phrase:rel.form_phrase, cond:rel.form_cond,
                       mult:rel.form_mult, formalizer:false, other_obj:form_obj );
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("1bf64a54-abc0-4b9f-9015-8be52c113bef",
	"f54fc649-5256-4bae-bb5d-c0a1c9a45cd5",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("f54fc649-5256-4bae-bb5d-c0a1c9a45cd5",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c04fde8e-f58c-4d2b-87a7-8393b796f271",
	"00000000-0000-0000-0000-000000000000",
	'transformState',
	'',
	'sm_state = param.sm_state;
sm = param.sm;
number = param.number;

// create state
create object instance state of State;
relate state to sm across R4751;
state.final = sm_state.Final == 1;
state.number = number;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = T::sub( format:"_", s:sm_state.Name );
invocable.parent_name = sm.name;
invocable.parent_package = sm.package;
relate state to invocable across R427;
select one sm_act related by sm_state->SM_MOAH[R511]->SM_AH[R513]->SM_ACT[R514];
invocable.oal = sm_act.Action_Semantics_internal;

// relate the body
select one act_act related by sm_act->ACT_SAB[R691]->ACT_ACT[R698];
if ( not_empty act_act )
  relate act_act to invocable across R432;
end if;

// link type
type = TypeReference::getBuiltinTypeReference( name:"void" );
relate type to invocable across R428;

// link to ooa state
relate state to sm_state across R4758;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("e075ca53-4cf3-4ba1-92c2-60e8754317fd",
	"c04fde8e-f58c-4d2b-87a7-8393b796f271",
	'sm_state',
	"ce86dade-b263-4245-8001-19dd4123f4f9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ce86dade-b263-4245-8001-19dd4123f4f9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine State>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("efcf7b2b-956d-4ff6-86b6-769109cbcdbf",
	"c04fde8e-f58c-4d2b-87a7-8393b796f271",
	'sm',
	"e26cd508-1f72-4f47-bc3a-f80c2afd819a",
	0,
	'',
	"e075ca53-4cf3-4ba1-92c2-60e8754317fd",
	'');
INSERT INTO S_SPARM
	VALUES ("813c23ee-1eaa-4107-9c9a-18a32ad8ed0d",
	"c04fde8e-f58c-4d2b-87a7-8393b796f271",
	'number',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"efcf7b2b-956d-4ff6-86b6-769109cbcdbf",
	'');
INSERT INTO PE_PE
	VALUES ("c04fde8e-f58c-4d2b-87a7-8393b796f271",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	"00000000-0000-0000-0000-000000000000",
	'transformStateMachine',
	'',
	'sm_sm = param.sm_sm;
obj = param.obj;

// TODO support polymorphic events

// create the state machine file
create object instance file of File;
file.name = obj.name + "StateMachine";
file.path = ::formatPath( path:obj.package );
file.package = obj.package;
file.extension = ".java";
file.exclude = false;

// create the object
create object instance sm of StateMachine;
relate sm to file across R401;
relate sm to obj across R4750;

// transform the first state (the state with the lowest number must have state id 0)
select many sm_states related by sm_sm->SM_STATE[R501];
select any init_state from instances of SM_STATE where false;
for each sm_state in sm_states
  if ( empty init_state or sm_state.Numb < init_state.Numb )
    init_state = sm_state;
  end if;
end for;
if ( not_empty init_state )
  ::transformState( sm_state:init_state, sm:sm, number:0 );
end if;

// transform the rest of the states
number = 1;
sm_states = sm_states - init_state;
for each sm_state in sm_states
  ::transformState( sm_state:sm_state, sm:sm, number:number );
  number = number + 1;
end for;

// transform events
id = 0;
select many sm_evts related by sm_sm->SM_EVT[R502]->SM_SEVT[R525]->SM_LEVT[R526]->SM_SEVT[R526]->SM_EVT[R525];
for each sm_evt in sm_evts
  ::transformEvent( sm_evt:sm_evt, sm:sm, id:id );
  id = id + 1;
end for;

// transform transition table
select many states related by sm->State[R4751];
for each state in states

  // create a row for this start state
  create object instance row of TransitionTableRow;
  relate row to sm across R4753;
  relate row to state across R4754;
  row.index = state.number;
  
  select many evts related by sm->Event[R4752];
  for each evt in evts
    
    // create a cell for this event
    create object instance cell of TransitionTableCell;
    relate cell to row across R4755;
    relate cell to evt across R4756;
    cell.index = evt.id;
    
    select one sm_state related by state->SM_STATE[R4758];
    select one sm_evt related by evt->SM_EVT[R4759];
    select any sm_seme related by sm_evt->SM_SEVT[R525]->SM_SEME[R503] where ( selected.SMstt_ID == sm_state.SMstt_ID );
    if ( not_empty sm_seme )
      // TODO bad
    end if;
    select one cant_happen related by sm_seme->SM_CH[R504];
    if ( not_empty cant_happen )
      cell.transition_type = TransitionType::CANT_HAPPEN;
    else
      select one event_ignored related by sm_seme->SM_EIGN[R504];
      if ( not_empty event_ignored )
        cell.transition_type = TransitionType::IGNORE;
      else
        // create transition
        create object instance txn of Transition;
        select one sm_txn related by sm_seme->SM_NSTXN[R504]->SM_TXN[R507];
        select one dest_state related by sm_txn->SM_STATE[R506]->State[R4758];
        relate dest_state to cell across R4757 using txn;
        cell.transition_type = TransitionType::TRANSITION;

        // create invocable
        create object instance invocable of InvocableObject;
        invocable.name = state.name + "_txn_" + dest_state.name;
        invocable.parent_name = sm.name;
        invocable.parent_package = sm.package;
        relate txn to invocable across R427;
        select one sm_act related by sm_txn->SM_TAH[R530]->SM_AH[R513]->SM_ACT[R514];
        invocable.oal = sm_act.Action_Semantics_internal;
        
        // relate the body
        select one act_act related by sm_act->ACT_TAB[R688]->ACT_ACT[R698];
        if ( not_empty act_act )
          relate act_act to invocable across R432;
        end if;
        
        // link type
        type = TypeReference::getBuiltinTypeReference( name:"void" );
        relate type to invocable across R428;
      end if;
    end if;

  end for;
  
end for;

// add imports
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.ITransition", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.statemachine.StateMachine", type:ImportType::IMPL );

select one class_file related by obj->File[R401];
select one comp_file related by obj->ComponentDefinition[R408]->File[R401];
::addFileToImports( file:file, file_to_import:class_file, type:ImportType::IMPL );
::addFileToImports( file:file, file_to_import:comp_file, type:ImportType::IMPL );
',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("52462f5f-c541-4d6a-884e-fcfacb4de247",
	"cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	'sm_sm',
	"f6562655-0940-4f4f-a1ae-7094b79949a7",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("f6562655-0940-4f4f-a1ae-7094b79949a7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<State Machine>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/State Machine/State Machine.xtuml');
INSERT INTO S_SPARM
	VALUES ("5f45583f-5aa4-4ba1-a0db-bef2a7a9a239",
	"cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	'obj',
	"a519e323-b117-4a03-9435-b88e56c2443d",
	0,
	'',
	"52462f5f-c541-4d6a-884e-fcfacb4de247",
	'');
INSERT INTO PE_PE
	VALUES ("cb20fa01-e4b7-4d9c-a8aa-ff49e5763228",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d02e7000-869b-4743-9418-85576a503800",
	"00000000-0000-0000-0000-000000000000",
	'transformUserDefinedType',
	'',
	's_dt = param.s_dt;
select one ep_pkg related by s_dt->PE_PE[R8001]->EP_PKG[R8000];

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_dt.Name, start_lower:false );
file.path = ::ep_pkgToPath( ep_pkg:ep_pkg );
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = false;

// create the type
create object instance type of Type;
type.name = file.name;
type.package = file.package;
type.default_value = "new " + type.name + "()";
type.resolve( s_dt:s_dt );
create object instance udt of UserDefinedType;
relate type to udt across R407;
relate udt to file across R401;

// add import
::addStringToImports( file:file, s:"io.ciera.runtime.summit.exceptions.XtumlException", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.types.IXtumlType", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("78c72c79-4b9b-423f-926e-db02292501ed",
	"d02e7000-869b-4743-9418-85576a503800",
	's_dt',
	"4a90cd45-ece0-4e72-afe7-44996f9d7e1e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("d02e7000-869b-4743-9418-85576a503800",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	"00000000-0000-0000-0000-000000000000",
	'transformUtility',
	'',
	's_ee = param.s_ee;
containing_comp_def = param.containing_comp_def;

// create the file
create object instance file of File;
file.name = ::camelCaseName( name:s_ee.Key_Lett, start_lower:false );
file.path = param.path;
file.package = ::pathToPackage( path:file.path );
file.extension = ".java";
file.exclude = param.exclude;

// create the utility object
create object instance utility of Utility;
relate utility to file across R401;

// relate the containing component
if ( not_empty containing_comp_def )
  create object instance util_ref of UtilityReference;
  relate utility to containing_comp_def across R4558 using util_ref;
  select one component_file related by containing_comp_def->File[R401];
  ::addFileToImports( file:component_file, file_to_import:file, type:ImportType::IMPL );
  ::addStringToImports( file:component_file, s: ::pathToPackage( path:file.path ) + ".impl." + file.name + "Impl", type:ImportType::IMPL );
end if;

// transform each utility function
select many s_brgs related by s_ee->S_BRG[R19];
for each s_brg in s_brgs
  ::transformUtilityFunction( s_brg:s_brg, utility:utility );
end for;

// create import block
::addFileToImports( file:file, file_to_import:file, type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.util.Utility", type:ImportType::IMPL );
::addStringToImports( file:file, s:"io.ciera.runtime.summit.components.IComponent", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("4ec862c4-7311-4839-9230-77e6cff9ec1c",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	's_ee',
	"fc04695e-75c8-413e-a409-6dbc6465e011",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("fc04695e-75c8-413e-a409-6dbc6465e011",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<External Entity>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO S_SPARM
	VALUES ("e5acec51-5918-4996-ada8-33baf8c87865",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'containing_comp_def',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	0,
	'',
	"c0d939f0-c1c0-4220-a02c-3bfc91900773",
	'');
INSERT INTO S_SPARM
	VALUES ("5078c5f9-c41e-4561-9c18-464a2137b800",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'exclude',
	"ba5eda7a-def5-0000-0000-000000000001",
	0,
	'',
	"e5acec51-5918-4996-ada8-33baf8c87865",
	'');
INSERT INTO S_SPARM
	VALUES ("c0d939f0-c1c0-4220-a02c-3bfc91900773",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'ep_pkg',
	"9939c670-a721-4742-a824-ed4b0df4acd6",
	0,
	'',
	"4ec862c4-7311-4839-9230-77e6cff9ec1c",
	'');
INSERT INTO S_SPARM
	VALUES ("65c10430-7eed-4271-b373-73fc7b6d5994",
	"13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	'path',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5078c5f9-c41e-4561-9c18-464a2137b800",
	'');
INSERT INTO PE_PE
	VALUES ("13f46372-87b9-41dc-bfd6-c69214ebb3c4",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("7987d2a8-0081-4942-a0f1-09509ae9f755",
	"00000000-0000-0000-0000-000000000000",
	'transformUtilityFunction',
	'',
	's_brg = param.s_brg;
utility = param.utility;

// create utility function object
create object instance util_func of UtilityFunction;
relate util_func to utility across R4559;

// create invocable
create object instance invocable of InvocableObject;
invocable.name = s_brg.Name;
invocable.parent_name = utility.name;
invocable.parent_package = utility.package;
relate util_func to invocable across R427;
invocable.oal = s_brg.Action_Semantics_internal;

// link type
select one s_dt related by s_brg->S_DT[R20];
select many s_dims related by s_brg->S_DIM[R50];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims );
relate type to invocable across R428;

// create parameters
select any s_bparm related by s_brg->S_BPARM[R21];
prev_s_bparm = s_bparm;
// select first parameter
while ( not_empty prev_s_bparm )
  s_bparm = prev_s_bparm;
  select one prev_s_bparm related by s_bparm->S_BPARM[R55.''succeeds''];
end while;
while ( not_empty s_bparm )
  // create parameter
  create object instance parm of FormalParameter;
  parm.name = "p_" + s_bparm.Name;
  parm.by_ref = ( 1 == s_bparm.By_Ref );
  select one parm_dt related by s_bparm->S_DT[R22];
  select many s_dims related by s_bparm->S_DIM[R49];
  parm_type = TypeReference::getInstance( s_dt:parm_dt, s_dims:s_dims );
  relate parm_type to parm across R431;
  ::linkParameter( invocable:invocable, parameter:parm );
  select one s_bparm related by s_bparm->S_BPARM[R55.''precedes''];
end while;

// relate bridge
relate s_brg to util_func across R4570;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0);
INSERT INTO S_SPARM
	VALUES ("42373b64-8fb9-4a71-b28d-d88fab9d5a5e",
	"7987d2a8-0081-4942-a0f1-09509ae9f755",
	'utility',
	"05845c9d-7216-4905-8b60-6bf9f95f42e7",
	0,
	'',
	"4cfc6825-9d26-4a1b-a502-e85f0e527e1f",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("05845c9d-7216-4905-8b60-6bf9f95f42e7",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Utility>',
	'',
	'',
	'../architecture/component/component.xtuml');
INSERT INTO S_SPARM
	VALUES ("4cfc6825-9d26-4a1b-a502-e85f0e527e1f",
	"7987d2a8-0081-4942-a0f1-09509ae9f755",
	's_brg',
	"ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("ecc1ab34-9767-4e8a-82ed-4ab5b2aea2c8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge>',
	'',
	'',
	'../../../../mcooa/models/mcooa/ooaofooa/Domain/Domain.xtuml');
INSERT INTO PE_PE
	VALUES ("7987d2a8-0081-4942-a0f1-09509ae9f755",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	1,
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO S_SYS_PROXY
	VALUES ("9092a4a9-91f5-4e59-984b-3ca72917240d",
	'tool-core',
	1,
	'../tool-core.xtuml');
