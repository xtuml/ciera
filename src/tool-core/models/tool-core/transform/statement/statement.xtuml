-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'statement',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("c1939e8a-8fe3-4cee-9fcb-7fc8e8cc2592",
	112,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.1.17',
	'tool-core::transform::statement');
INSERT INTO DIM_DIA
	VALUES ("c1939e8a-8fe3-4cee-9fcb-7fc8e8cc2592",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO S_SYNC
	VALUES ("f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	"00000000-0000-0000-0000-000000000000",
	'transformBridgeInvocation',
	'',
	'act_brg = param.act_brg;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_brg->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570];
if ( empty util_func )
  select one s_ee related by act_brg->S_BRG[R674]->S_EE[R19];
  select one s_ee_pkg related by s_ee->PE_PE[R8001]->EP_PKG[R8000];
  select any empty_comp_def from instances of ComponentDefinition where false;
  ::transformUtility( s_ee:s_ee, ep_pkg:s_ee_pkg, containing_comp_def:empty_comp_def, exclude:true, path: ::ep_pkgToPath( ep_pkg:s_ee_pkg ) );
  select one util_func related by act_brg->S_BRG[R674]->UtilityFunction[R4570];
end if;
select one invocable related by util_func->InvocableObject[R427];
select one utility related by util_func->Utility[R4559];
select one utility_file related by utility->File[R401];
containing_comp_def = ::getCompDefForStatement( smt:smt );
select one containing_comp_file related by containing_comp_def->File[R401];
::addFileToImports( file:containing_comp_file, file_to_import:utility_file, type:ImportType::IMPL );
::addStringToImports( file:containing_comp_file, s: ::pathToPackage( path:utility_file.path ) + ".impl." + utility_file.name + "Impl", type:ImportType::IMPL );
if ( not_empty containing_comp_def )
  select any util_ref related by utility->UtilityReference[R4558] where ( selected.comp_name == containing_comp_def.name and selected.comp_package == containing_comp_def.package );
  if ( empty util_ref )
    create object instance util_ref of UtilityReference;
    relate utility to containing_comp_def across R4558 using util_ref;
  end if;
end if;
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr2 across R795;
  // create named reference
  create object instance named_ref of NamedReference;
  relate named_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  named_ref.name = "context()." + utility.name + "()";
  // transform actual parameters
  select many v_pars related by act_brg->V_PAR[R628];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("352665b2-b1ca-4679-b298-9ca266aadaf3",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'act_brg',
	"9401259e-aff6-4747-8963-a78cca9bb312",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("9401259e-aff6-4747-8963-a78cca9bb312",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Bridge Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("5495268f-96a0-4daa-ad63-c0a3f6bc7003",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"352665b2-b1ca-4679-b298-9ca266aadaf3",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Code Block>',
	'',
	'',
	'../../architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("d70d90ad-fb70-4874-b173-f7e5961e06e8",
	"f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"5495268f-96a0-4daa-ad63-c0a3f6bc7003",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../architecture/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("f25977aa-02ba-4eb4-b209-5dc798d1aac7",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	"00000000-0000-0000-0000-000000000000",
	'transformFunctionInvocation',
	'',
	'act_fnc = param.act_fnc;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fnc->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select one s_sync related by act_fnc->S_SYNC[R675];
containing_comp_def = ::getCompDefForStatement( smt:smt );
select any invocable related by containing_comp_def->Function[R405]->InvocableObject[R427] where ( selected.name == s_sync.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr2 across R795;
  // create named reference
  create object instance named_ref of NamedReference;
  relate named_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  named_ref.name = "context()";
  // transform actual parameters
  select many v_pars related by act_fnc->V_PAR[R669];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("4b2aafc8-3fec-4b00-b681-6d73ba77aeca",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'act_fnc',
	"86cad241-b50f-4db8-85e7-1f596daa2aaf",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("86cad241-b50f-4db8-85e7-1f596daa2aaf",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Function Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("03a296be-0cc2-4739-aab1-a165c687b305",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"4b2aafc8-3fec-4b00-b681-6d73ba77aeca",
	'');
INSERT INTO S_SPARM
	VALUES ("9376b863-3c08-4a7f-a09d-53af4225082e",
	"abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"03a296be-0cc2-4739-aab1-a165c687b305",
	'');
INSERT INTO PE_PE
	VALUES ("abb5709b-a87d-4b0a-adb9-6e3892c3295d",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("73520fae-d9ee-4105-950f-69fe437a613e",
	"00000000-0000-0000-0000-000000000000",
	'transformOperationInvocation',
	'',
	'act_tfm = param.act_tfm;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_tfm->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select one o_tfr related by act_tfm->O_TFR[R673];
select any invocable related by o_tfr->O_OBJ[R115]->Class[R409]->Operation[R416]->InvocableObject[R427] where ( selected.name == o_tfr.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate eas to expr across R476;
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // relate expression to expression as statement
  select one op_v_var related by act_tfm->V_VAR[R667];
  if ( empty op_v_var ) // class based operation
    // create named reference expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775;
    expr2.expression_number = "1.1";
    relate expr2 to invoc across R798;
    void_type = TypeReference::getBuiltinTypeReference( name:"void" );
    relate void_type to expr2 across R795;
    // create named reference
    create object instance named_ref of NamedReference;
    relate named_ref to expr2 across R776;
    select one target_class related by invocable->Operation[R427]->Class[R416];
    named_ref.name = "new " + target_class.name + "Impl.CLASS(context())";
    select one class_file related by target_class->File[R401];
    ::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
  else // instance based operation
    // create variable reference expression
    create object instance expr2 of Expression;
    relate expr2 to smt across R775;
    expr2.expression_number = "1.1";
    relate expr2 to invoc across R798;
    select one op_s_dt related by op_v_var->S_DT[R848];
    select one op_obj related by o_tfr->O_OBJ[R115];
    op_s_dt = ::getInstRefTypeForClass( s_dt:op_s_dt, o_obj:op_obj );
    select many s_dims related by op_v_var->S_DIM[R849];
    select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
    op_type = TypeReference::getInstance( s_dt:op_s_dt, s_dims:s_dims, referring_comp:referring_comp );
    relate op_type to expr2 across R795;
    select any op_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == op_v_var.Name );
    if ( not_empty op_var ) // cannot declare two variables of the same name in the same scope
      create object instance var_ref of VariableReference;
      relate op_var to var_ref across R782;
      relate var_ref to expr2 across R776;
      select one type related by expr2->TypeReference[R795]->Type[R3800];
      ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
    elif ( "self" == op_v_var.Name )
      // create named reference
      create object instance self_ref of NamedReference;
      relate self_ref to expr2 across R776;
      self_ref.name = "self()";
    else
      // TODO bad
    end if;
  end if;
  // transform actual parameters
  select many v_pars related by act_tfm->V_PAR[R627];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e85eda2c-3c15-4bd7-9595-08b630b7a666",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'act_tfm',
	"c3a0c649-c89b-4f9b-9fdc-719fe83d5949",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c3a0c649-c89b-4f9b-9fdc-719fe83d5949",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Operation Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("ee005cc8-cd28-4b02-a6b8-fb16d32ff8ec",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"e85eda2c-3c15-4bd7-9595-08b630b7a666",
	'');
INSERT INTO S_SPARM
	VALUES ("7aad2443-ee03-4b07-a9a3-d43b7040878e",
	"73520fae-d9ee-4105-950f-69fe437a613e",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"ee005cc8-cd28-4b02-a6b8-fb16d32ff8ec",
	'');
INSERT INTO PE_PE
	VALUES ("73520fae-d9ee-4105-950f-69fe437a613e",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("3e960d0c-6b93-4eb9-b226-4655058ab532",
	"00000000-0000-0000-0000-000000000000",
	'transformSignalInvocation',
	'',
	'act_sgn = param.act_sgn;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_sgn->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select one spr_rs related by act_sgn->SPR_RS[R660];
select one spr_ps related by act_sgn->SPR_PS[R663];
select one c_ep related by spr_rs->SPR_REP[R4502]->C_EP[R4500];
if ( empty c_ep )
  select one c_ep related by spr_ps->SPR_PEP[R4503]->C_EP[R4501];
end if;
select one c_po related by spr_rs->SPR_REP[R4502]->C_R[R4500]->C_IR[R4009]->C_PO[R4016];
if ( empty c_po )
  select one c_po related by spr_ps->SPR_PEP[R4503]->C_P[R4501]->C_IR[R4009]->C_PO[R4016];
end if;
select one target_port related by c_po->Port[R422];
select any invocable related by target_port->PortMessage[R420]->InvocableObject[R427] where ( selected.name == c_ep.Name );
if ( not_empty invocable )
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate eas to expr across R476;
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to expr across R776;
  relate invoc to invocable across R792;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = "1.1";
  relate expr2 to invoc across R798;
  void_type = TypeReference::getBuiltinTypeReference( name:"void" );
  relate void_type to expr2 across R795;
  // create named reference
  create object instance named_ref of NamedReference;
  relate named_ref to expr2 across R776;
  named_ref.name = "context()." + target_port.port_name + "()";
  // transform actual parameters
  select many v_pars related by act_sgn->V_PAR[R662];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:"1", base_num:2 );
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("f1d2c3b8-1e18-4855-a7dc-7517c6460cf0",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'act_sgn',
	"a5d7357e-b251-4e0f-8026-7df3117e656e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a5d7357e-b251-4e0f-8026-7df3117e656e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Signal Invocation>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("0736d699-4c6c-479d-92f5-5867a8d07aa8",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"f1d2c3b8-1e18-4855-a7dc-7517c6460cf0",
	'');
INSERT INTO S_SPARM
	VALUES ("99a75507-8e17-475b-8368-71fa62cd158f",
	"3e960d0c-6b93-4eb9-b226-4655058ab532",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"0736d699-4c6c-479d-92f5-5867a8d07aa8",
	'');
INSERT INTO PE_PE
	VALUES ("3e960d0c-6b93-4eb9-b226-4655058ab532",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("de7e24ef-9847-4033-a108-d402987edf81",
	"00000000-0000-0000-0000-000000000000",
	'transformIfStatement',
	'',
	'act_if = param.act_if;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_if->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select any empty_invocableInComp from instances of InvocableInComponent where false;
// create if statement
create object instance if_smt of IfSmt;
relate if_smt to smt across R451;
if_smt.is_else_if = false;
// translate if expression
select one if_val related by act_if->V_VAL[R625];
::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
select any if_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate if_expr to if_smt across R471;
// create then block
then_block_number = ::getNextBlockNumber( upper_block:block );
select one then_blk related by act_if->ACT_BLK[R607];
::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocableInComp:empty_invocableInComp );
select any then_block related by block->InvocableInComponent[R4000]->CodeBlock[R4000] where ( selected.block_number == then_block_number );
relate then_block to if_smt across R453;
// translate elifs
select many act_els related by act_if->ACT_EL[R682];
select many translated_act_els from instances of ACT_EL where false;
remaining_act_els = act_els - translated_act_els;
while ( not_empty remaining_act_els )
  // get the next elif
  select any act_el from instances of ACT_EL where false;
  for each remaining_act_el in remaining_act_els
    if ( empty act_el )
      act_el = remaining_act_el;
    else
      select one act_el_smt related by act_el->ACT_SMT[R603];
      select one remaining_act_el_smt related by remaining_act_el->ACT_SMT[R603];
      if ( remaining_act_el_smt.LineNumber < act_el_smt.LineNumber or
           remaining_act_el_smt.LineNumber == act_el_smt.LineNumber and remaining_act_el_smt.StartPosition == act_el_smt.StartPosition )
        act_el = remaining_act_el;
      end if;
    end if;
  end for;
  // create block for elif
  elif_block_number = ::getNextBlockNumber( upper_block:block );
  ::transformBlockForElif( upper_block:block, act_el:act_el, block_number:elif_block_number );
  select any else_block related by block->InvocableInComponent[R4000]->CodeBlock[R4000] where ( selected.block_number == elif_block_number );
  relate else_block to if_smt across R454;
  // set the new current block and if statement
  block = else_block;
  select any if_smt related by if_smt->CodeBlock[R454]->Statement[R450]->IfSmt[R451];
  // mark the elif as translated
  translated_act_els = translated_act_els + act_el;
  remaining_act_els = act_els - translated_act_els;
end while;
// create else block
else_block_number = ::getNextBlockNumber( upper_block:block );
select one else_blk related by act_if->ACT_E[R683]->ACT_BLK[R606];
if ( not_empty else_blk )
  ::transformBlock( upper_block:block, act_blk:else_blk, block_number:else_block_number, invocableInComp:empty_invocableInComp );
  select any else_block related by block->InvocableInComponent[R4000]->CodeBlock[R4000] where ( selected.block_number == else_block_number );
  relate else_block to if_smt across R454;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("552c46f9-9d62-416c-85a9-4f3e6a48cf78",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'act_if',
	"bb76d140-b203-4872-8599-9118f0d24469",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bb76d140-b203-4872-8599-9118f0d24469",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<If Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("825e76f0-0e5b-48b5-934d-91e6e2f4b4c3",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"552c46f9-9d62-416c-85a9-4f3e6a48cf78",
	'');
INSERT INTO S_SPARM
	VALUES ("ebe132d9-4995-4f47-a949-e8061a13dc4f",
	"de7e24ef-9847-4033-a108-d402987edf81",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"825e76f0-0e5b-48b5-934d-91e6e2f4b4c3",
	'');
INSERT INTO PE_PE
	VALUES ("de7e24ef-9847-4033-a108-d402987edf81",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("65b5e300-7f3b-4575-850c-ff44c70f27ab",
	"00000000-0000-0000-0000-000000000000",
	'transformWhileStatement',
	'',
	'act_whl = param.act_whl;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_whl->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select any empty_invocableInComp from instances of InvocableInComponent where false;
// create while statement
create object instance while_smt of WhileSmt;
relate while_smt to smt across R451;
// translate while expression
select one while_val related by act_whl->V_VAL[R626];
::transformExpression( v_val:while_val, expr_number:"1", smt:smt );
select any while_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate while_expr to while_smt across R472;
// create control block
control_block_number = ::getNextBlockNumber( upper_block:block );
select one control_blk related by act_whl->ACT_BLK[R608];
::transformBlock( upper_block:block, act_blk:control_blk, block_number:control_block_number, invocableInComp:empty_invocableInComp );
select any control_block related by block->InvocableInComponent[R4000]->
  CodeBlock[R4000] where ( selected.block_number == control_block_number );
relate control_block to while_smt across R456;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2f21f7a6-bc41-4aa5-b407-02b485f9c3a5",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'act_whl',
	"86e01ede-4100-4b04-9d71-5d50a8ab4dd8",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("86e01ede-4100-4b04-9d71-5d50a8ab4dd8",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<While Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("949a2c93-01d1-4d82-9e09-092ac18e3d00",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"2f21f7a6-bc41-4aa5-b407-02b485f9c3a5",
	'');
INSERT INTO S_SPARM
	VALUES ("1450494b-793f-4c98-8b92-762ca3cd9685",
	"65b5e300-7f3b-4575-850c-ff44c70f27ab",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"949a2c93-01d1-4d82-9e09-092ac18e3d00",
	'');
INSERT INTO PE_PE
	VALUES ("65b5e300-7f3b-4575-850c-ff44c70f27ab",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	"00000000-0000-0000-0000-000000000000",
	'transformBreakStatement',
	'',
	'act_brk = param.act_brk;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_brk->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create break statement
create object instance break_smt of BreakSmt;
relate break_smt to smt across R451;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9d2176aa-8350-411d-8089-18be2d55aa4d",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'act_brk',
	"da79315c-1694-40ef-bd42-87a95148b582",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("da79315c-1694-40ef-bd42-87a95148b582",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Break>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("44c502a7-27b2-4b2d-91b9-7e3510f1597f",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"9d2176aa-8350-411d-8089-18be2d55aa4d",
	'');
INSERT INTO S_SPARM
	VALUES ("28b2c872-c56c-4e83-b170-53a736402329",
	"9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"44c502a7-27b2-4b2d-91b9-7e3510f1597f",
	'');
INSERT INTO PE_PE
	VALUES ("9e42f0ed-93eb-4942-aef4-1d8d707a3052",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	"00000000-0000-0000-0000-000000000000",
	'transformContinueStatement',
	'',
	'act_con = param.act_con;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_con->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create continue statement
create object instance continue_smt of ContinueSmt;
relate continue_smt to smt across R451;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e9a9c1cd-e629-4407-b390-05f9637ce18a",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'act_con',
	"d64b7f9b-4188-431e-8dd3-f34c683c0a7a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d64b7f9b-4188-431e-8dd3-f34c683c0a7a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Continue>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("3b25b90e-976a-4f1b-b451-f5b800796a23",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"e9a9c1cd-e629-4407-b390-05f9637ce18a",
	'');
INSERT INTO S_SPARM
	VALUES ("0035ec14-8c30-46d7-91e6-a3fa5ea1771c",
	"5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"3b25b90e-976a-4f1b-b451-f5b800796a23",
	'');
INSERT INTO PE_PE
	VALUES ("5c74c23a-3535-4414-acf9-fcc6e5cbe3d1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5d38219f-e7ec-4d37-920a-526625941452",
	"00000000-0000-0000-0000-000000000000",
	'transformAssignToMember',
	'',
	'act_ai = param.act_ai;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ai->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// If this assignment is assigning an invocation return value to a variable
// that is never read in the body, simply execute the invocation. OAL has
// a limitation in that you cannot invoke bodies that return a value without
// assigning the value to something (even if you do not intend to use it).
// If there is an invocation of T::include anywhere in the body, bail because
// the variable might be referenced in the template.
select one l_val related by act_ai->V_VAL[R689];
select one l_val_dt related by l_val->S_DT[R820];
select one r_val related by act_ai->V_VAL[R609];
select one r_val_dt related by r_val->S_DT[R820];
select one v_var related by l_val->V_TVL[R801]->V_VAR[R805];
if ( empty v_var )
  select one v_var related by l_val->V_IRF[R801]->V_VAR[R808];
  if ( empty v_var )
    select one v_var related by l_val->V_ISR[R801]->V_VAR[R809];
  end if;
end if;
num_references = ::numReferences( v_var:v_var );
select one r_brv related by r_val->V_BRV[R801];
select one r_fnv related by r_val->V_FNV[R801];
select one r_trv related by r_val->V_TRV[R801];
rhs_is_invocation = not_empty r_brv or not_empty r_fnv or not_empty r_trv;
select many s_brgs related by act_ai->ACT_SMT[R603]->ACT_BLK[R602]->ACT_ACT[R601]->ACT_BLK[R601]->ACT_SMT[R602]->ACT_BRG[R603]->S_BRG[R674] where ( selected.Name == "include" );
select any s_ee related by s_brgs->S_EE[R19] where ( selected.Key_Lett == "T" );
if ( empty s_ee and rhs_is_invocation and num_references == 1 )
  // create right operand
  ::transformExpression( v_val:r_val, expr_number:"1", smt:smt );
  select any r_op related by smt->Expression[R775] where ( selected.expression_number == "1" );
  relate r_op to eas across R476;
else
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  relate expr to eas across R476;
  // create binary operation and assignment expression
  create object instance binop of BinaryOperation;
  relate binop to expr across R776;
  binop.operator = "=";
  binop.invocation = false;
  // create left operand
  ::transformExpression( v_val:l_val, expr_number:"1.1", smt:smt );
  select any l_op related by smt->Expression[R775] where ( selected.expression_number == "1.1" );
  relate l_op to binop across R779;
  select one ltype related by l_op->TypeReference[R795];
  // create right operand
  // no type promotion necessary or automatic promotion of integer to real or integer to timestamp
  if l_val_dt == r_val_dt or (l_val_dt.Name == "real" and r_val_dt.Name == "integer") or (l_val_dt.Name == "timestamp" and r_val_dt.Name == "integer")
    ::transformExpression( v_val:r_val, expr_number:"1.2", smt:smt );
  else
    // must do type promotion
    create object instance prom_expr of Expression;
    relate prom_expr to smt across R775;
    prom_expr.expression_number = "1.2";
    relate ltype to prom_expr across R795;
    create object instance prom of Promotion;
    relate prom to prom_expr across R776;
    if ::typeIsBasedOn(type:r_val_dt, parentType:l_val_dt)
      // only a simple cast is required
      prom.cast = true;
    else
      prom.cast = false;
      file = ::getFileForStatement(smt:smt);
      select one l_type related by ltype->Type[R3800];
      ::addTypeToImports(file:file, type_to_import:l_type, type:ImportType::IMPL);
    end if;
    ::transformExpression(v_val:r_val, expr_number:"1.2.1", smt:smt);
    select any prom_val related by smt->Expression[R775] where (selected.expression_number == "1.2.1");
    relate prom_val to prom across R3907;
  end if;
  select any r_op related by smt->Expression[R775] where ( selected.expression_number == "1.2" );
  relate r_op to binop across R778;
  // link l_op type to the main expression
  select one type related by l_op->TypeReference[R795];
  relate type to expr across R795;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1794be11-aeec-48b5-add2-4a1f9da41cb6",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'act_ai',
	"dd812f1d-8408-4547-b6a7-b4647dde5560",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("dd812f1d-8408-4547-b6a7-b4647dde5560",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Assign to Member>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("a07595ec-559e-4c0a-aec7-3d8102508762",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"1794be11-aeec-48b5-add2-4a1f9da41cb6",
	'');
INSERT INTO S_SPARM
	VALUES ("f07f3063-c859-4332-babd-e18233358cba",
	"5d38219f-e7ec-4d37-920a-526625941452",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"a07595ec-559e-4c0a-aec7-3d8102508762",
	'');
INSERT INTO PE_PE
	VALUES ("5d38219f-e7ec-4d37-920a-526625941452",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("72240988-bdbe-4ced-9848-4e72f7fda04e",
	"00000000-0000-0000-0000-000000000000",
	'transformForStatement',
	'',
	'act_for = param.act_for;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_for->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create for statement
create object instance for_smt of ForSmt;
relate for_smt to smt across R451;
// translate iterable expression
select one iterable_v_var related by act_for->V_VAR[R652];
select one iterable_o_obj related by iterable_v_var->V_INS[R814]->O_OBJ[R819];
select any iterable_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == iterable_v_var.Name );
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
select one s_dt related by iterable_v_var->S_DT[R848];
s_dt = ::getInstRefTypeForClass( s_dt:s_dt, o_obj:iterable_o_obj );
select many s_dims related by iterable_v_var->S_DIM[R849];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate type to expr across R795;
create object instance var_ref of VariableReference;
relate iterable_var to var_ref across R782;
relate var_ref to expr across R776;
relate expr to for_smt across R478;
select one expr_type related by expr->TypeReference[R795]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
// create iterator variable
select one iter_v_var related by act_for->V_VAR[R614];
select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == iter_v_var.Name );
if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
  ::transformVariable( v_var:iter_v_var, smt:smt );
end if;
select any iter_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == iter_v_var.Name );
relate iter_var to for_smt across R459;
// link iterator variable type
select one iter_type related by iter_var->TypeReference[R461]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:iter_type, type:ImportType::IMPL );
// create control block
control_block_number = ::getNextBlockNumber( upper_block:block );
select one control_blk related by act_for->ACT_BLK[R605];
::transformBlockForFor( upper_block:block, act_blk:control_blk, block_number:control_block_number, iter_var:iter_var, for_smt:for_smt );
select any control_block related by block->InvocableInComponent[R4000]->
  CodeBlock[R4000] where ( selected.block_number == control_block_number );
relate control_block to for_smt across R455;
for_smt.initializeIterator();
::addStringToImports( file: ::getFileForStatement( smt:smt ), s:"java.util.Iterator", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("baa5eb23-30c7-4592-8bf0-fedf3ad2bc74",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'act_for',
	"5f3e2b9f-0432-4222-bce6-7ac8c9a492e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5f3e2b9f-0432-4222-bce6-7ac8c9a492e2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<For Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("54474ea7-1f74-4740-bd7c-91baa009ca41",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"baa5eb23-30c7-4592-8bf0-fedf3ad2bc74",
	'');
INSERT INTO S_SPARM
	VALUES ("b887d774-52e2-465d-ae0c-0bba3c5df376",
	"72240988-bdbe-4ced-9848-4e72f7fda04e",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"54474ea7-1f74-4740-bd7c-91baa009ca41",
	'');
INSERT INTO PE_PE
	VALUES ("72240988-bdbe-4ced-9848-4e72f7fda04e",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectFromInstances',
	'',
	'act_fio = param.act_fio;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fio->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_fio->V_VAR[R639];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select one select_s_dt related by select_v_var->S_DT[R848];
select one select_obj related by act_fio->O_OBJ[R677];
select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
select many s_dims related by select_v_var->S_DIM[R849];
select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate select_type to l_op across R795;
select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
  ::transformVariable( v_var:select_v_var, smt:smt );
end if;
select any select_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
select one expr_type related by l_op->TypeReference[R795]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:expr_type, type:ImportType::IMPL );
// create right operand
selector = InstancePopulationSelector::get( block:block, o_obj:select_obj );
create object instance r_op of Expression;
relate r_op to smt across R775;
r_op.expression_number = "1.2";
relate r_op to binop across R778;
select any s_irdt related by act_fio->O_OBJ[R677]->S_IRDT[R123] where ( selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
select many s_dims from instances of S_DIM where false;
fio_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate fio_type to r_op across R795;
if ( "any" == act_fio.cardinality ) // create another expression for the ''any''. Note that this is a little tricky because the local var ''r_op'' is being reused
  create object instance any_expr of AnyExpr;
  relate any_expr to r_op across R776;
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2.1";
  relate select_type to r_op across R795;
  relate r_op to any_expr across R783;
end if;
create object instance sel of SelectExpr;
relate sel to r_op across R776;
create object instance sel_fi of SelectFromInstances;
relate sel_fi to sel across R789;
relate selector to sel_fi across R799;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("9c483a34-c551-4b76-9a15-a4ea2d3b36dc",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'act_fio',
	"42f4ea26-5209-40ef-9c07-9e6e6abf7b73",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("42f4ea26-5209-40ef-9c07-9e6e6abf7b73",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select From Instances>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("aec982f2-5bca-4547-aa75-c2c552fe7982",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"9c483a34-c551-4b76-9a15-a4ea2d3b36dc",
	'');
INSERT INTO S_SPARM
	VALUES ("c5cccfd9-6b1f-4daf-9acb-6ac0617cbf7d",
	"0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"aec982f2-5bca-4547-aa75-c2c552fe7982",
	'');
INSERT INTO PE_PE
	VALUES ("0e774dfc-a6b6-437e-93d7-9acb1b252db1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("11c6c837-e285-46ea-a532-2be0c0a19b7a",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectFromInstancesWhere',
	'',
	'act_fiw = param.act_fiw;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_fiw->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_fiw->V_VAR[R665];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select one select_s_dt related by select_v_var->S_DT[R848];
select one select_obj related by act_fiw->O_OBJ[R676];
select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
select many s_dims related by select_v_var->S_DIM[R849];
select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate select_type to l_op across R795;
select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
  ::transformVariable( v_var:select_v_var, smt:smt );
end if;
select any select_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
select one type related by l_op->TypeReference[R795]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
// create right operand
select one where_clause_val related by act_fiw->V_VAL[R610];
select one where_clause_lbo related by where_clause_val->V_LBO[R801];
if ( not_empty where_clause_lbo and ( "false" == T::sub( format:"l", s:where_clause_lbo.Value ) ) ) // special case where the where clause is ''false''
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  create object instance named_expr of NamedReference;
  relate named_expr to r_op across R776;
  select one select_type_def related by select_type->Type[R3800];
  named_expr.name = select_type_def.default_value;
  ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:select_type_def.package + ".impl." + select_type_def.name + "Impl", type:ImportType::IMPL );
else
  selector = InstancePopulationSelector::get( block:block, o_obj:select_obj );
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate select_type to r_op across R795;
  relate r_op to binop across R778;
  create object instance where_expr of WhereExpr;
  relate where_expr to r_op across R776;
  where_expr.multiplicity = act_fiw.cardinality;
  where_expr.sorted = SortType::NONE;
  if ("many" == where_expr.multiplicity)
    cls_set = ClassSet::get( block:block, o_obj:select_obj );
    where_expr.cast = cls_set.name;
  elif ("one" == where_expr.multiplicity)
    select one cls related by select_obj->Class[R409];
    where_expr.cast = cls.name;
  end if;
  // create selection expr
  create object instance sel_expr of Expression;
  relate sel_expr to smt across R775;
  sel_expr.expression_number = "1.2.1";
  select any s_irdt related by act_fiw->O_OBJ[R676]->S_IRDT[R123] where ( selected.isSet );
  select one s_dt related by s_irdt->S_DT[R17];
  select many s_dims from instances of S_DIM where false;
  fiw_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate fiw_type to sel_expr across R795;
  relate sel_expr to where_expr across R790;
  create object instance sel of SelectExpr;
  relate sel to sel_expr across R776;
  create object instance sel_fi of SelectFromInstances;
  relate sel_fi to sel across R789;
  relate selector to sel_fi across R799;
  // transform the where clause condition
  ::transformExpression( v_val:where_clause_val, expr_number:"1.2.2", smt:smt );
  select any where_clause_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2.2" );
  relate where_clause_expr to where_expr across R796;
  ::resolveSortedSelection(where_expr:where_expr);
end if;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("37fd3836-f715-45b7-b4a8-7012c2fb68e0",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'act_fiw',
	"2527a5ea-3890-49e4-9f12-44ef91b2fdab",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2527a5ea-3890-49e4-9f12-44ef91b2fdab",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select From Instances Where>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("f9e20633-3e98-4cbb-8742-1272414935bf",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"37fd3836-f715-45b7-b4a8-7012c2fb68e0",
	'');
INSERT INTO S_SPARM
	VALUES ("cad3d747-4f86-4a0d-a7a8-a4a23a2a5137",
	"11c6c837-e285-46ea-a532-2be0c0a19b7a",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"f9e20633-3e98-4cbb-8742-1272414935bf",
	'');
INSERT INTO PE_PE
	VALUES ("11c6c837-e285-46ea-a532-2be0c0a19b7a",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	"00000000-0000-0000-0000-000000000000",
	'transformSelect',
	'',
	'act_sel = param.act_sel;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_sel->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one select_v_var related by act_sel->V_VAR[R638];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select one select_s_dt related by select_v_var->S_DT[R848];
select one last_lnk related by act_sel->ACT_LNK[R637];
select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
while ( not_empty next_lnk )
  last_lnk = next_lnk;
  select one next_lnk related by last_lnk->ACT_LNK[R604.''precedes''];
end while;
select one select_obj related by last_lnk->O_OBJ[R678];
select_s_dt = ::getInstRefTypeForClass( s_dt:select_s_dt, o_obj:select_obj );
select many s_dims related by select_v_var->S_DIM[R849];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
select_type = TypeReference::getInstance( s_dt:select_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate select_type to l_op across R795;
select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
  ::transformVariable( v_var:select_v_var, smt:smt );
end if;
select any select_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == select_v_var.Name );
create object instance var_ref of VariableReference;
relate select_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
select one type related by l_op->TypeReference[R795]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
// create right operand
select one where_clause_val related by act_sel->ACT_SRW[R664]->V_VAL[R611];
select one where_clause_lbo related by where_clause_val->V_LBO[R801];
if ( not_empty where_clause_lbo and ( "false" == T::sub( format:"l", s:where_clause_lbo.Value ) ) ) // special case where the where clause is ''false''
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  create object instance named_expr of NamedReference;
  relate named_expr to r_op across R776;
  select one select_type_def related by select_type->Type[R3800];
  named_expr.name = select_type_def.default_value;
  ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:select_type_def.package + ".impl." + select_type_def.name + "Impl", type:ImportType::IMPL );
else
  // get the final selection chain link
  select one lnk related by act_sel->ACT_LNK[R637];
  select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
  while ( not_empty next_lnk )
    lnk = next_lnk;
    select one next_lnk related by lnk->ACT_LNK[R604.''precedes''];
  end while;
  if ( not_empty where_clause_val or "any" == act_sel.cardinality )
    create object instance r_op of Expression;
    relate r_op to smt across R775;
    r_op.expression_number = "1.2";
    relate r_op to binop across R778;
    relate select_type to r_op across R795;
    // create expression for last chain link
    ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2.1", smt:smt );
    if ( not_empty where_clause_val )
      create object instance where_expr of WhereExpr;
      relate where_expr to r_op across R776;
      where_expr.multiplicity = act_sel.cardinality;
      where_expr.sorted = SortType::NONE;
      if ("many" == where_expr.multiplicity)
        cls_set = ClassSet::get( block:block, o_obj:select_obj );
        where_expr.cast = cls_set.name;
      elif ("one" == where_expr.multiplicity)
        select one cls related by select_obj->Class[R409];
        where_expr.cast = cls.name;
      end if;
      // select the transformed link, relate it to the where clause
      select any select_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2.1" );
      relate select_expr to where_expr across R790;
      // transform the where clause condition
      ::transformExpression( v_val:where_clause_val, expr_number:"1.2.2", smt:smt );
      select any where_clause_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2.2" );
      relate where_clause_expr to where_expr across R796;
      ::resolveSortedSelection(where_expr:where_expr);
    else
      create object instance any_expr of AnyExpr;
      relate any_expr to r_op across R776;
      // select the transformed link, relate it to the any expression
      select any select_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2.1" );
      relate select_expr to any_expr across R783;
    end if;
  else
    // create expression for last chain link
    ::transformSelectionLink( act_lnk:lnk, expr_number:"1.2", smt:smt );
    // select the transformed link, relate it to the
    select any select_expr related by smt->Expression[R775] where ( selected.expression_number == "1.2" );
    relate select_expr to binop across R778;
  end if;
end if;
// link select type to the main expression
relate select_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("3c110882-7386-49b1-85c3-486a1c0efda7",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'act_sel',
	"633aa463-4eea-4f3c-aa01-8220a7870baa",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("633aa463-4eea-4f3c-aa01-8220a7870baa",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Select>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("8e258060-79d3-4d22-b9b1-960a8dc1f2ec",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"3c110882-7386-49b1-85c3-486a1c0efda7",
	'');
INSERT INTO S_SPARM
	VALUES ("6b2430e0-f218-427b-8b46-28feeaa6fdab",
	"af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"8e258060-79d3-4d22-b9b1-960a8dc1f2ec",
	'');
INSERT INTO PE_PE
	VALUES ("af8f13b1-ab56-4082-a3f0-55f200c7b3e1",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("6036379f-2a05-4d11-a876-958e0d4819c3",
	"00000000-0000-0000-0000-000000000000",
	'transformCreate',
	'',
	'act_cr = param.act_cr;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_cr->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
// create binary operation and assignment expression
create object instance binop of BinaryOperation;
relate binop to expr across R776;
binop.operator = "=";
binop.invocation = false;
// relate expression to expression as statement
relate eas to expr across R476;
// create left operand
select one cr_v_var related by act_cr->V_VAR[R633];
create object instance l_op of Expression;
relate l_op to smt across R775;
l_op.expression_number = "1.1";
select one cr_s_dt related by cr_v_var->S_DT[R848];
select one cr_obj related by act_cr->O_OBJ[R671];
cr_s_dt = ::getInstRefTypeForClass( s_dt:cr_s_dt, o_obj:cr_obj );
select many s_dims related by cr_v_var->S_DIM[R849];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
cr_type = TypeReference::getInstance( s_dt:cr_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate cr_type to l_op across R795;
select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == cr_v_var.Name );
if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
  ::transformVariable( v_var:cr_v_var, smt:smt );
end if;
select any cr_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == cr_v_var.Name );
create object instance var_ref of VariableReference;
relate cr_var to var_ref across R782;
relate var_ref to l_op across R776;
relate l_op to binop across R779;
select one type related by l_op->TypeReference[R795]->Type[R3800];
::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
// create right operand
create object instance r_op of Expression;
relate r_op to smt across R775;
r_op.expression_number = "1.2";
relate cr_type to r_op across R795;
create object instance cr of Creation;
relate cr to r_op across R776;
select one obj related by cr_obj->Class[R409];
relate cr to obj across R780;
relate r_op to binop across R778;
select one class_file related by obj->File[R401];
::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );
// link create type to the main expression
relate cr_type to expr across R795;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("48e1fa81-e41e-4fa9-a148-ddd99a3c72fc",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'act_cr',
	"07240b48-02ee-409d-b202-725bbb1b6707",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("07240b48-02ee-409d-b202-725bbb1b6707",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Create>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("de027b78-58a9-49f7-b97a-eb9dc2082ab8",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"48e1fa81-e41e-4fa9-a148-ddd99a3c72fc",
	'');
INSERT INTO S_SPARM
	VALUES ("1dc782ac-a634-4929-8faf-f3a611c8cc49",
	"6036379f-2a05-4d11-a876-958e0d4819c3",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"de027b78-58a9-49f7-b97a-eb9dc2082ab8",
	'');
INSERT INTO PE_PE
	VALUES ("6036379f-2a05-4d11-a876-958e0d4819c3",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	"00000000-0000-0000-0000-000000000000",
	'transformCreateNoVariable',
	'',
	'act_cnv = param.act_cnv;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_cnv->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create expression as statement
create object instance eas of ExpressionAsStatement;
relate eas to smt across R451;
// create main expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
relate eas to expr across R476;
select any s_irdt related by act_cnv->O_OBJ[R672]->S_IRDT[R123] where ( not selected.isSet );
select one s_dt related by s_irdt->S_DT[R17];
select many s_dims from instances of S_DIM where false;
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
cr_type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate cr_type to expr across R795;
// create creation
create object instance cr of Creation;
relate cr to expr across R776;
select one obj related by act_cnv->O_OBJ[R672]->Class[R409];
relate cr to obj across R780;
select one class_file related by obj->File[R401];
::addStringToImports( file: ::getFileForStatement( smt:smt ), s: ::pathToPackage( path:class_file.path ) + ".impl." + class_file.name + "Impl", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("0d2c8921-c1eb-4cb9-9429-8f7ded79758a",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'act_cnv',
	"6cab5519-9843-4065-80d9-10e766f232a1",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("6cab5519-9843-4065-80d9-10e766f232a1",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Create No Variable>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("bc5221f0-a255-4931-a2f1-99279f77e4ec",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"0d2c8921-c1eb-4cb9-9429-8f7ded79758a",
	'');
INSERT INTO S_SPARM
	VALUES ("42d0e1cd-a14c-4295-9f31-8881f78b56dd",
	"5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"bc5221f0-a255-4931-a2f1-99279f77e4ec",
	'');
INSERT INTO PE_PE
	VALUES ("5eaa4245-1b8b-422a-8599-f9c9b3e8f53c",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("963265b3-faa7-40a3-9425-55bca25e12e7",
	"00000000-0000-0000-0000-000000000000",
	'transformControl',
	'',
	'act_ctl = param.act_ctl;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ctl->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create halt statement
create object instance halt_smt of Halt;
relate halt_smt to smt across R451;
::addStringToImports( file: ::getFileForStatement( smt:smt ), s:"io.ciera.runtime.summit.application.tasks.HaltExecutionTask", type:ImportType::IMPL );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("70eba75f-b729-4e41-98a6-758d0b221973",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'act_ctl',
	"dbe30ccb-7f4a-4fde-b51a-cfd0b3dac9c9",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("dbe30ccb-7f4a-4fde-b51a-cfd0b3dac9c9",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Control>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("2a2a9434-69e4-4888-887c-e3a36000315b",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"70eba75f-b729-4e41-98a6-758d0b221973",
	'');
INSERT INTO S_SPARM
	VALUES ("b3d9aee1-b7c6-4bb9-82ce-b642056d1fa7",
	"963265b3-faa7-40a3-9425-55bca25e12e7",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"2a2a9434-69e4-4888-887c-e3a36000315b",
	'');
INSERT INTO PE_PE
	VALUES ("963265b3-faa7-40a3-9425-55bca25e12e7",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1ae7862a-2280-485d-adf4-4f7f2b553c75",
	"00000000-0000-0000-0000-000000000000",
	'transformDelete',
	'',
	'act_del = param.act_del;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_del->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create delete statement
create object instance del of DeleteSmt;
relate del to smt across R451;
// create variable reference expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = "1";
relate del to expr across R462;
select one del_v_var related by act_del->V_VAR[R634];
select one del_s_dt related by del_v_var->S_DT[R848];
select one del_obj related by del_v_var->V_INT[R814]->O_OBJ[R818];
del_s_dt = ::getInstRefTypeForClass( s_dt:del_s_dt, o_obj:del_obj );
select many s_dims related by del_v_var->S_DIM[R849];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
del_type = TypeReference::getInstance( s_dt:del_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate del_type to expr across R795;
select any del_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == del_v_var.Name );
if ( not_empty del_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate del_var to var_ref across R782;
  relate var_ref to expr across R776;
  select one type related by expr->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
elif ( "self" == del_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("015844df-dd39-45e8-b46b-ebb29b3cb13a",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'act_del',
	"a3a3437e-a8c2-4229-b348-ba64feaa5de5",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a3a3437e-a8c2-4229-b348-ba64feaa5de5",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Delete>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Instance Access/Instance Access.xtuml');
INSERT INTO S_SPARM
	VALUES ("833eb53d-3f12-423c-9fb2-a82f973d507d",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"015844df-dd39-45e8-b46b-ebb29b3cb13a",
	'');
INSERT INTO S_SPARM
	VALUES ("ecd46958-bc87-4eba-9ed5-fe1ff575dd18",
	"1ae7862a-2280-485d-adf4-4f7f2b553c75",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"833eb53d-3f12-423c-9fb2-a82f973d507d",
	'');
INSERT INTO PE_PE
	VALUES ("1ae7862a-2280-485d-adf4-4f7f2b553c75",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a5290be7-15be-4b55-a290-f48a0523e7ac",
	"00000000-0000-0000-0000-000000000000",
	'transformReturnStatement',
	'',
	'act_ret = param.act_ret;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ret->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create return statement
create object instance ret of ReturnSmt;
relate ret to smt across R451;
// create return expression
select one ret_val related by act_ret->V_VAL[R668];
if ( not_empty ret_val )
  select one act_act related by body->ACT_ACT[R432];
  ret_dt = ::getReturnType(act_act:act_act);
  select one val_dt related by ret_val->S_DT[R820];
  // no type promotion necessary or automatic promotion of integer to real or integer to timestamp
  if ret_dt == val_dt or (ret_dt.Name == "real" and val_dt.Name == "integer") or (ret_dt.Name == "timestamp" and val_dt.Name == "integer")
    ::transformExpression( v_val:ret_val, expr_number:"1", smt:smt );
  else
    // must do type promotion
    create object instance prom_expr of Expression;
    relate prom_expr to smt across R775;
    prom_expr.expression_number = "1";
    select many s_dims from instances of S_DIM where false;  // TODO does not support array types in type promotions
    type = TypeReference::getInstance(s_dt:ret_dt, s_dims:s_dims, referring_comp:referring_comp);
    relate type to prom_expr across R795;
    create object instance prom of Promotion;
    relate prom to prom_expr across R776;
    if ::typeIsBasedOn(type:val_dt, parentType:ret_dt)
      // only a simple cast is required
      prom.cast = true;
    else
      prom.cast = false;
      file = ::getFileForStatement(smt:smt);
      select one l_type related by type->Type[R3800];
      ::addTypeToImports(file:file, type_to_import:l_type, type:ImportType::IMPL);
    end if;
    ::transformExpression( v_val:ret_val, expr_number:"1.1", smt:smt );
    select any prom_val related by smt->Expression[R775] where (selected.expression_number == "1.1");
    relate prom_val to prom across R3907;
  end if;
  select any ret_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
  relate ret_expr to ret across R473;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("f52cd030-7a44-4ab4-ad14-b039b7a13438",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'act_ret',
	"e1613f59-f8aa-49fe-b922-77a457143277",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("e1613f59-f8aa-49fe-b922-77a457143277",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Return Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Invocation/Invocation.xtuml');
INSERT INTO S_SPARM
	VALUES ("5bde5d99-af6c-4cfc-9176-3cc09d3cd0ba",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"f52cd030-7a44-4ab4-ad14-b039b7a13438",
	'');
INSERT INTO S_SPARM
	VALUES ("446a5838-2c77-49b6-8a63-680ea0b2710f",
	"a5290be7-15be-4b55-a290-f48a0523e7ac",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"5bde5d99-af6c-4cfc-9176-3cc09d3cd0ba",
	'');
INSERT INTO PE_PE
	VALUES ("a5290be7-15be-4b55-a290-f48a0523e7ac",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("8644d33b-9954-4438-97ab-f130505c0621",
	"00000000-0000-0000-0000-000000000000",
	'transformRelate',
	'',
	'act_rel = param.act_rel;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_rel->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create relate statement
create object instance relsmt of RelateSmt;
relate relsmt to smt across R451;
// select the relationship
select one r_rel related by act_rel->R_REL[R653];
select one one_v_var related by act_rel->V_VAR[R615];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_rel->V_VAR[R616];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
    other_phrase = C_UTIL::stripTics( s:act_rel.relationship_phrase );
    select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_rel.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
    if ( not_empty oir )
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
    else
      // TODO bad
    end if;
  else // non-reflexive simple association
    select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
    select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
    if ( not_empty one_oir and not_empty other_oir )
      one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
      other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
    else
      // TODO bad
    end if;
  end if;
else
  select one subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty subsup )
    one_phrase = "is_a";
    other_phrase = "is_a";
  end if;
end if;
select any form_v_var from instances of V_VAR where false;
select any part_v_var from instances of V_VAR where false;
select any form_obj from instances of O_OBJ where false;
select any part_obj from instances of O_OBJ where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
  select any rel related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
  if ( not_empty rel )
    form_v_var = one_v_var;
    form_obj = one_o_obj;
    part_v_var = other_v_var;
    part_obj = other_o_obj;
  else
    select any rel related by containing_comp_def->Relationship[R448]
      where ( selected.num == r_rel.Numb and
        ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
    form_v_var = other_v_var;
    form_obj = other_o_obj;
    part_v_var = one_v_var;
    part_obj = one_o_obj;
  end if;
  if ( not_empty rel )
    relate rel to relsmt across R481;
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;
// create variable reference expression for formalizer
create object instance form_expr of Expression;
relate form_expr to smt across R775;
form_expr.expression_number = "1";
relate relsmt to form_expr across R479;
select one form_s_dt related by form_v_var->S_DT[R848];
form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:form_obj );
select many s_dims related by form_v_var->S_DIM[R849];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];
form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate form_type to form_expr across R795;
select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == form_v_var.Name );
if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate form_var to var_ref across R782;
  relate var_ref to form_expr across R776;
  select one type related by form_expr->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
elif ( "self" == form_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to form_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;
// create variable reference expression for participant
create object instance part_expr of Expression;
relate part_expr to smt across R775;
part_expr.expression_number = "2";
relate relsmt to part_expr across R480;
select one part_s_dt related by part_v_var->S_DT[R848];
part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:part_obj );
select many s_dims related by part_v_var->S_DIM[R849];
part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate part_type to part_expr across R795;
select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == part_v_var.Name );
if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate part_var to var_ref across R782;
  relate var_ref to part_expr across R776;
  select one type related by part_expr->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
elif ( "self" == part_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to part_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("dd0fd3f1-b737-409e-b37c-5f7518308ec5",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'act_rel',
	"d5097eb3-4f7a-4187-8d85-db8765b299c4",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d5097eb3-4f7a-4187-8d85-db8765b299c4",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relate>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("adcc66ef-8480-4080-8ccc-1c8086f742ef",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"dd0fd3f1-b737-409e-b37c-5f7518308ec5",
	'');
INSERT INTO S_SPARM
	VALUES ("4b39a960-38e5-4edf-8e2a-1387c16ca900",
	"8644d33b-9954-4438-97ab-f130505c0621",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"adcc66ef-8480-4080-8ccc-1c8086f742ef",
	'');
INSERT INTO PE_PE
	VALUES ("8644d33b-9954-4438-97ab-f130505c0621",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("17595ebc-9b3b-4a65-9834-4433f9a542a3",
	"00000000-0000-0000-0000-000000000000",
	'transformRelateUsing',
	'',
	'act_ru = param.act_ru;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_ru->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// select the relationship
select one r_rel related by act_ru->R_REL[R654];
select one one_v_var related by act_ru->V_VAR[R617];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_ru->V_VAR[R618];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one link_v_var related by act_ru->V_VAR[R619];
select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
select one link_class related by link_o_obj->Class[R409];
if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
  other_phrase = C_UTIL::stripTics( s:act_ru.relationship_phrase );
  select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_ru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
  select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
  select any one_oir from instances of R_OIR where false;
  for each oir in oirs
    if ( not_empty link and oir.OIR_ID != link.OIR_ID )
      one_oir = oir;
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
      break;
    end if;
  end for;
  if ( empty one_oir )
    // TODO bad
  end if;
else // non-reflexive linked association
  select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
  select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
  if ( not_empty one_oir and not_empty other_oir )
    one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
    other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
  else
    // TODO bad
  end if;
end if;
select any rel1 from instances of Relationship where false;
select any rel2 from instances of Relationship where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
  select any rel1 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
  select any rel2 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
else
  // TODO bad
end if;
if ( not_empty rel1 and not_empty rel2 )
  // create first relate statement (one to link)
  create object instance relsmt1 of RelateSmt;
  relate relsmt1 to smt across R451;
  relate rel1 to relsmt1 across R481;
  // create variable reference expression for formalizer for the first relate
  create object instance form_expr1 of Expression;
  relate form_expr1 to smt across R775;
  form_expr1.expression_number = "1";
  relate relsmt1 to form_expr1 across R479;
  select one form_s_dt related by link_v_var->S_DT[R848];
  form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:link_o_obj );
  select many s_dims related by link_v_var->S_DIM[R849];
  form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate form_type to form_expr1 across R795;
  select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == link_v_var.Name );
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr1 across R776;
    select one type related by form_expr1->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the first relate
  create object instance part_expr1 of Expression;
  relate part_expr1 to smt across R775;
  part_expr1.expression_number = "2";
  relate relsmt1 to part_expr1 across R480;
  select one part_s_dt related by one_v_var->S_DT[R848];
  part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:one_o_obj );
  select many s_dims related by one_v_var->S_DIM[R849];
  part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate part_type to part_expr1 across R795;
  select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == one_v_var.Name );
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr1 across R776;
    select one type related by part_expr1->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == one_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create second relate statement (other to link)
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = STRING::itoa( i:STRING::atoi( s:smt.statement_number ) + 1 );
  relate smt2 to smt across R477.''executes after'';
  smt2.oal = "";
  create object instance relsmt2 of RelateSmt;
  relate relsmt2 to smt2 across R451;
  relate rel2 to relsmt2 across R481;
  // create variable reference expression for formalizer for the second relate
  create object instance form_expr2 of Expression;
  relate form_expr2 to smt2 across R775;
  form_expr2.expression_number = "1";
  relate relsmt2 to form_expr2 across R479;
  relate form_type to form_expr2 across R795;
  select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == link_v_var.Name );
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr2 across R776;
    select one type related by form_expr2->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the second relate
  create object instance part_expr2 of Expression;
  relate part_expr2 to smt2 across R775;
  part_expr2.expression_number = "2";
  relate relsmt2 to part_expr2 across R480;
  select one part_s_dt related by other_v_var->S_DT[R848];
  part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:other_o_obj );
  select many s_dims related by other_v_var->S_DIM[R849];
  part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate part_type to part_expr2 across R795;
  select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == other_v_var.Name );
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr2 across R776;
    select one type related by part_expr2->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == other_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("c8b2f235-5faf-4c10-8efb-a0100f64f453",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'act_ru',
	"d67aab73-fa78-4bdb-b3a2-3d9eb1e798e2",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("d67aab73-fa78-4bdb-b3a2-3d9eb1e798e2",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Relate Using>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("0b1f5daa-5019-4d3f-9e24-081df02b7f43",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"c8b2f235-5faf-4c10-8efb-a0100f64f453",
	'');
INSERT INTO S_SPARM
	VALUES ("7a53e811-2dad-48b3-b4f8-af62426fb774",
	"17595ebc-9b3b-4a65-9834-4433f9a542a3",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"0b1f5daa-5019-4d3f-9e24-081df02b7f43",
	'');
INSERT INTO PE_PE
	VALUES ("17595ebc-9b3b-4a65-9834-4433f9a542a3",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	"00000000-0000-0000-0000-000000000000",
	'transformUnrelate',
	'',
	'act_unr = param.act_unr;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_unr->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create unrelate statement
create object instance unrelsmt of UnrelateSmt;
relate unrelsmt to smt across R451;
// select the relationship
select one r_rel related by act_unr->R_REL[R655];
select one one_v_var related by act_unr->V_VAR[R620];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_unr->V_VAR[R621];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one simp related by r_rel->R_SIMP[R206];
if ( not_empty simp )
  if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive simple association
    other_phrase = C_UTIL::stripTics( s:act_unr.relationship_phrase );
    select any oir related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_unr.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
    if ( not_empty oir )
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
    else
      // TODO bad
    end if;
  else // non-reflexive simple association
    select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
    select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
    if ( not_empty one_oir and not_empty other_oir )
      one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
      other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
    else
      // TODO bad
    end if;
  end if;
else
  select one subsup related by r_rel->R_SUBSUP[R206];
  if ( not_empty subsup )
    one_phrase = "is_a";
    other_phrase = "is_a";
  end if;
end if;
select any form_v_var from instances of V_VAR where false;
select any part_v_var from instances of V_VAR where false;
select any form_obj from instances of O_OBJ where false;
select any part_obj from instances of O_OBJ where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class )
  select any rel related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == one_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
  if ( not_empty rel )
    form_v_var = one_v_var;
    form_obj = one_o_obj;
    part_v_var = other_v_var;
    part_obj = other_o_obj;
  else
    select any rel related by containing_comp_def->Relationship[R448]
      where ( selected.num == r_rel.Numb and
        ( selected.form_name == other_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
    form_v_var = other_v_var;
    form_obj = other_o_obj;
    part_v_var = one_v_var;
    part_obj = one_o_obj;
  end if;
  if ( not_empty rel )
    relate rel to unrelsmt across R484;
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;
// create variable reference expression for formalizer
create object instance form_expr of Expression;
relate form_expr to smt across R775;
form_expr.expression_number = "1";
relate unrelsmt to form_expr across R483;
select one form_s_dt related by form_v_var->S_DT[R848];
form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:form_obj );
select many s_dims related by form_v_var->S_DIM[R849];
form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate form_type to form_expr across R795;
select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == form_v_var.Name );
if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate form_var to var_ref across R782;
  relate var_ref to form_expr across R776;
  select one type related by form_expr->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
elif ( "self" == form_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to form_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;
// create variable reference expression for participant
create object instance part_expr of Expression;
relate part_expr to smt across R775;
part_expr.expression_number = "2";
relate unrelsmt to part_expr across R482;
select one part_s_dt related by part_v_var->S_DT[R848];
part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:part_obj );
select many s_dims related by part_v_var->S_DIM[R849];
part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate part_type to part_expr across R795;
select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == part_v_var.Name );
if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
  create object instance var_ref of VariableReference;
  relate part_var to var_ref across R782;
  relate var_ref to part_expr across R776;
  select one type related by part_expr->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
elif ( "self" == part_v_var.Name )
  // create named reference
  create object instance self_ref of NamedReference;
  relate self_ref to part_expr across R776;
  self_ref.name = "self()";
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1dac3743-7efa-410e-9f60-f1bdfe79b3ce",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'act_unr',
	"eb4d7904-ebb3-44a2-a564-13c9f7978b60",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("eb4d7904-ebb3-44a2-a564-13c9f7978b60",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Unrelate>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("c781e493-f545-4b53-bea8-5f604cae99ed",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"1dac3743-7efa-410e-9f60-f1bdfe79b3ce",
	'');
INSERT INTO S_SPARM
	VALUES ("94993921-0dad-4ee2-a3b6-51979d5ac418",
	"ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"c781e493-f545-4b53-bea8-5f604cae99ed",
	'');
INSERT INTO PE_PE
	VALUES ("ff1b9e3e-9e45-43be-add7-bda4c00b5ee2",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("48985724-4b82-49d9-9e43-d57a9ed432fd",
	"00000000-0000-0000-0000-000000000000",
	'transformUnrelateUsing',
	'',
	'act_uru = param.act_uru;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by act_uru->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// select the relationship
select one r_rel related by act_uru->R_REL[R656];
select one one_v_var related by act_uru->V_VAR[R622];
select one one_o_obj related by one_v_var->V_INT[R814]->O_OBJ[R818];
select one one_class related by one_o_obj->Class[R409];
one_phrase = "";
select one other_v_var related by act_uru->V_VAR[R623];
select one other_o_obj related by other_v_var->V_INT[R814]->O_OBJ[R818];
select one other_class related by other_o_obj->Class[R409];
other_phrase = "";
select one link_v_var related by act_uru->V_VAR[R624];
select one link_o_obj related by link_v_var->V_INT[R814]->O_OBJ[R818];
select one link_class related by link_o_obj->Class[R409];
if ( one_o_obj.Obj_ID == other_o_obj.Obj_ID ) // reflexive linked association
  other_phrase = C_UTIL::stripTics( s:act_uru.relationship_phrase );
  select many oirs related by r_rel->R_OIR[R201] where ( C_UTIL::stripTics( s:act_uru.relationship_phrase ) != ::oirGetPhrase( r_oir_id:selected.OIR_ID ) );
  select any link related by oirs->R_RGO[R203]->R_ASSR[R205];
  select any one_oir from instances of R_OIR where false;
  for each oir in oirs
    if ( not_empty link and oir.OIR_ID != link.OIR_ID )
      one_oir = oir;
      one_phrase = ::oirGetPhrase( r_oir_id:oir.OIR_ID );
      break;
    end if;
  end for;
  if ( empty one_oir )
    // TODO bad
  end if;
else // non-reflexive linked association
  select any one_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == one_o_obj.Obj_ID );
  select any other_oir related by r_rel->R_OIR[R201] where ( selected.Obj_ID == other_o_obj.Obj_ID );
  if ( not_empty one_oir and not_empty other_oir )
    one_phrase = ::oirGetPhrase( r_oir_id:one_oir.OIR_ID );
    other_phrase = ::oirGetPhrase( r_oir_id:other_oir.OIR_ID );
  else
    // TODO bad
  end if;
end if;
select any rel1 from instances of Relationship where false;
select any rel2 from instances of Relationship where false;
containing_comp_def = ::getCompDefForStatement( smt:smt );
if ( not_empty containing_comp_def and not_empty one_class and not_empty other_class and not_empty link_class )
  select any rel1 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == other_phrase and selected.part_name == one_class.name and selected.part_phrase == one_phrase ) );
  select any rel2 related by containing_comp_def->Relationship[R448]
    where ( selected.num == r_rel.Numb and
      ( selected.form_name == link_class.name and selected.form_phrase == one_phrase and selected.part_name == other_class.name and selected.part_phrase == other_phrase ) );
else
  // TODO bad
end if;
if ( not_empty rel1 and not_empty rel2 )
  // create first unrelate statement (one to link)
  create object instance unrelsmt1 of UnrelateSmt;
  relate unrelsmt1 to smt across R451;
  relate rel1 to unrelsmt1 across R484;
  // create variable reference expression for formalizer for the first unrelate
  create object instance form_expr1 of Expression;
  relate form_expr1 to smt across R775;
  form_expr1.expression_number = "1";
  relate unrelsmt1 to form_expr1 across R483;
  select one form_s_dt related by link_v_var->S_DT[R848];
  form_s_dt = ::getInstRefTypeForClass( s_dt:form_s_dt, o_obj:link_o_obj );
  select many s_dims related by link_v_var->S_DIM[R849];
  form_type = TypeReference::getInstance( s_dt:form_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate form_type to form_expr1 across R795;
  select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == link_v_var.Name );
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr1 across R776;
    select one type related by form_expr1->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the first relate
  create object instance part_expr1 of Expression;
  relate part_expr1 to smt across R775;
  part_expr1.expression_number = "2";
  relate unrelsmt1 to part_expr1 across R482;
  select one part_s_dt related by one_v_var->S_DT[R848];
  part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:one_o_obj );
  select many s_dims related by one_v_var->S_DIM[R849];
  part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate part_type to part_expr1 across R795;
  select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == one_v_var.Name );
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr1 across R776;
    select one type related by part_expr1->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == one_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr1 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create second relate statement (other to link)
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = STRING::itoa( i:STRING::atoi( s:smt.statement_number ) + 1 );
  relate smt2 to smt across R477.''executes after'';
  smt2.oal = "";
  create object instance unrelsmt2 of UnrelateSmt;
  relate unrelsmt2 to smt2 across R451;
  relate rel2 to unrelsmt2 across R484;
  // create variable reference expression for formalizer for the second relate
  create object instance form_expr2 of Expression;
  relate form_expr2 to smt2 across R775;
  form_expr2.expression_number = "1";
  relate unrelsmt2 to form_expr2 across R483;
  relate form_type to form_expr2 across R795;
  select any form_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == link_v_var.Name );
  if ( not_empty form_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate form_var to var_ref across R782;
    relate var_ref to form_expr2 across R776;
    select one type related by form_expr2->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == link_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to form_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
  // create variable reference expression for participant for the second relate
  create object instance part_expr2 of Expression;
  relate part_expr2 to smt2 across R775;
  part_expr2.expression_number = "2";
  relate unrelsmt2 to part_expr2 across R482;
  select one part_s_dt related by other_v_var->S_DT[R848];
  part_s_dt = ::getInstRefTypeForClass( s_dt:part_s_dt, o_obj:other_o_obj );
  select many s_dims related by other_v_var->S_DIM[R849];
  part_type = TypeReference::getInstance( s_dt:part_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate part_type to part_expr2 across R795;
  select any part_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == other_v_var.Name );
  if ( not_empty part_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate part_var to var_ref across R782;
    relate var_ref to part_expr2 across R776;
    select one type related by part_expr2->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == other_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to part_expr2 across R776;
    self_ref.name = "self()";
  else
    // TODO bad
  end if;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("777239a3-27e7-410e-935e-0b4299d7115e",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'act_uru',
	"0c25b822-1415-4179-a600-998ebcb89b17",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0c25b822-1415-4179-a600-998ebcb89b17",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Unrelate Using>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Relate And Unrelate/Relate And Unrelate.xtuml');
INSERT INTO S_SPARM
	VALUES ("f4c88b70-1d06-4464-968a-46acb41222ec",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"777239a3-27e7-410e-935e-0b4299d7115e",
	'');
INSERT INTO S_SPARM
	VALUES ("b683f05a-48a7-4c5b-8949-a3438906cdee",
	"48985724-4b82-49d9-9e43-d57a9ed432fd",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"f4c88b70-1d06-4464-968a-46acb41222ec",
	'');
INSERT INTO PE_PE
	VALUES ("48985724-4b82-49d9-9e43-d57a9ed432fd",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("ff9fef83-850a-4abe-82ef-6d5b83f505bf",
	"00000000-0000-0000-0000-000000000000",
	'getCompDefForStatement',
	'',
	'smt = param.smt;
select one comp_def related by smt->CodeBlock[R450]->
  InvocableInComponent[R4000]->ComponentDefinition[R4001];
return comp_def;',
	"109e90cb-1d66-46ee-88db-a568044879d0",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e54da777-e46e-48c6-b14e-aa50240d50f4",
	"ff9fef83-850a-4abe-82ef-6d5b83f505bf",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("ff9fef83-850a-4abe-82ef-6d5b83f505bf",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_DT_PROXY
	VALUES ("109e90cb-1d66-46ee-88db-a568044879d0",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Component Definition>',
	'',
	'',
	'../../architecture/component/component.xtuml');
INSERT INTO S_SYNC
	VALUES ("1086e27e-2bff-450b-b9e1-903ffcc7f983",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameter',
	'',
	'invocation = param.invocation;
parm = param.parm;
v_par = param.v_par;
prev_act_parm = param.prev_act_parm;
expr_number = param.expression_num;

select one smt related by invocation->Expression[R776]->Statement[R775];

select any expr from instances of Expression where false;

select one v_val related by v_par->V_VAL[R800];
if ( not_empty v_val )
  par_dt = ::getParType(v_par:v_par);
  select one s_dt related by v_val->S_DT[R820];
  // no type promotion necessary or automatic promotion of integer to real or integer to timestamp
  if par_dt == s_dt or (par_dt.Name == "real" and s_dt.Name == "integer") or (par_dt.Name == "timestamp" and s_dt.Name == "integer")
    ::transformExpression(v_val:v_val, expr_number:expr_number, smt:smt);
  else
    // must do type promotion
    create object instance prom_expr of Expression;
    relate prom_expr to smt across R775;
    prom_expr.expression_number = expr_number;
    select many s_dims from instances of S_DIM where false;  // TODO does not support array types in type promotions
    select one referring_comp related by smt->CodeBlock[R450]->InvocableInComponent[R4000]->ComponentDefinition[R4001];
    type = TypeReference::getInstance(s_dt:par_dt, s_dims:s_dims, referring_comp:referring_comp);
    relate type to prom_expr across R795;
    create object instance prom of Promotion;
    relate prom to prom_expr across R776;
    if ::typeIsBasedOn(type:s_dt, parentType:par_dt)
      // only a simple cast is required
      prom.cast = true;
    else
      prom.cast = false;
      file = ::getFileForStatement(smt:smt);
      select one l_type related by type->Type[R3800];
      ::addTypeToImports(file:file, type_to_import:l_type, type:ImportType::IMPL);
    end if;
    ::transformExpression(v_val:v_val, expr_number:expr_number + ".1", smt:smt);
    select any prom_val related by smt->Expression[R775] where (selected.expression_number == expr_number + ".1");
    relate prom_val to prom across R3907;
  end if;
 
  select any expr related by smt->Expression[R775] where (selected.expression_number == expr_number);
else
  // TODO bad
end if;

if ( not_empty expr )

  // create the actual parameter
  create object instance act_parm of ActualParameter;
  relate act_parm to expr across R794;
  relate invocation to act_parm across R793;
  if (not_empty parm)
    relate act_parm to parm across R3904;
  end if;
  if (not_empty prev_act_parm)
    relate prev_act_parm to act_parm across R3905.''precedes'';
  end if;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("58a320b8-144a-4b2d-bf9f-794e7007f45b",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'invocation',
	"887d1375-b0ab-4462-b2be-ec5b8e265583",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("887d1375-b0ab-4462-b2be-ec5b8e265583",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocation>',
	'',
	'',
	'../../architecture/expression/expression.xtuml');
INSERT INTO S_SPARM
	VALUES ("951ecc90-134e-49da-9ed8-c63a155663e0",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'parm',
	"4f106c1b-2473-4622-9798-816c7eb93613",
	0,
	'',
	"58a320b8-144a-4b2d-bf9f-794e7007f45b",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("4f106c1b-2473-4622-9798-816c7eb93613",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Formal Parameter>',
	'',
	'',
	'../../architecture/invocable/invocable.xtuml');
INSERT INTO S_SPARM
	VALUES ("395d0c03-151e-48dc-a94c-3446a5137c72",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'expression_num',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"951ecc90-134e-49da-9ed8-c63a155663e0",
	'');
INSERT INTO S_SPARM
	VALUES ("ccea4989-d98a-418c-9e68-f3c4f0a37fcf",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'v_par',
	"2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	0,
	'',
	"395d0c03-151e-48dc-a94c-3446a5137c72",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("2f2a9dba-8f5a-45a4-8c26-dfe684dbe206",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("d1b3d818-7d61-4e09-8a18-23cac76427be",
	"1086e27e-2bff-450b-b9e1-903ffcc7f983",
	'prev_act_parm',
	"15f335b9-816f-44ca-811f-2a2daa85f28b",
	0,
	'',
	"ccea4989-d98a-418c-9e68-f3c4f0a37fcf",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15f335b9-816f-44ca-811f-2a2daa85f28b",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Actual Parameter>',
	'',
	'',
	'../../architecture/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("1086e27e-2bff-450b-b9e1-903ffcc7f983",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	"00000000-0000-0000-0000-000000000000",
	'transformActualParameters',
	'',
	'invocation = param.invocation;
v_pars = param.v_pars;
expr_number = param.expr_number;
base_num = param.base_num;

// get first formal parameter
select any parm related by invocation->InvocableObject[R792]->FormalParameter[R429];
select one prev_parm related by parm->FormalParameter[R404.''follows''];
while ( not_empty prev_parm )
  parm = prev_parm;
  select one prev_parm related by parm->FormalParameter[R404.''follows''];
end while;

// transform each parameter
num = base_num;
select any v_par from instances of V_PAR where false;
select any prev_act_parm from instances of ActualParameter where false;
while ( not_empty parm )
  for each par in v_pars
    if ( "p_" + par.Name == parm.name )
      v_par = par;
      break;
    end if;
  end for;
  ::transformActualParameter( invocation:invocation, parm:parm, expression_num:expr_number + "." + STRING::itoa( i:num ), v_par:v_par, prev_act_parm:prev_act_parm );
  select any prev_act_parm related by invocation->ActualParameter[R793] where (selected.expression_number == expr_number + "." + STRING::itoa( i:num ));
  select one parm related by parm->FormalParameter[R404.''precedes''];
  num = num + 1;
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("1fe4d601-e86d-4986-81ce-83aa4a39f88e",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'invocation',
	"887d1375-b0ab-4462-b2be-ec5b8e265583",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("5e01e39f-65f1-46fe-84b9-ecfda3d67470",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'v_pars',
	"cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	0,
	'',
	"1fe4d601-e86d-4986-81ce-83aa4a39f88e",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("cff0610c-aa78-4735-bf53-f7fa31ce74fd",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref_set<Actual Parameter>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("f1e1995e-dc4c-4f29-93ec-f8e6d0cc1c9f",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"5e01e39f-65f1-46fe-84b9-ecfda3d67470",
	'');
INSERT INTO S_SPARM
	VALUES ("ad54a420-a271-4416-8160-585c7d6b65d9",
	"d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	'base_num',
	"ba5eda7a-def5-0000-0000-000000000002",
	0,
	'',
	"f1e1995e-dc4c-4f29-93ec-f8e6d0cc1c9f",
	'');
INSERT INTO PE_PE
	VALUES ("d25a1b30-4119-4e3f-a9f6-e37efecc2378",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	"00000000-0000-0000-0000-000000000000",
	'transformBlock',
	'',
	'upper_block = param.upper_block;
act_blk = param.act_blk;
if ( not_empty act_blk )

  invocableInComp = param.invocableInComp;
  select one invocable related by invocableInComp->InvocableObject[R4001];

  // create code block
  create object instance block of CodeBlock;
  if ( empty upper_block )
    block.top_level = true;
    block.tab_depth = 1;
    select one port_msg related by invocable->PortMessage[R427];
    if ( not_empty port_msg )
      select one port related by port_msg->Port[R420];
      select one msg related by port_msg->Message[R420];
      if ( ( msg.to_provider and not port.provider ) or ( not msg.to_provider and port.provider ) )
        block.tab_depth = 2; // increase the tab depth by one for bodies which belong to outbound port messages
      end if;
    end if;
    select one deriv related by invocable->AttributeDerivation[R427];
    select one class_op related by invocable->Operation[R427] where ( selected.is_class_based );
    if ( not_empty deriv  or not_empty class_op )
      block.tab_depth = 2; // increase the tab depth by one for bodies which belong to derived attributes and class based operations
    end if;
  else
    select one invocableInComp related by upper_block->InvocableInComponent[R4000];
    block.top_level = false;
    block.tab_depth = upper_block.tab_depth + 1;
  end if;
  relate block to invocableInComp across R4000;
  block.block_number = param.block_number;

  // copy visibile variables from upper block
  select many vars related by upper_block->Variable[R458];
  for each var in vars
    create object instance var_in_scope of VariableInScope;
    relate var to block across R458 using var_in_scope;
  end for;

  // transform all statements
  ::transformStatements( act_blk:act_blk, block:block );

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("c7c645e5-1940-478e-9373-907b72bb2272",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'upper_block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("48703f0c-67e0-473b-aede-2525092b2198",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"c7c645e5-1940-478e-9373-907b72bb2272",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("069f7c9f-7387-4d78-8d66-5f72c773e58e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Block>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("47463209-70cd-45f6-8be8-763363b0cfe6",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"48703f0c-67e0-473b-aede-2525092b2198",
	'');
INSERT INTO S_SPARM
	VALUES ("98163c1d-46c5-45d1-96af-242557384710",
	"c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	'invocableInComp',
	"15275e26-b9be-4723-81b7-a823b206a5bb",
	0,
	'',
	"47463209-70cd-45f6-8be8-763363b0cfe6",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("15275e26-b9be-4723-81b7-a823b206a5bb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<InvocableInComponent>',
	'',
	'',
	'../../architecture/invocable/invocable.xtuml');
INSERT INTO PE_PE
	VALUES ("c98ed204-d0e1-49ac-b3b8-6a8518c35bfb",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("1f9fe480-5772-4b3b-9bc1-137bca58c156",
	"00000000-0000-0000-0000-000000000000",
	'transformBlockForElif',
	'',
	'upper_block = param.upper_block;
act_el = param.act_el;

// create block
select one invocableInComp related by upper_block->InvocableInComponent[R4000];
select one invocable related by invocableInComp->InvocableObject[R4001];
create object instance block of CodeBlock;
relate block to invocableInComp across R4000;
block.block_number = param.block_number;
block.tab_depth = upper_block.tab_depth;  // keep same tab depth

// copy visibile variables from upper block
select many vars related by upper_block->Variable[R458];
for each var in vars
  create object instance var_in_scope of VariableInScope;
  relate var to block across R458 using var_in_scope;
end for;

// create single statement in block
create object instance smt of Statement;
relate smt to block across R450;
smt.statement_number = "1";
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
select one act_smt related by act_el->ACT_SMT[R603];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create if statement
create object instance if_smt of IfSmt;
relate if_smt to smt across R451;
if_smt.is_else_if = true;

// translate if expression
select one if_val related by act_el->V_VAL[R659];
::transformExpression( v_val:if_val, expr_number:"1", smt:smt );
select any if_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate if_expr to if_smt across R471;

// create then block
select any empty_invocableInComp from instances of InvocableInComponent where false;
then_block_number = ::getNextBlockNumber( upper_block:block );
select one then_blk related by act_el->ACT_BLK[R658];
::transformBlock( upper_block:block, act_blk:then_blk, block_number:then_block_number, invocableInComp:empty_invocableInComp );
select any then_block related by block->InvocableInComponent[R4000]->CodeBlock[R4000] where ( selected.block_number == then_block_number );
relate then_block to if_smt across R453;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("e32ea91a-410f-40ab-accd-76e327852918",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'upper_block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("a7dfa395-bf16-4110-8ff6-c5f19da15fe0",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'act_el',
	"c73f7572-ce31-4792-9718-8a411cbfe1eb",
	0,
	'',
	"e32ea91a-410f-40ab-accd-76e327852918",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c73f7572-ce31-4792-9718-8a411cbfe1eb",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<ElseIf Stmt>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("51da31a8-3182-4ffc-8f99-df45099bc3f7",
	"1f9fe480-5772-4b3b-9bc1-137bca58c156",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"a7dfa395-bf16-4110-8ff6-c5f19da15fe0",
	'');
INSERT INTO PE_PE
	VALUES ("1f9fe480-5772-4b3b-9bc1-137bca58c156",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("a1626421-4c40-4eec-96aa-f6a8308f9d49",
	"00000000-0000-0000-0000-000000000000",
	'transformBlockForFor',
	'',
	'upper_block = param.upper_block;
act_blk = param.act_blk;

// create code block
create object instance block of CodeBlock;
select one invocableInComp related by upper_block->InvocableInComponent[R4000];
block.tab_depth = upper_block.tab_depth + 1;
relate block to invocableInComp across R4000;
block.block_number = param.block_number;

// copy visibile variables from upper block
select many vars related by upper_block->Variable[R458];
for each var in vars
  create object instance var_in_scope of VariableInScope;
  relate var to block across R458 using var_in_scope;
end for;

// transform all statements
::transformStatements( act_blk:act_blk, block:block );',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("95163797-f92a-4cde-8bd1-653fc93e495e",
	"a1626421-4c40-4eec-96aa-f6a8308f9d49",
	'upper_block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("56ae9715-a512-4828-af92-32914de2ed6b",
	"a1626421-4c40-4eec-96aa-f6a8308f9d49",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"95163797-f92a-4cde-8bd1-653fc93e495e",
	'');
INSERT INTO S_SPARM
	VALUES ("f8f85dfe-4bcf-4059-90da-40fd4d6da916",
	"a1626421-4c40-4eec-96aa-f6a8308f9d49",
	'block_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"56ae9715-a512-4828-af92-32914de2ed6b",
	'');
INSERT INTO S_SPARM
	VALUES ("13db2b19-4749-4b6f-9dff-db535c20e770",
	"a1626421-4c40-4eec-96aa-f6a8308f9d49",
	'iter_var',
	"c9708af9-d7e3-4342-b794-8c2671da2530",
	0,
	'',
	"f8f85dfe-4bcf-4059-90da-40fd4d6da916",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("c9708af9-d7e3-4342-b794-8c2671da2530",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Variable>',
	'',
	'',
	'../../architecture/statement/statement.xtuml');
INSERT INTO S_SPARM
	VALUES ("5135db2b-c762-4330-9272-898ef5a621f4",
	"a1626421-4c40-4eec-96aa-f6a8308f9d49",
	'for_smt',
	"5b47ee89-895b-438a-928d-743a7ac25fa3",
	0,
	'',
	"13db2b19-4749-4b6f-9dff-db535c20e770",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("5b47ee89-895b-438a-928d-743a7ac25fa3",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<For>',
	'',
	'',
	'../../architecture/statement/statement.xtuml');
INSERT INTO PE_PE
	VALUES ("a1626421-4c40-4eec-96aa-f6a8308f9d49",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	"00000000-0000-0000-0000-000000000000",
	'transformBody',
	'',
	'invocableInComp = param.invocableInComp;
select one invocable related by invocableInComp->InvocableObject[R4001];
select one act_act related by invocable->ACT_ACT[R432];
if ( not_empty act_act and not_empty invocable )
    
  // check if deferred operation
  select one deferral related by act_act->ACT_OPB[R698]->O_TFR[R696]->O_DEF[R126];
  if (not_empty deferral and STRING::indexof(haystack:invocable.name, needle:"_supertype_") != 0)
    ::transformDeferral(invocableInComp:invocableInComp, deferral:deferral);
  else
    select any upper_block from instances of CodeBlock where false;
    select one act_blk related by act_act->ACT_BLK[R666];
    ::transformBlock( invocableInComp:invocableInComp, upper_block:upper_block, act_blk:act_blk, block_number:"1" );
    
    // finalize variables referenced from within a where clause
    ::resloveVariableFinalizations( invocable:invocable );
  end if;

else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("bce2fe74-a3cb-4614-8044-7d471c36ab0d",
	"e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	'invocableInComp',
	"15275e26-b9be-4723-81b7-a823b206a5bb",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("e45b0c87-1160-45d1-89dc-89f8f9c8a3c2",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("04db27cc-9322-4de2-9d0d-d758274a9cda",
	"00000000-0000-0000-0000-000000000000",
	'transformStatement',
	'',
	'act_smt = param.act_smt;
block = param.block;
prev_smt = param.prev_smt;
if ( empty act_smt or empty block )
  // TODO bad
end if;

select one act_brg related by act_smt->ACT_BRG[R603];
if ( not_empty act_brg )
  ::transformBridgeInvocation( act_brg:act_brg, block:block, prev_smt:prev_smt );
  
else
select one act_fnc related by act_smt->ACT_FNC[R603];
if ( not_empty act_fnc )
  ::transformFunctionInvocation( act_fnc:act_fnc, block:block, prev_smt:prev_smt );
  
else
select one act_tfm related by act_smt->ACT_TFM[R603];
if ( not_empty act_tfm )
  ::transformOperationInvocation( act_tfm:act_tfm, block:block, prev_smt:prev_smt );
  
else
select one act_sgn related by act_smt->ACT_SGN[R603];
if ( not_empty act_sgn )
  ::transformSignalInvocation( act_sgn:act_sgn, block:block, prev_smt:prev_smt );
  
else
select one act_if related by act_smt->ACT_IF[R603];
if ( not_empty act_if )
  ::transformIfStatement( act_if:act_if, block:block, prev_smt:prev_smt );
  
else
select one act_whl related by act_smt->ACT_WHL[R603];
if ( not_empty act_whl )
  ::transformWhileStatement( act_whl:act_whl, block:block, prev_smt:prev_smt );
  
else
select one act_brk related by act_smt->ACT_BRK[R603];
if ( not_empty act_brk )
  ::transformBreakStatement( act_brk:act_brk, block:block, prev_smt:prev_smt );

else
select one act_con related by act_smt->ACT_CON[R603];
if ( not_empty act_con )
  ::transformContinueStatement( act_con:act_con, block:block, prev_smt:prev_smt );

else
select one act_ai related by act_smt->ACT_AI[R603];
if ( not_empty act_ai )
  ::transformAssignToMember( act_ai:act_ai, block:block, prev_smt:prev_smt );

else
select one act_for related by act_smt->ACT_FOR[R603];
if ( not_empty act_for )
  ::transformForStatement( act_for:act_for, block:block, prev_smt:prev_smt );

else
select one act_fio related by act_smt->ACT_FIO[R603];
if ( not_empty act_fio )
  ::transformSelectFromInstances( act_fio:act_fio, block:block, prev_smt:prev_smt );

else
select one act_fiw related by act_smt->ACT_FIW[R603];
if ( not_empty act_fiw )
  ::transformSelectFromInstancesWhere( act_fiw:act_fiw, block:block, prev_smt:prev_smt );

else
select one act_sel related by act_smt->ACT_SEL[R603];
if ( not_empty act_sel )
  ::transformSelect( act_sel:act_sel, block:block, prev_smt:prev_smt );

else 
select one act_cr related by act_smt->ACT_CR[R603];
if ( not_empty act_cr )
  ::transformCreate( act_cr:act_cr, block:block, prev_smt:prev_smt );

else
select one act_cnv related by act_smt->ACT_CNV[R603];
if ( not_empty act_cnv )
  ::transformCreateNoVariable( act_cnv:act_cnv, block:block, prev_smt:prev_smt );
 
else
select one act_ctl related by act_smt->ACT_CTL[R603];
if ( not_empty act_ctl )
  ::transformControl( act_ctl:act_ctl, block:block, prev_smt:prev_smt );

else
select one act_del related by act_smt->ACT_DEL[R603];
if ( not_empty act_del )
  ::transformDelete( act_del:act_del, block:block, prev_smt:prev_smt );

else
select one act_ret related by act_smt->ACT_RET[R603];
if ( not_empty act_ret )
  ::transformReturnStatement( act_ret:act_ret, block:block, prev_smt:prev_smt );

else
select one act_rel related by act_smt->ACT_REL[R603];
if ( not_empty act_rel )
  ::transformRelate( act_rel:act_rel, block:block, prev_smt:prev_smt );

else
select one act_ru related by act_smt->ACT_RU[R603];
if ( not_empty act_ru )
  ::transformRelateUsing( act_ru:act_ru, block:block, prev_smt:prev_smt );

else
select one act_unr related by act_smt->ACT_UNR[R603];
if ( not_empty act_unr )
  ::transformUnrelate( act_unr:act_unr, block:block, prev_smt:prev_smt );

else
select one act_uru related by act_smt->ACT_URU[R603];
if ( not_empty act_uru )
  ::transformUnrelateUsing( act_uru:act_uru, block:block, prev_smt:prev_smt );
  
else
select one e_ess related by act_smt->E_ESS[R603];
if ( not_empty e_ess )
  ::transformEventSpecificationStatement( e_ess:e_ess, block:block, prev_smt:prev_smt );

else
select one e_gpr related by act_smt->E_GPR[R603];
if ( not_empty e_gpr )
  ::transformGeneratePreexistingEventStatement( e_gpr:e_gpr, block:block, prev_smt:prev_smt );

else
  LOG::LogFailure( message:"statement type not supported" );
end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if; end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("6a797716-53e0-4e73-a25b-a85802ff8f54",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'act_smt',
	"8ca0ad46-f8b8-47ba-9456-548bf0777490",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8ca0ad46-f8b8-47ba-9456-548bf0777490",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Statement>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Body/Body.xtuml');
INSERT INTO S_SPARM
	VALUES ("7ddfbe6a-6e18-4242-92c6-9c6c0090d58c",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"6a797716-53e0-4e73-a25b-a85802ff8f54",
	'');
INSERT INTO S_SPARM
	VALUES ("85a83eca-bdf5-487b-9110-50b786be86c7",
	"04db27cc-9322-4de2-9d0d-d758274a9cda",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"7ddfbe6a-6e18-4242-92c6-9c6c0090d58c",
	'');
INSERT INTO PE_PE
	VALUES ("04db27cc-9322-4de2-9d0d-d758274a9cda",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("bb386e4f-49ba-4b23-b465-577216ff4555",
	"00000000-0000-0000-0000-000000000000",
	'transformStatements',
	'',
	'act_blk = param.act_blk;
block = param.block;
// transform all statements
// BridgePoint produces statement lists in reverse order of what they would be expected
// to be according to the role phrases: https://support.onefact.net/issues/5382.
// This code appears to select the last statement which is actually the first statement.
// Then, when iterating to the next statement, it iterates backwards which is actually
// forwards (gah).
select any act_smt from instances of ACT_SMT where false;
select many act_smts related by act_blk->ACT_SMT[R602];
for each smt in act_smts
  if ( empty act_smt )
    act_smt = smt;
  else
    if ( smt.LineNumber < act_smt.LineNumber or smt.LineNumber == act_smt.LineNumber and smt.StartPosition < act_smt.StartPosition )
      act_smt = smt;
    end if;
  end if;
end for;

select any prev_smt from instances of Statement where false;
smt_num = 1;
while ( not_empty act_smt )
  ::transformStatement( act_smt:act_smt, block:block, prev_smt:prev_smt );
  select any prev_smt related by block->Statement[R450] where ( selected.statement_number == STRING::itoa( i:smt_num + 1 ) ); // for OAL statements that result in 2 statements
  if ( not_empty prev_smt )
    smt_num = smt_num + 2;
  else
    select any prev_smt related by block->Statement[R450] where ( selected.statement_number == STRING::itoa( i:smt_num ) );
    smt_num = smt_num + 1;
  end if;
  select one act_smt related by act_smt->ACT_SMT[R661.''succeeds''];
  // see if array needs to be declared
  ::resolveArrayDeclaration( smt:prev_smt );
end while;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("50ed669c-51ab-49f7-8029-0a7263aac5e5",
	"bb386e4f-49ba-4b23-b465-577216ff4555",
	'act_blk',
	"069f7c9f-7387-4d78-8d66-5f72c773e58e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_SPARM
	VALUES ("d1fafd85-9481-48cb-97e4-7ac46c0814b6",
	"bb386e4f-49ba-4b23-b465-577216ff4555",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"50ed669c-51ab-49f7-8029-0a7263aac5e5",
	'');
INSERT INTO PE_PE
	VALUES ("bb386e4f-49ba-4b23-b465-577216ff4555",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("85cbd402-8906-4b60-9700-a81e119bef37",
	"00000000-0000-0000-0000-000000000000",
	'transformVariable',
	'',
	'v_var = param.v_var;
smt = param.smt;

// create new variable
create object instance new_var of Variable;
relate new_var to smt across R457;
new_var.name = v_var.Name;

// link in scope
select one scope related by smt->CodeBlock[R450];
select any existing_var_in_scope related by scope->VariableInScope[R458] where ( selected.var_name == new_var.name );
if ( not_empty existing_var_in_scope )  // shadow variable of same name
  LOG::LogInfo( message:"warning: shadowing variable" );
  select one existing_var related by existing_var_in_scope->Variable[R458];
  unrelate existing_var from scope across R458 using existing_var_in_scope;
end if;
create object instance var_in_scope of VariableInScope;
relate new_var to scope across R458 using var_in_scope;

// link data type
select one var_dt related by v_var->S_DT[R848];
select one var_obj related by v_var->V_INT[R814]->O_OBJ[R818];
if ( empty var_obj )
  select one var_obj related by v_var->V_INS[R814]->O_OBJ[R819];
end if;
var_dt = ::getInstRefTypeForClass( s_dt:var_dt, o_obj:var_obj );
select many s_dims related by v_var->S_DIM[R849];
select one referring_comp related by smt->CodeBlock[R450]->InvocableInComponent[R4000]->ComponentDefinition[R4001];
var_type = TypeReference::getInstance( s_dt:var_dt, s_dims:s_dims, referring_comp:referring_comp );
relate var_type to new_var across R461;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("953bf602-54fb-42df-842d-b8e5e6f19fe8",
	"85cbd402-8906-4b60-9700-a81e119bef37",
	'v_var',
	"0e65b778-e815-4f26-b470-456b52561157",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("0e65b778-e815-4f26-b470-456b52561157",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Variable>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Value/Value.xtuml');
INSERT INTO S_SPARM
	VALUES ("a0768183-bea9-4ca2-95b9-595cd6261b39",
	"85cbd402-8906-4b60-9700-a81e119bef37",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"953bf602-54fb-42df-842d-b8e5e6f19fe8",
	'');
INSERT INTO PE_PE
	VALUES ("85cbd402-8906-4b60-9700-a81e119bef37",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("66cd847e-1baf-4368-98bd-abc7fffced6f",
	"00000000-0000-0000-0000-000000000000",
	'transformSelectionLink',
	'',
	'act_lnk = param.act_lnk;
smt = param.smt;
expr_number = param.expr_number;

// create expression
create object instance expr of Expression;
relate expr to smt across R775;
expr.expression_number = expr_number;

// link type
select one o_obj related by act_lnk->O_OBJ[R678];
select any irdt related by o_obj->S_IRDT[R123] where ( ( selected.isSet and ::act_lnkGetMult( act_lnk:act_lnk ) == Mult::MANY ) or ( not selected.isSet and ::act_lnkGetMult( act_lnk:act_lnk ) == Mult::ONE ) );
select one s_dt related by irdt->S_DT[R17];
if ( empty s_dt )
  // TODO bad
end if;
select many s_dims from instances of S_DIM where false;
select one referring_comp related by smt->CodeBlock[R450]->InvocableInComponent[R4000]->ComponentDefinition[R4001];
type = TypeReference::getInstance( s_dt:s_dt, s_dims:s_dims, referring_comp:referring_comp );
relate type to expr across R795;

// create select expression
create object instance sel of SelectExpr;
relate sel to expr across R776;
create object instance sel_rel of SelectRelated;
relate sel_rel to sel across R789;

// transform the previous link
select one prev_lnk related by act_lnk->ACT_LNK[R604.''succeeds''];
select any base_class from instances of Class where false;
if ( not_empty prev_lnk )
  ::transformSelectionLink( act_lnk:prev_lnk, expr_number:expr_number + ".1", smt:smt );
  select any prev_lnk_expr related by smt->Expression[R775] where ( selected.expression_number == expr_number + ".1" );
  relate prev_lnk_expr to sel_rel across R791;
  select one base_class related by prev_lnk->O_OBJ[R678]->Class[R409];
else
  select one base_val related by act_lnk->ACT_SEL[R637]->V_VAL[R613];
  ::transformExpression( v_val:base_val, expr_number:expr_number + ".1", smt:smt );
  select any base_expr related by smt->Expression[R775] where ( selected.expression_number == expr_number + ".1" );
  relate base_expr to sel_rel across R791;
  select one base_class related by base_val->V_IRF[R801]->V_VAR[R808]->V_INT[R814]->O_OBJ[R818]->Class[R409];
  if ( empty base_class )
    select one base_class related by base_val->V_ISR[R801]->V_VAR[R809]->V_INS[R814]->O_OBJ[R819]->Class[R409];
  end if;
end if;

// get the selector
select one r_rel related by act_lnk->R_REL[R681];
select one target_class related by o_obj->Class[R409];
phrase = C_UTIL::stripTics( s:act_lnk.Rel_Phrase );
if ( "" == phrase ) // if the phrase is not included, may need to get the phrase for getting the selector
  select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                 selected.form_name == target_class.name and
                                                                 selected.part_name == base_class.name ); // if no phrase was included, the target and base class must be different
  if ( not_empty relationship )
    phrase = relationship.form_phrase;
  else
    select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                   selected.form_name == base_class.name and
                                                                   selected.part_name == target_class.name );
    if ( not_empty relationship )
      phrase = relationship.part_phrase;
    end if;
  end if;
end if;
selector_name = "R" + STRING::itoa( i:r_rel.Numb ) + "_";
if ( "" != phrase )
  selector_name = selector_name + T::sub( format:"_", s:phrase ) + "_";
end if;
selector_name = selector_name + target_class.name;
select any selector related by base_class->InstanceSelector[R442]->Selector[R445] where ( selected.name == selector_name );
if ( empty selector )
  select one component related by smt->CodeBlock[R450]->InvocableInComponent[R4000]->ComponentDefinition[R4001];
  classInComp = ClassInComponent::get( obj:base_class, component:component );
  select any selector related by classInComp->ClassSet[R406]->SetSelector[R444]->Selector[R445] where ( selected.name == selector_name );
end if;
if ( not_empty selector )
  relate selector to sel_rel across R797;
else
  // TODO bad
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2ba68ecf-32d2-466e-bb9a-4d61abfd64fd",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'act_lnk',
	"bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("bcbe8755-e8ea-4d2b-9f81-529c5437c084",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Chain Link>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Selection/Selection.xtuml');
INSERT INTO S_SPARM
	VALUES ("cb909a0f-1538-4a1c-bf9b-480f132d9279",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'expr_number',
	"ba5eda7a-def5-0000-0000-000000000004",
	0,
	'',
	"2ba68ecf-32d2-466e-bb9a-4d61abfd64fd",
	'');
INSERT INTO S_SPARM
	VALUES ("3d367fc8-3174-4399-b90f-e7160cc99484",
	"66cd847e-1baf-4368-98bd-abc7fffced6f",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"cb909a0f-1538-4a1c-bf9b-480f132d9279",
	'');
INSERT INTO PE_PE
	VALUES ("66cd847e-1baf-4368-98bd-abc7fffced6f",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("9887c09e-f8cb-4d54-9f3d-44f6d220145c",
	"00000000-0000-0000-0000-000000000000",
	'resloveVariableFinalizations',
	'',
	'invocable = param.invocable;

select many affected_smts from instances of Statement where false;

select many where_clauses from instances of WhereExpr where ( selected.parent_name == invocable.parent_name and
                                                              selected.parent_package == invocable.parent_package and
                                                              selected.body_name == invocable.name );
for each where_clause in where_clauses
  select one where_expr related by where_clause->Expression[R796];
  select many var_refs from instances of VariableReference where ( selected.parent_name == invocable.parent_name and
                                                                   selected.parent_package == invocable.parent_package and
                                                                   selected.body_name == invocable.name and
                                                                   selected.block_number == where_expr.block_number and
                                                                   selected.statement_number == where_expr.statement_number and
                                                                   0 == STRING::indexof( haystack:selected.expression_number, needle:where_expr.expression_number ) );
  for each var_ref in var_refs
    select many var_assignments related by var_ref->Variable[R782]->VariableReference[R782]->Expression[R776]->BinaryOperation[R779] where ( selected.operator == "=" );
    select one for_smt related by var_ref->Variable[R782]->ForSmt[R459];
    if ( cardinality var_assignments > 1 or not_empty for_smt ) // the variable needs to be finalized because it is assigned later
      select one smt related by var_ref->Expression[R776]->Statement[R775];
      select one var related by var_ref->Variable[R782];
      select any finalization related by smt->Finalization[R485] where ( selected.var_block_number == var.block_number and selected.var_name == var.name );
      if ( empty finalization )
        create object instance finalization of Finalization;
        relate smt to var across R485 using finalization;
        affected_smts = affected_smts + smt;
      end if;
    end if;
  end for;
end for;

for each smt in affected_smts
  select many finalizations related by smt->Finalization[R485];
  for each finalization in finalizations
    finalization.render();
  end for;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("35e31fca-5f9c-4c6c-82d5-468f8f4ef569",
	"9887c09e-f8cb-4d54-9f3d-44f6d220145c",
	'invocable',
	"3ab44839-4426-4754-b12a-0a00ce4dae1a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("3ab44839-4426-4754-b12a-0a00ce4dae1a",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Invocable Object>',
	'',
	'',
	'../../architecture/invocable/invocable.xtuml');
INSERT INTO PE_PE
	VALUES ("9887c09e-f8cb-4d54-9f3d-44f6d220145c",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	"00000000-0000-0000-0000-000000000000",
	'resolveArrayDeclaration',
	'',
	'smt = param.smt;
select one block related by smt->CodeBlock[R450];
indent = ::getIndent( tab_depth:block.tab_depth + 1 );

select many declared_vars related by smt->Variable[R457];
for each declared_var in declared_vars
  select many var_refs related by declared_var->VariableReference[R782] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
  select any earliest_var_ref from instances of VariableReference where false;
  for each var_ref in var_refs
    if ( empty earliest_var_ref or var_ref.expression_number < earliest_var_ref.expression_number )
      earliest_var_ref = var_ref;
    end if;
  end for;
  if ( not_empty earliest_var_ref )
    earliest_var_ref.declaration = true;
  end if;
end for;

select many array_vars related by smt->Expression[R775]->ArrayElementReference[R776]->Expression[R3900]->VariableReference[R776]->Variable[R782];
for each array_var in array_vars
  if ( smt.block_number == array_var.block_number and smt.statement_number == array_var.statement_number ) // variable was declared in this statement
    select many array_refs related by array_var->VariableReference[R782]->Expression[R776]->ArrayElementReference[R3900] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
    select any earliest_array_ref from instances of ArrayElementReference where false;
    for each array_ref in array_refs
      if ( empty earliest_array_ref or array_ref.expression_number < earliest_array_ref.expression_number )
        earliest_array_ref = array_ref;
      end if;
    end for;
    select one var_type related by array_var->TypeReference[R461];
    select one array_index related by earliest_array_ref->Expression[R3901];;
    T::push_buffer();
    array_index.render();
    smt.prefix = smt.prefix + indent + var_type.type_reference_name + " " + array_var.name + " = new " + var_type.type_name + "[" + T::body() + "+1];\n";
    T::pop_buffer();
    // no longer need to mark the first reference as a declaration
    select many var_refs related by array_var->VariableReference[R782] where ( selected.block_number == smt.block_number and selected.statement_number == smt.statement_number );
    for each var_ref in var_refs
      var_ref.declaration = false;
    end for;
  end if;
end for;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("23c66a56-7518-4f4b-b8bc-15f4d63d9d19",
	"c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	'smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO PE_PE
	VALUES ("c0600fb5-e569-49ff-a405-f8ca7f1d1236",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("56579a04-8946-4a1f-ac3e-d51efab8a618",
	"00000000-0000-0000-0000-000000000000",
	'transformEventSpecificationStatement',
	'',
	'e_ess = param.e_ess;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by e_ess->ACT_SMT[R603];
select one referring_comp related by block->InvocableInComponent[R4000]->ComponentDefinition[R4001];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

select one e_ges related by e_ess->E_GES[R701];
if ( not_empty e_ges )

  // transform generate statements
  select one evt related by e_ges->E_GSME[R703]->SM_EVT[R707]->Event[R4759];
  select one target_v_var related by e_ges->E_GSME[R703]->E_GEN[R705]->V_VAR[R712];
  if ( empty target_v_var )
    // TODO bad
    LOG::LogFailure( message:"Generation to class and generation to creator not supported." );
  end if;
  
  // create generate statement
  create object instance gen_smt of Generate;
  relate gen_smt to smt across R451;
  
  // create the event expression
  create object instance evt_expr of Expression;
  relate evt_expr to smt across R775;
  evt_expr.expression_number = "1";
  evt_type_ref = TypeReference::getBuiltinTypeReference( name:"EventHandle" );
  relate evt_type_ref to evt_expr across R795;
  relate evt_expr to gen_smt across R486;
  // create event creation
  create object instance evt_cr of EventCreation;
  relate evt_cr to evt_expr across R776;
  evt_cr.to_self = false;
  // create the event invocation
  create object instance invoc_expr of Expression;
  relate invoc_expr to smt across R775;
  invoc_expr.expression_number = evt_expr.expression_number + ".1";
  relate evt_type_ref to invoc_expr across R795;
  relate invoc_expr to evt_cr across R3903;
  create object instance invoc of Invocation;
  relate invoc to invoc_expr across R776;
  select one evt_invocable related by evt->InvocableObject[R427];
  relate invoc to evt_invocable across R792;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = invoc_expr.expression_number + ".1";
  select one obj related by evt->StateMachine[R4752]->ClassInComponent[R4750]->Class[R408];
  select one inst_type related by obj->Type[R407];
  select many s_dims from instances of S_DIM where false;
  inst_type_ref = TypeReference::getInstanceFromType( type:inst_type, s_dims:s_dims );
  relate inst_type_ref to expr2 across R795;
  // create named reference
  create object instance named_ref of NamedReference;
  relate named_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  named_ref.name = obj.name + "Impl";
  // transform actual parameters
  select many v_pars related by e_ess->V_PAR[R700];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:invoc_expr.expression_number, base_num:2 );
  
  // create the target expression
  create object instance target_expr of Expression;
  relate target_expr to smt across R775;
  target_expr.expression_number = evt_expr.expression_number + ".2";
  relate evt_cr to target_expr across R3902;
  select one target_s_dt related by target_v_var->S_DT[R848];
  select one target_obj related by target_v_var->V_INT[R814]->O_OBJ[R818];
  target_s_dt = ::getInstRefTypeForClass( s_dt:target_s_dt, o_obj:target_obj );
  target_type = TypeReference::getInstance( s_dt:target_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate target_type to target_expr across R795;
  select any target_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == target_v_var.Name );
  if ( not_empty target_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate target_var to var_ref across R782;
    relate var_ref to target_expr across R776;
    select one type related by target_expr->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == target_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to target_expr across R776;
    self_ref.name = "self()";
    evt_cr.to_self = true;
  else
    // TODO bad
  end if;

  // add import for class
  ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:obj.package + ".impl." + obj.name + "Impl", type:ImportType::IMPL );

else

  // transform create event statements
  select one e_ces related by e_ess->E_CES[R701];
  select one evt related by e_ces->E_CSME[R702]->SM_EVT[R706]->Event[R4759];
  select one result_v_var related by e_ces->V_VAR[R710];
  select one target_v_var related by e_ces->E_CSME[R702]->E_CEI[R704]->V_VAR[R711];
  if ( empty target_v_var )
    // TODO bad
    LOG::LogFailure( message:"Event creation to class and event creation to creator not supported." );
  end if;
  
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  evt_type_ref = TypeReference::getBuiltinTypeReference( name:"EventHandle" );
  relate evt_type_ref to expr across R795;
  // create binary operation and assignment expression
  create object instance binop of BinaryOperation;
  relate binop to expr across R776;
  binop.operator = "=";
  binop.invocation = false;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create left operand
  create object instance l_op of Expression;
  relate l_op to smt across R775;
  l_op.expression_number = "1.1";
  relate evt_type_ref to l_op across R795;
  select any existing_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == result_v_var.Name );
  if ( empty existing_var ) // cannot declare two variables of the same name in the same scope
    ::transformVariable( v_var:result_v_var, smt:smt );
  end if;
  select any result_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == result_v_var.Name );
  create object instance var_ref of VariableReference;
  relate result_var to var_ref across R782;
  relate var_ref to l_op across R776;
  relate l_op to binop across R779;
  select one type related by l_op->TypeReference[R795]->Type[R3800];
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  // create right operand
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate evt_type_ref to r_op across R795;
  relate r_op to binop across R778;
  // create event creation
  create object instance evt_cr of EventCreation;
  relate evt_cr to r_op across R776;
  evt_cr.to_self = false;
  // create the event invocation
  create object instance invoc_expr of Expression;
  relate invoc_expr to smt across R775;
  invoc_expr.expression_number = r_op.expression_number + ".1";
  relate evt_type_ref to invoc_expr across R795;
  relate invoc_expr to evt_cr across R3903;
  create object instance invoc of Invocation;
  relate invoc to invoc_expr across R776;
  select one evt_invocable related by evt->InvocableObject[R427];
  relate invoc to evt_invocable across R792;
  // create named reference expression
  create object instance expr2 of Expression;
  relate expr2 to smt across R775;
  expr2.expression_number = invoc_expr.expression_number + ".1";
  select one obj related by evt->StateMachine[R4752]->ClassInComponent[R4750]->Class[R408];
  select one inst_type related by obj->Type[R407];
  select many s_dims from instances of S_DIM where false;
  inst_type_ref = TypeReference::getInstanceFromType( type:inst_type, s_dims:s_dims );
  relate inst_type_ref to expr2 across R795;
  // create named reference
  create object instance named_ref of NamedReference;
  relate named_ref to expr2 across R776;
  relate expr2 to invoc across R798;
  named_ref.name = obj.name + "Impl";
  // transform actual parameters
  select many v_pars related by e_ess->V_PAR[R700];
  ::transformActualParameters( invocation:invoc, v_pars:v_pars, expr_number:invoc_expr.expression_number, base_num:2 );
  
  // create the target expression
  create object instance target_expr of Expression;
  relate target_expr to smt across R775;
  target_expr.expression_number = r_op.expression_number + ".2";
  relate evt_cr to target_expr across R3902;
  select one target_s_dt related by target_v_var->S_DT[R848];
  select one target_obj related by target_v_var->V_INT[R814]->O_OBJ[R818];
  target_s_dt = ::getInstRefTypeForClass( s_dt:target_s_dt, o_obj:target_obj );
  target_type = TypeReference::getInstance( s_dt:target_s_dt, s_dims:s_dims, referring_comp:referring_comp );
  relate target_type to target_expr across R795;
  select any target_var related by smt->CodeBlock[R450]->Variable[R458] where ( selected.name == target_v_var.Name );
  if ( not_empty target_var ) // cannot declare two variables of the same name in the same scope
    create object instance var_ref of VariableReference;
    relate target_var to var_ref across R782;
    relate var_ref to target_expr across R776;
    select one type related by target_expr->TypeReference[R795]->Type[R3800];
    ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:type, type:ImportType::IMPL );
  elif ( "self" == target_v_var.Name )
    // create named reference
    create object instance self_ref of NamedReference;
    relate self_ref to target_expr across R776;
    self_ref.name = "self()";
    evt_cr.to_self = true;
  else
    // TODO bad
  end if;
  
  // add import for class
  ::addStringToImports( file: ::getFileForStatement( smt:smt ), s:obj.package + ".impl." + obj.name + "Impl", type:ImportType::IMPL );

end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("987c4060-b7f5-4209-a28f-a21665d23a52",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'e_ess',
	"a885b904-2a7c-42ce-bc53-db13d709ae6f",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("a885b904-2a7c-42ce-bc53-db13d709ae6f",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Event Specification Statement>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Event/Event.xtuml');
INSERT INTO S_SPARM
	VALUES ("81098ce2-32c5-4ea7-95de-124f52bad3bb",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"987c4060-b7f5-4209-a28f-a21665d23a52",
	'');
INSERT INTO S_SPARM
	VALUES ("9eb8d78c-fe64-46fb-84ea-d1dcd014404f",
	"56579a04-8946-4a1f-ac3e-d51efab8a618",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"81098ce2-32c5-4ea7-95de-124f52bad3bb",
	'');
INSERT INTO PE_PE
	VALUES ("56579a04-8946-4a1f-ac3e-d51efab8a618",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("72fc322d-1724-4725-9fad-9b8215ab0fd3",
	"00000000-0000-0000-0000-000000000000",
	'transformGeneratePreexistingEventStatement',
	'',
	'e_gpr = param.e_gpr;
block = param.block;
prev_smt = param.prev_smt;
select one act_smt related by e_gpr->ACT_SMT[R603];

// create a statement
create object instance smt of Statement;
relate smt to block across R450;
if ( not_empty prev_smt )
  smt.statement_number = STRING::itoa( i:STRING::atoi( s:prev_smt.statement_number ) + 1 );
  relate smt to prev_smt across R477.''executes after'';
else
  smt.statement_number = "1";
end if;
select one body related by block->InvocableInComponent[R4000]->InvocableObject[R4001];
smt.oal = ::getOalStatement( body:body.oal, line_num:act_smt.LineNumber );

// create generate statement
create object instance gen_smt of Generate;
relate gen_smt to smt across R451;

// create the event expression
select one evt_v_val related by e_gpr->V_VAL[R714];
::transformExpression( v_val:evt_v_val, expr_number:"1", smt:smt );
select any evt_expr related by smt->Expression[R775] where ( selected.expression_number == "1" );
relate evt_expr to gen_smt across R486;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("2c9f8764-5e1e-4a13-a7b8-9d7d8783ea73",
	"72fc322d-1724-4725-9fad-9b8215ab0fd3",
	'e_gpr',
	"13c04771-67be-42a3-a789-b68f0f9c6f54",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("13c04771-67be-42a3-a789-b68f0f9c6f54",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Generate Preexisting Event>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Event/Event.xtuml');
INSERT INTO S_SPARM
	VALUES ("f3781110-14d6-422a-9c62-6f7d5ac63407",
	"72fc322d-1724-4725-9fad-9b8215ab0fd3",
	'block',
	"60d4da0e-4cbe-4620-8c16-4e1dba1c6b8d",
	0,
	'',
	"2c9f8764-5e1e-4a13-a7b8-9d7d8783ea73",
	'');
INSERT INTO S_SPARM
	VALUES ("00a11383-e402-4704-9854-dc4611a6a493",
	"72fc322d-1724-4725-9fad-9b8215ab0fd3",
	'prev_smt',
	"b586ec7e-41fe-4d50-9cf3-27b173e9848a",
	0,
	'',
	"f3781110-14d6-422a-9c62-6f7d5ac63407",
	'');
INSERT INTO PE_PE
	VALUES ("72fc322d-1724-4725-9fad-9b8215ab0fd3",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	"00000000-0000-0000-0000-000000000000",
	'transformDeferral',
	'',
	'invocableInComp = param.invocableInComp;
deferral = param.deferral;

select one invocable related by invocableInComp->InvocableObject[R4001];
select one o_tfr related by deferral->O_TFR[R126];
select one type related by invocable->TypeReference[R428];
returns_value = "void" != type.type_name;
select many subtypes related by deferral->R_REL[R126]->R_SUBSUP[R206]->R_SUB[R213]->R_RGO[R205]->R_OIR[R203]->O_OBJ[R201];

// create code block
create object instance block of CodeBlock;
block.top_level = true;
block.tab_depth = 1;
relate block to invocableInComp across R4000;
block.block_number = "1";

// create an invocation for each subtype
for each subtype in subtypes

  // create a select statement
  create object instance smt of Statement;
  relate smt to block across R450;
  smt.statement_number = "1";
  smt.oal = "";
  // create expression as statement
  create object instance eas of ExpressionAsStatement;
  relate eas to smt across R451;
  // create main expression
  create object instance expr of Expression;
  relate expr to smt across R775;
  expr.expression_number = "1";
  // create binary operation and assignment expression
  create object instance binop of BinaryOperation;
  relate binop to expr across R776;
  binop.operator = "=";
  binop.invocation = false;
  // relate expression to expression as statement
  relate eas to expr across R476;
  // create left operand
  create object instance l_op of Expression;
  relate l_op to smt across R775;
  l_op.expression_number = "1.1";
  select any subtype_invocable related by subtype->O_TFR[R115]->ACT_OPB[R696]->ACT_ACT[R698]->InvocableObject[R432] where (selected.name == invocable.name);
  target_invocable = subtype_invocable;
  if (empty subtype_invocable and deferral.required == 1)  // deferral is optional
    select any target_invocable related by invocable->Operation[R427]->Class[R416]->Operation[R416]->InvocableObject[R427] where (selected.name == "_supertype_" + invocable.name);
  elif (empty subtype_invocable and deferral.required != 1)
    LOG::LogFailure(message:"Could not find matching operation: " + invocable.name + " for subtype: " + subtype.Name);
  end if;
  select one select_class related by subtype->Class[R409];
  select one select_type_def related by select_class->Type[R407];
  select_type = TypeReference::getInstanceWithDimString(type:select_type_def, dims:"");
  relate select_type to l_op across R795;
  // create new variable
  create object instance select_var of Variable;
  relate select_var to smt across R457;
  select_var.name = T::sub(format:"l", s:select_class.name);
  // link in scope
  select one block related by smt->CodeBlock[R450];
  create object instance var_in_scope of VariableInScope;
  relate select_var to block across R458 using var_in_scope;
  // link data type
  relate select_type to select_var across R461;
  // create variable reference
  create object instance var_ref of VariableReference;
  var_ref.declaration = true;
  relate select_var to var_ref across R782;
  relate var_ref to l_op across R776;
  relate l_op to binop across R779;
  ::addTypeToImports( file: ::getFileForStatement( smt:smt ), type_to_import:select_type_def, type:ImportType::IMPL );
  // create right operand
  create object instance r_op of Expression;
  relate r_op to smt across R775;
  r_op.expression_number = "1.2";
  relate r_op to binop across R778;
  relate select_type to r_op across R795;
  // create select expression
  create object instance sel of SelectExpr;
  relate sel to r_op across R776;
  create object instance sel_rel of SelectRelated;
  relate sel_rel to sel across R789;
  // create named reference
  create object instance self_expr of Expression;
  relate self_expr to smt across R775;
  self_expr.expression_number = "1.2.1";
  select one self_class related by invocable->Operation[R427]->Class[R416];
  select one self_type_def related by self_class->Type[R407];
  self_type = TypeReference::getInstanceWithDimString(type:self_type_def, dims:"");
  relate self_type to self_expr across R795;
  create object instance self_ref of NamedReference;
  relate self_ref to self_expr across R776;
  self_ref.name = "self()";
  relate self_expr to sel_rel across R791;
  // get the selector
  select one r_rel related by deferral->R_REL[R126];
  select any relationship from instances of Relationship where ( selected.num == r_rel.Numb and
                                                                 selected.form_name == select_class.name and
                                                                 selected.part_name == self_class.name ); // if no phrase was included, the target and base class must be different
  selector_name = "R" + STRING::itoa( i:r_rel.Numb ) + "_is_a_" + select_class.name;
  select any selector related by self_class->InstanceSelector[R442]->Selector[R445] where ( selected.name == selector_name );
  if ( not_empty selector )
    relate selector to sel_rel across R797;
  else
    // TODO bad
  end if;
  // link select type to the main expression
  relate select_type to expr across R795;
  
  // create if statement
  create object instance smt2 of Statement;
  relate smt2 to block across R450;
  smt2.statement_number = "2";
  relate smt2 to smt across R477.''executes after'';
  smt2.oal = "";
  create object instance if_smt of IfSmt;
  relate if_smt to smt2 across R451;
  if_smt.is_else_if = false;
  // translate if expression
  create object instance if_expr of Expression;
  relate if_expr to smt2 across R775;
  if_expr.expression_number = "1";
  relate if_expr to if_smt across R471;
  // link type
  if_type = TypeReference::getBuiltinTypeReference(name:"boolean");
  relate if_type to if_expr across R795;
  // create the unary expression
  create object instance unary of UnaryOperation;
  relate unary to if_expr across R776;
  unary.operator = "!";
  unary.invocation = false;
  // create ''empty'' expression
  create object instance if_expr2 of Expression;
  relate if_expr2 to smt2 across R775;
  if_expr2.expression_number = "1.1";
  relate if_expr2 to unary across R777;
  relate if_type to if_expr2 across R795;
  create object instance unary2 of UnaryOperation;
  relate unary2 to if_expr2 across R776;
  unary2.operator = "isEmpty";
  unary2.invocation = true;
  // transform the operand expression
  create object instance op_expr of Expression;
  relate op_expr to smt2 across R775;
  op_expr.expression_number = "1.1.1";
  // link type
  relate select_type to op_expr across R795;
  // create variable reference
  create object instance op_var_ref of VariableReference;
  relate select_var to op_var_ref across R782;
  relate op_var_ref to op_expr across R776;
  relate op_expr to unary2 across R777;
  // create then block
  then_block_number = ::getNextBlockNumber(upper_block:block);
  create object instance then_block of CodeBlock;
  then_block.top_level = false;
  then_block.tab_depth = block.tab_depth + 1;
  relate then_block to invocableInComp across R4000;
  then_block.block_number = then_block_number;
  relate then_block to if_smt across R453;
  // create invocation
  create object instance smt3 of Statement;
  relate smt3 to then_block across R450;
  smt3.statement_number = "1";
  smt3.oal = "";
  // create invocation expression
  create object instance invoc_expr of Expression;
  relate invoc_expr to smt3 across R775;
  invoc_expr.expression_number = "1";
  // link type
  void_type = TypeReference::getBuiltinTypeReference(name:"void");
  relate void_type to invoc_expr across R795;
  // create invocation
  create object instance invoc of Invocation;
  relate invoc to invoc_expr across R776;
  relate invoc to target_invocable across R792;
  if (empty subtype_invocable and deferral.required == 1)  // deferral is optional
    // create named reference
    create object instance self_expr of Expression;
    relate self_expr to smt3 across R775;
    self_expr.expression_number = "1.1";
    relate self_type to self_expr across R795;
    relate self_expr to invoc across R798;
    create object instance self_ref of NamedReference;
    relate self_ref to self_expr across R776;
    self_ref.name = "self()";
  else
    // create variable reference expression
    create object instance invoc_expr2 of Expression;
    relate invoc_expr2 to smt3 across R775;
    invoc_expr2.expression_number = "1.1";
    relate invoc_expr2 to invoc across R798;
    relate select_type to invoc_expr2 across R795;
    create object instance invoc_var_ref of VariableReference;
    relate select_var to invoc_var_ref across R782;
    relate invoc_var_ref to invoc_expr2 across R776;
  end if;
  // transform actual parameters
  base_num = 2;
  select any prev_actual_parameter from instances of ActualParameter where false;
  select any formal_parameter related by target_invocable->FormalParameter[R429];
  select one prev_formal_parameter related by formal_parameter->FormalParameter[R404.''follows''];
  while (not_empty prev_formal_parameter)
    formal_parameter = prev_formal_parameter;
    select one prev_formal_parameter related by formal_parameter->FormalParameter[R404.''follows''];
  end while;
  while (not_empty formal_parameter)
    // create parameter reference
    select any referenced_formal_parameter related by invocable->FormalParameter[R429] where (selected.name == formal_parameter.name);
    create object instance param_ref_expr of Expression;
    relate param_ref_expr to smt3 across R775;
    param_ref_expr.expression_number = "1." + STRING::itoa(i:base_num);
    select one param_type related by formal_parameter->TypeReference[R431];
    relate param_type to param_ref_expr across R795;
    create object instance param_ref of ParameterReference;
    relate param_ref to param_ref_expr across R776;
    relate referenced_formal_parameter to param_ref across R781;
    // create actual parameter
    create object instance act_parm of ActualParameter;
    relate act_parm to param_ref_expr across R794;
    relate invoc to act_parm across R793;
    relate formal_parameter to act_parm across R3904;
    if (not_empty prev_actual_parameter)
      relate prev_actual_parameter to act_parm across R3905.''precedes'';
    end if;
    base_num = base_num + 1;
    prev_actual_parameter = act_parm;
    select one formal_parameter related by formal_parameter->FormalParameter[R404.''precedes''];
  end while;
  if (returns_value)
    // create return statement
    create object instance ret_smt of ReturnSmt;
    relate ret_smt to smt3 across R451;
    relate invoc_expr to ret_smt across R473;
  else
    // create expression as statement
    create object instance eas2 of ExpressionAsStatement;
    relate eas2 to smt3 across R451;
    relate invoc_expr to eas2 across R476;
  end if;
  // create else block
  else_block_number = ::getNextBlockNumber(upper_block:block);
  create object instance else_block of CodeBlock;
  else_block.top_level = false;
  else_block.tab_depth = block.tab_depth + 1;
  relate else_block to invocableInComp across R4000;
  else_block.block_number = else_block_number;
  relate else_block to if_smt across R454;
  
  block = else_block;

end for;

// add an exception if no subtypes match
create object instance smt4 of Statement;
relate smt4 to block across R450;
smt4.statement_number = "1";
smt4.oal = "";
// create named references for thows
create object instance throws_expr of Expression;
relate throws_expr to smt4 across R775;
throws_expr.expression_number = "1.2.1";
void_type = TypeReference::getBuiltinTypeReference(name:"void");
relate void_type to throws_expr across R795;
create object instance throws_ref of NamedReference;
relate throws_ref to throws_expr across R776;
throws_ref.name = "throw new XtumlException(" + STRING::quote() + "No subtype selected" + STRING::quote() + ")";
// create expression as statement
create object instance eas3 of ExpressionAsStatement;
relate eas3 to smt4 across R451;
relate throws_expr to eas3 across R476;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("29cc6813-0b74-4cfe-899d-8def3337814c",
	"56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	'deferral',
	"b5231088-af9f-42ab-b08b-e1578453a954",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("b5231088-af9f-42ab-b08b-e1578453a954",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Deferral>',
	'',
	'',
	'../../../../../mcooa/models/mcooa/ooaofooa/Subsystem/Subsystem.xtuml');
INSERT INTO S_SPARM
	VALUES ("e1e11b27-7829-4ff3-a0e0-eb0a79054e63",
	"56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	'invocableInComp',
	"15275e26-b9be-4723-81b7-a823b206a5bb",
	0,
	'',
	"29cc6813-0b74-4cfe-899d-8def3337814c",
	'');
INSERT INTO PE_PE
	VALUES ("56dd991f-2c16-4b8a-9f82-b3dd99c25611",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO S_SYNC
	VALUES ("b224dbc7-8ee3-42cf-9aea-12a3211e411b",
	"00000000-0000-0000-0000-000000000000",
	'resolveSortedSelection',
	'',
	'where_expr = param.where_expr;

// check if there is an invocation of a SORT bridge in the where expression
select one where_clause_expr related by where_expr->Expression[R796];
select any invoc related by where_clause_expr->Statement[R775]->Expression[R775]->Invocation[R776] where 
  (selected.invoked_parent_name == "SORT" and STRING::indexof(haystack:selected.expression_number, needle:where_clause_expr.expression_number) == 0);
if (not_empty invoc)
  sort_type = SortType::NONE;
  if (invoc.invoked_name == "ascending")
    sort_type = SortType::ASCENDING;
  elif (invoc.invoked_name == "descending")
    sort_type = SortType::DESCENDING;
  end if;
  // select the sort attribute
  select any attr_parm related by invoc->ActualParameter[R793] where (selected.param_name == "p_attr");
  select one literal related by attr_parm->Expression[R794]->Literal[R776];
  if (not_empty literal)
    select one cls related by where_expr->Expression[R776]->TypeReference[R795]->Type[R3800]->Class[R407];
    if (empty cls)
      select one cls related by where_expr->Expression[R776]->TypeReference[R795]->Type[R3800]->ClassSet[R407]->ClassInComponent[R406]->Class[R408];
    end if;
    select any attr related by cls->Attribute[R410] where (selected.name == "m_" + literal.value or selected.name == "ref_" + literal.value);
    if (not_empty attr)
      // relate attribute to where expression
      where_expr.sorted = sort_type;
      relate attr to where_expr across R3906;
      // add util import if necessary
      select one attr_type related by attr->TypeReference[R424]->Type[R3800];
      if (attr_type.primitive())
        select one smt related by where_expr->Expression[R776]->Statement[R775];
        file = ::getFileForStatement(smt:smt);
        if ("boolean" == attr_type.name)
          ::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.BooleanUtil", type:ImportType::BOTH);
        elif ("int" == attr_type.name)
          ::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.IntegerUtil", type:ImportType::BOTH);
        elif ("double" == attr_type.name)
          ::addStringToImports(file:file, s:"io.ciera.runtime.summit.types.RealUtil", type:ImportType::BOTH);
        end if;
      end if;
    else
      LOG::LogFailure(message:"Could not find attribute ''" + literal.value + "'' in class ''" + cls.name + "'' for sorting");
    end if;
  else
    LOG::LogFailure(message:"SORT bridges require literal string parameters");
  end if;
end if;',
	"ba5eda7a-def5-0000-0000-000000000000",
	1,
	'',
	0,
	0);
INSERT INTO S_SPARM
	VALUES ("040b9859-feb4-47d6-b987-e4df27fafd0d",
	"b224dbc7-8ee3-42cf-9aea-12a3211e411b",
	'where_expr',
	"8a75e82a-db3d-4bdb-aba6-6de4e88a243e",
	0,
	'',
	"00000000-0000-0000-0000-000000000000",
	'');
INSERT INTO S_DT_PROXY
	VALUES ("8a75e82a-db3d-4bdb-aba6-6de4e88a243e",
	"00000000-0000-0000-0000-000000000000",
	'inst_ref<Where>',
	'',
	'',
	'../../architecture/expression/expression.xtuml');
INSERT INTO PE_PE
	VALUES ("b224dbc7-8ee3-42cf-9aea-12a3211e411b",
	1,
	"1aa08c2b-b96c-4c66-8c25-c079950eef10",
	"00000000-0000-0000-0000-000000000000",
	1);
INSERT INTO PE_PE
	VALUES ("1aa08c2b-b96c-4c66-8c25-c079950eef10",
	1,
	"302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("302d02ea-52a7-489d-a14b-18b29f3c8d86",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	"9092a4a9-91f5-4e59-984b-3ca72917240d",
	'transform',
	'',
	0,
	'../transform.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("9092a4a9-91f5-4e59-984b-3ca72917240d",
	'tool-core',
	1,
	'../../tool-core.xtuml');
