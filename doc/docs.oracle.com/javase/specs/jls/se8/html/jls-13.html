
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;13.&nbsp;Binary Compatibility</title>
      <link rel="stylesheet" type="text/css" href="https://docs.oracle.com/javase/specs/javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Language Specification">
      <link rel="up" href="index.html" title="The Java&reg; Language Specification">
      <link rel="prev" href="jls-12.html" title="Chapter&nbsp;12.&nbsp;Execution">
      <link rel="next" href="jls-14.html" title="Chapter&nbsp;14.&nbsp;Blocks and Statements">
      <link rel="copyright" href="jls-0-front.html" title="Legal Notice">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="https://docs.oracle.com/javase/webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="https://docs.oracle.com/javase/8/docs/">Java SE</a> &gt; <a href="https://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Language Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;13.&nbsp;Binary Compatibility</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jls-12.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jls-14.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;13.&nbsp;Binary Compatibility">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jls-13"></a>Chapter&nbsp;13.&nbsp;Binary Compatibility
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jls-13.html#jls-13.1">13.1. The Form of a Binary</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.2">13.2. What Binary Compatibility Is and Is Not</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.3">13.3. Evolution of Packages</a></span></dt>
               <dt><span class="section"><a href="jls-13.html#jls-13.4">13.4. Evolution of Classes</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.1">13.4.1. <code class="literal">abstract</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.2">13.4.2. <code class="literal">final</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.3">13.4.3. <code class="literal">public</code> Classes</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.4">13.4.4. Superclasses and Superinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.5">13.4.5. Class Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.6">13.4.6. Class Body and Member Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.7">13.4.7. Access to Members and Constructors</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.8">13.4.8. Field Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.9">13.4.9. <code class="literal">final</code> Fields and <code class="literal">static</code> Constant Variables</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.10">13.4.10. <code class="literal">static</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.11">13.4.11. <code class="literal">transient</code> Fields</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.12">13.4.12. Method and Constructor Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.13">13.4.13. Method and Constructor Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.14">13.4.14. Method and Constructor Formal Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.15">13.4.15. Method Result Type</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.16">13.4.16. <code class="literal">abstract</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.17">13.4.17. <code class="literal">final</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.18">13.4.18. <code class="literal">native</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.19">13.4.19. <code class="literal">static</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.20">13.4.20. <code class="literal">synchronized</code> Methods</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.21">13.4.21. Method and Constructor Throws</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.22">13.4.22. Method and Constructor Body</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.23">13.4.23. Method and Constructor Overloading</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.24">13.4.24. Method Overriding</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.25">13.4.25. Static Initializers</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.4.26">13.4.26. Evolution of Enums</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jls-13.html#jls-13.5">13.5. Evolution of Interfaces</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.1">13.5.1. <code class="literal">public</code> Interfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.2">13.5.2. Superinterfaces</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.3">13.5.3. Interface Members</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.4">13.5.4. Interface Type Parameters</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.5">13.5.5. Field Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.6">13.5.6. Interface Method Declarations</a></span></dt>
                     <dt><span class="section"><a href="jls-13.html#jls-13.5.7">13.5.7. Evolution of Annotation Types</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <p class="norm"><a name="jls-13-100"></a>Development tools for the
            Java programming language should support automatic recompilation as necessary
            whenever source code is available. Particular implementations may also
            store the source and binary of types in a versioning database and
            implement a <code class="literal">ClassLoader</code> that uses integrity mechanisms of the
            database to prevent linkage errors by providing binary-compatible
            versions of types to clients.
         </p>
         <p class="norm"><a name="jls-13-110"></a>Developers of packages and
            classes that are to be widely distributed face a different set of
            problems. In the Internet, which is our favorite example of a widely
            distributed system, it is often impractical or impossible to
            automatically recompile the pre-existing binaries that directly or
            indirectly depend on a type that is to be changed. Instead, this
            specification defines a set of changes that developers are permitted
            to make to a package or to a class or interface type while preserving
            (not breaking) compatibility with pre-existing binaries.
         </p>
         <p class="norm"><a name="jls-13-120"></a>Within the framework
            of <em class="citetitle">Release-to-Release Binary Compatibility in
               SOM</em> (Forman, Conner, Danforth, and
            Raper, <em class="citetitle">Proceedings of OOPSLA '95</em>), Java programming language
            binaries are binary compatible under all relevant transformations that
            the authors identify (with some caveats with respect to the addition
            of instance variables). Using their scheme, here is a list of some
            important binary compatible changes that the Java programming language
            supports:
         </p>
         <div class="norm">
            <ul class="norm" type="disc">
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-A"></a>
                           Reimplementing existing methods, constructors, and initializers
                           to improve performance.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-B"></a>
                           Changing methods or constructors to return values on inputs for
                           which they previously either threw exceptions that normally
                           should not occur or failed by going into an infinite loop or
                           causing a deadlock.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-C"></a>
                           Adding new fields, methods, or constructors to an existing class
                           or interface.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-D"></a>
                           Deleting <code class="literal">private</code> fields, methods, or constructors of a
                           class.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-E"></a>
                           When an entire package is updated, deleting package access
                           fields, methods, or constructors of classes and interfaces in
                           the package.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-F"></a>
                           Reordering the fields, methods, or constructors in an existing
                           type declaration.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-G"></a>
                           Moving a method upward in the class hierarchy.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-H"></a>
                           Reordering the list of direct superinterfaces of a class or
                           interface.
                  </p>
               </li>
               <li class="listitem">
                  <p class="norm"><a name="jls-13-120-I"></a>
                           Inserting new class or interface types in the type
                           hierarchy.
                  </p>
               </li>
            </ul>
         </div>
         <p class="norm"><a name="jls-13-200"></a>This chapter specifies minimum
            standards for binary compatibility guaranteed by all
            implementations. The Java programming language guarantees compatibility when binaries
            of classes and interfaces are mixed that are not known to be from
            compatible sources, but whose sources have been modified in the
            compatible ways described here. Note that we are discussing
            compatibility between releases of an application. A discussion of
            compatibility among releases of the Java SE platform is beyond the scope of
            this chapter.
         </p>
         <p class="norm"><a name="jls-13-210"></a>We encourage development systems
            to provide facilities that alert developers to the impact of changes
            on pre-existing binaries that cannot be recompiled.
         </p>
         <p class="norm"><a name="jls-13-220"></a>This chapter first specifies
            some properties that any binary format for the Java programming language must have
            (<a class="xref" href="jls-13.html#jls-13.1" title="13.1.&nbsp;The Form of a Binary">&sect;13.1</a>). It next defines binary compatibility,
            explaining what it is and what it is not
            (<a class="xref" href="jls-13.html#jls-13.2" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">&sect;13.2</a>). It finally enumerates a large set of
            possible changes to packages (<a class="xref" href="jls-13.html#jls-13.3" title="13.3.&nbsp;Evolution of Packages">&sect;13.3</a>), classes
            (<a class="xref" href="jls-13.html#jls-13.4" title="13.4.&nbsp;Evolution of Classes">&sect;13.4</a>), and interfaces
            (<a class="xref" href="jls-13.html#jls-13.5" title="13.5.&nbsp;Evolution of Interfaces">&sect;13.5</a>), specifying which of these changes are
            guaranteed to preserve binary compatibility and which are not.
         </p>
         <p class="norm"><a name="jls-13-230"></a>Occasionally, references of the
            form: (JVMS &sect;x.y) are used to indicate concepts from <em class="citetitle">The Java Virtual Machine Specification, Java SE 8 Edition</em>.
         </p>
         <div class="section" title="13.1.&nbsp;The Form of a Binary">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.1"></a>13.1.&nbsp;The Form of a Binary
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm-static"><a name="jls-13.1-100"></a>Programs
               must be compiled either into the <code class="literal">class</code> file format specified by
               <em class="citetitle">The Java Virtual Machine Specification, Java SE 8 Edition</em>, or into a representation that can be mapped into that format
               by a class loader written in the Java programming language.
            </p>
            <p class="norm-static"><a name="jls-13.1-110"></a>
               The resulting <code class="literal">class</code> file must have certain properties. A number of
               these properties are specifically chosen to support source code
               transformations that preserve binary compatibility. The required
               properties are:
            </p>
            <div class="orderedlist">
               <ol class="orderedlist" type="1">
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-A"></a>
                              The class or interface must be named by its <span class="emphasis"><em>binary
                                    name</em></span>, which must meet the following
                              constraints:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-A"></a>
                                 	  The binary name of a top level type
                                 	  (<a class="xref" href="jls-7.html#jls-7.6" title="7.6.&nbsp;Top Level Type Declarations">&sect;7.6</a>) is its canonical name
                                 	  (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>).
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-B"></a>
                                 	  The binary name of a member type (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>) consists of the binary name of
                                 	  its immediately enclosing type, followed by <code class="literal">$</code>,
                                 	  followed by the simple name of the member.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-C"></a>
                                 	  The binary name of a local class
                                 	  (<a class="xref" href="jls-14.html#jls-14.3" title="14.3.&nbsp;Local Class Declarations">&sect;14.3</a>) consists of the binary name of
                                 	  its immediately enclosing type, followed by <code class="literal">$</code>,
                                 	  followed by a non-empty sequence of digits, followed by the
                                 	  simple name of the local class.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-D"></a>
                                 	  The binary name of an anonymous class
                                 	  (<a class="xref" href="jls-15.html#jls-15.9.5" title="15.9.5.&nbsp;Anonymous Class Declarations">&sect;15.9.5</a>) consists of the binary name
                                 	  of its immediately enclosing type, followed by <code class="literal">$</code>,
                                 	  followed by a non-empty sequence of digits.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-E"></a>
                                 	  The binary name of a type variable declared by a generic
                                 	  class or interface (<a class="xref" href="jls-8.html#jls-8.1.2" title="8.1.2.&nbsp;Generic Classes and Type Parameters">&sect;8.1.2</a>,
                                 	  <a class="xref" href="jls-9.html#jls-9.1.2" title="9.1.2.&nbsp;Generic Interfaces and Type Parameters">&sect;9.1.2</a>) is the binary name of its
                                 	  immediately enclosing type, followed by <code class="literal">$</code>, followed
                                 	  by the simple name of the type variable.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-F"></a>
                                 	  The binary name of a type variable declared by a generic
                                 	  method (<a class="xref" href="jls-8.html#jls-8.4.4" title="8.4.4.&nbsp;Generic Methods">&sect;8.4.4</a>) is the binary name of
                                 	  the type declaring the method, followed by <code class="literal">$</code>,
                                 	  followed by the descriptor of the method (JVMS &sect;4.3.3),
                                 	  followed by <code class="literal">$</code>, followed by the simple name of the
                                 	  type variable.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-A-G"></a>
                                 	  The binary name of a type variable declared by a generic
                                 	  constructor (<a class="xref" href="jls-8.html#jls-8.8.4" title="8.8.4.&nbsp;Generic Constructors">&sect;8.8.4</a>) is the binary name
                                 	  of the type declaring the constructor, followed by <code class="literal">$</code>,
                                 	  followed by the descriptor of the constructor (JVMS &sect;4.3.3),
                                 	  followed by <code class="literal">$</code>, followed by the simple name of the
                                 	  type variable.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-B"></a>
                              A reference to another class or interface type must be symbolic,
                              using the binary name of the type.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-C"></a>
                              A reference to a field that is a constant variable
                              (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>) must be resolved at compile time
                              to the value <span class="type">V</span> denoted by
                              the constant variable's initializer.
                     </p>
                     <p class="norm"><a name="jls-13.1-110-C.1"></a>
                              If such a field is <code class="literal">static</code>, then no reference to the field
                              should be present in the code in a binary file, including the
                              class or interface which declared the field. Such a field must
                              always appear to have been initialized
                              (<a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>); the default initial value for
                              the field (if different than <span class="type">V</span>) must never be observed.
                     </p>
                     <p class="norm"><a name="jls-13.1-110-C.2"></a>
                              If such a field is non-<code class="literal">static</code>, then no reference to the field
                              should be present in the code in a binary file, except in the
                              class containing the field. (It will be a class rather than an
                              interface, since an interface has only <code class="literal">static</code> fields.) The
                              class should have code to set the field's value to <span class="type">V</span> during
                              instance creation (<a class="xref" href="jls-12.html#jls-12.5" title="12.5.&nbsp;Creation of New Class Instances">&sect;12.5</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-D"></a>
                              Given a legal expression denoting a field access in a class <span class="type">C</span>,
                              referencing a  field named <code class="varname">f</code> that is not a
                              constant variable and is declared in a (possibly distinct) class
                              or interface <span class="type">D</span>, we define the <span class="emphasis"><em>qualifying type of the
                                    field reference</em></span> as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-A"></a>
                                 	  If the expression is referenced by a simple name, then if
                                 	  <code class="varname">f</code> is a member of the current class or interface, <span class="type">C</span>, then
                                 	  let <span class="type">T</span> be <span class="type">C</span>. Otherwise, let <span class="type">T</span> be the innermost
                                 	  lexically enclosing type declaration of which <code class="varname">f</code> is a
                                 	  member. In either case, <span class="type">T</span> is the qualifying type of the
                                 	  reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-B"></a>
                                 	  If the reference is of the form <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="varname">f</code>, where
                                 	  <span class="emphasis"><em>TypeName</em></span> denotes a class or interface, then the class or
                                 	  interface denoted by <span class="emphasis"><em>TypeName</em></span> is the qualifying type of
                                 	  the reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-C"></a>
                                 	  If the expression is of the form <span class="emphasis"><em>ExpressionName</em></span><code class="literal">.</code><code class="varname">f</code> or
                                 	  <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="varname">f</code>, then:
                              </p>
                              <div class="norm">
                                 <ul class="norm" type="circle">
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-D-C-A"></a>
                                          	      If the compile-time type of <span class="emphasis"><em>ExpressionName</em></span> or
                                          	      <span class="emphasis"><em>Primary</em></span> is an intersection type <span class="type">V<sub>1</sub></span> <code class="literal">&amp;</code> ... <code class="literal">&amp;</code>
                                          	      <span class="type">V<sub>n</sub></span> (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>), then the qualifying
                                          	      type of the reference is <span class="type">V<sub>1</sub></span>.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-D-C-B"></a>
                                          	      Otherwise, the compile-time type of <span class="emphasis"><em>ExpressionName</em></span> or
                                          	      <span class="emphasis"><em>Primary</em></span> is the qualifying type of the
                                          	      reference.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-D"></a>
                                 	  If the expression is of the form <code class="literal">super</code><code class="literal">.</code><code class="varname">f</code>, then the
                                 	  superclass of <span class="type">C</span> is the qualifying type of the
                                 	  reference.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-D-E"></a>
                                 	  If the expression is of the form
                                 	  <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">f</code>, then the superclass of the
                                 	  class denoted by <span class="emphasis"><em>TypeName</em></span> is the qualifying type of the
                                 	  reference.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-D.1"></a>
                              The reference to <code class="varname">f</code> must be compiled into a symbolic reference
                              to the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the qualifying
                              type of the reference, plus the simple name of the field,
                              <code class="varname">f</code>. The reference must also include a symbolic reference to the
                              erasure of the declared type of the field so that the verifier
                              can check that the type is as expected.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-E"></a>
                              
                              Given a method invocation expression or a method reference
                              expression in a class or interface <span class="type">C</span>, referencing a method
                              named <code class="varname">m</code> declared (or implicitly declared
                              (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>)) in a (possibly distinct) class or
                              interface <span class="type">D</span>, we define the <span class="emphasis"><em>qualifying type of the
                                    method invocation</em></span> as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E-A"></a>
                                 	  If <span class="type">D</span> is <code class="literal">Object</code> then the qualifying type of the
                                 	  expression is <code class="literal">Object</code>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E-B"></a>Otherwise:
                              </p>
                              <div class="norm">
                                 <ul class="norm" type="circle">
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-B-A"></a>
                                          	      If the method is referenced by a simple name, then if
                                          	      <code class="varname">m</code> is a member of the current class or interface <span class="type">C</span>,
                                          	      let <span class="type">T</span> be <span class="type">C</span>; otherwise, let <span class="type">T</span> be the innermost
                                          	      lexically enclosing type declaration of which <code class="varname">m</code> is a
                                          	      member. In either case, <span class="type">T</span> is the qualifying type of
                                          	      the method invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-B-B"></a>
                                                	      If the expression is of the form <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="varname">m</code> or
                                          	      <span class="emphasis"><em>ReferenceType</em></span><code class="literal">::</code><code class="varname">m</code>, then the type denoted by
                                          	      <span class="emphasis"><em>TypeName</em></span> or <span class="emphasis"><em>ReferenceType</em></span> is the qualifying type of
                                          	      the method invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-B-C"></a>
                                          	      If the expression is of the form
                                          	      <span class="emphasis"><em>ExpressionName</em></span><code class="literal">.</code><code class="varname">m</code> or <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="varname">m</code> or
                                          	      <span class="emphasis"><em>ExpressionName</em></span><code class="literal">::</code><code class="varname">m</code> or
                                          	      <span class="emphasis"><em>Primary</em></span><code class="literal">::</code><code class="varname">m</code>, then:
                                       </p>
                                       <div class="norm">
                                          <ul class="norm" type="square">
                                             <li class="listitem">
                                                <p class="norm"><a name="jls-13.1-110-E-B-C-A"></a>
                                                   		  If the compile-time type of <span class="emphasis"><em>ExpressionName</em></span> or
                                                   		  <span class="emphasis"><em>Primary</em></span> is an intersection type <span class="type">V<sub>1</sub></span> <code class="literal">&amp;</code>
                                                   		  ... <code class="literal">&amp;</code> <span class="type">V<sub>n</sub></span> (<a class="xref" href="jls-4.html#jls-4.9" title="4.9.&nbsp;Intersection Types">&sect;4.9</a>), then the
                                                   		  qualifying type of the method invocation is
                                                   		  <span class="type">V<sub>1</sub></span>.
                                                </p>
                                             </li>
                                             <li class="listitem">
                                                <p class="norm"><a name="jls-13.1-110-E-B-C-B"></a>
                                                   		  Otherwise, the compile-time type of <span class="emphasis"><em>ExpressionName</em></span>
                                                   		  or <span class="emphasis"><em>Primary</em></span> is the qualifying type of the method
                                                   		  invocation.
                                                </p>
                                             </li>
                                          </ul>
                                       </div>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-B-D"></a>
                                          	      If the expression is of the form <code class="literal">super</code><code class="literal">.</code><code class="varname">m</code> or
                                          	      <code class="literal">super</code><code class="literal">::</code><code class="varname">m</code>, then the superclass of <span class="type">C</span> is
                                          	      the qualifying type of the method invocation.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jls-13.1-110-E-B-E"></a>
                                          	      If the expression is of the form
                                          	      <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">.</code><code class="varname">m</code> or
                                          	      <span class="emphasis"><em>TypeName</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">::</code><code class="varname">m</code>, then if
                                          	      <span class="emphasis"><em>TypeName</em></span> denotes a class <span class="type">X</span>, the superclass of <span class="type">X</span> is
                                          	      the qualifying type of the method invocation; if
                                          	      <span class="emphasis"><em>TypeName</em></span> denotes an interface <span class="type">X</span>, <span class="type">X</span> is the
                                          	      qualifying type of the method invocation.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p class="norm-static"><a name="jls-13.1-110-E.1"></a>
                              A reference to a method must be resolved at compile time to a
                              symbolic reference to the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of
                              the qualifying type of the invocation, plus the erasure of the
                              signature (<a class="xref" href="jls-8.html#jls-8.4.2" title="8.4.2.&nbsp;Method Signature">&sect;8.4.2</a>) of the method. The
                              signature of a method must include all of the
                              following as determined by
                              <a class="xref" href="jls-15.html#jls-15.12.3" title="15.12.3.&nbsp;Compile-Time Step 3: Is the Chosen Method Appropriate?">&sect;15.12.3</a>:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-A"></a>
                                 	  The simple name of the method
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-B"></a>
                                 	  The number of parameters to the method
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-E.1-C"></a>
                                 	  A symbolic reference to the type of each parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-E.2"></a>
                              A reference to a method must also include either a symbolic
                              reference to the erasure of the return type of the denoted
                              method or an indication that the denoted method is declared
                              <code class="literal">void</code> and does not return a value.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-110-F"></a>
                              Given a class instance creation expression
                              (<a class="xref" href="jls-15.html#jls-15.9" title="15.9.&nbsp;Class Instance Creation Expressions">&sect;15.9</a>) or an explicit constructor
                              invocation statement (<a class="xref" href="jls-8.html#jls-8.8.7.1" title="8.8.7.1.&nbsp;Explicit Constructor Invocations">&sect;8.8.7.1</a>) or a method
                              reference expression of the form <span class="emphasis"><em>ClassType
                                    <code class="literal">::</code> <code class="literal">new</code></em></span> (<a class="xref" href="jls-15.html#jls-15.13" title="15.13.&nbsp;Method Reference Expressions">&sect;15.13</a>) in a
                              class or interface <span class="type">C</span> referencing a constructor <code class="varname">m</code> declared in
                              a (possibly distinct) class or interface <span class="type">D</span>, we define the
                              qualifying type of the constructor invocation as follows:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-A"></a>
                                 	  If the expression is of the form
                                 	  <code class="literal">new</code> <span class="type">D</span><code class="literal">(...)</code> or
                                           <span class="emphasis"><em>ExpressionName</em></span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...)</code> or 
                                           <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...)</code> or
                                 	  <span class="type">D</span> <code class="literal">::</code> <code class="literal">new</code>,
                                 	  then the qualifying type of the invocation is <span class="type">D</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-B"></a>
                                 	  If the expression is of the form 
                                 	  <code class="literal">new</code> <span class="type">D</span><code class="literal">(...){...}</code> or 
                                 	  <span class="emphasis"><em>ExpressionName</em></span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...){...}</code> or
                                 	  <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="literal">new</code> <span class="type">D</span><code class="literal">(...){...}</code>,
                                 	  then the qualifying type of the expression is the
                                   	  compile-time type of the expression.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-C"></a>
                                 	  If the expression is of the form
                                           <code class="literal">super</code><code class="literal">(...)</code> or
                                           <span class="emphasis"><em>ExpressionName</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">(...)</code> or
                                           <span class="emphasis"><em>Primary</em></span><code class="literal">.</code><code class="literal">super</code><code class="literal">(...)</code>, then the
                                           qualifying type of the expression is the direct superclass
                                           of <span class="type">C</span>.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F-D"></a>
                                 	  If the expression is of the form
                                 	  <code class="literal">this</code><code class="literal">(...)</code>, then the qualifying type of
                                 	  the expression is <span class="type">C</span>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jls-13.1-110-F.1"></a>
                              A reference to a constructor must be resolved at compile time to
                              a symbolic reference to the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>)
                              of the qualifying type of the invocation, plus the signature of
                              the constructor (<a class="xref" href="jls-8.html#jls-8.8.2" title="8.8.2.&nbsp;Constructor Signature">&sect;8.8.2</a>). The signature of
                              a constructor must include both:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F.1-A"></a>
                                 	  The number of parameters of the constructor
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-110-F.1-B"></a>
                                 	  A symbolic reference to the type of each formal
                                 	  parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
               </ol>
            </div>
            <p class="norm-static"><a name="jls-13.1-120"></a>A binary
               representation for a class or interface must also contain all of the
               following:
            </p>
            <div class="orderedlist">
               <ol class="orderedlist" type="1">
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-A"></a>
                              If it is a class and is not <code class="literal">Object</code>, then a symbolic reference
                              to the erasure of the direct superclass of this class.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-B"></a>
                              A symbolic reference to the erasure of each direct
                              superinterface, if any.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-C"></a>
                              A specification of each field declared in the class or
                              interface, given as the simple name of the field and a symbolic
                              reference to the erasure of the type of the field.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-D"></a>
                              If it is a class, then the erased signature of each constructor,
                              as described above.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-E"></a>
                              For each method declared in the class or interface (excluding, for an interface, its implicitly declared methods
                              (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>)), its erased signature
                              and return type, as described above.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-F"></a>
                              The code needed to implement the class or interface:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="disc">
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-120-F-A"></a>
                                 	  For an interface, code for the field initializers and the
                                 	  implementation of each default method.
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jls-13.1-120-F-B"></a>
                                 	  For a class, code for the field initializers, the instance
                                 	  and static initializers, and the implementation of each
                                 	  method or constructor.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-G"></a>
                              Every type must contain sufficient information to recover its
                              canonical name (<a class="xref" href="jls-6.html#jls-6.7" title="6.7.&nbsp;Fully Qualified Names and Canonical Names">&sect;6.7</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-H"></a>
                              Every member type must have sufficient information to recover
                              its source level access modifier.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-I"></a>
                              Every nested class and nested interface must have a symbolic
                              reference to its immediately enclosing class
                              (<a class="xref" href="jls-8.html#jls-8.1.3" title="8.1.3.&nbsp;Inner Classes and Enclosing Instances">&sect;8.1.3</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-J"></a>
                              Every class  must contain
                              symbolic references to all of its member types
                              (<a class="xref" href="jls-8.html#jls-8.5" title="8.5.&nbsp;Member Type Declarations">&sect;8.5</a>), and to all local and anonymous
                              classes that appear in its methods, constructors, static
                              initializers, instance initializers, and field
                              initializers.
                     </p>
                     <p class="norm"><a name="jls-13.1-120-J.1"></a>
                              Every interface must contain symbolic references to all of its
                              member types (<a class="xref" href="jls-9.html#jls-9.5" title="9.5.&nbsp;Member Type Declarations">&sect;9.5</a>), and to all local and
                              anonymous classes that appear in its default methods and field
                              initializers.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-K"></a>
                              A construct emitted by a Java compiler must be marked
                              as <span class="emphasis"><em>synthetic</em></span> if it does not correspond to a
                              construct declared explicitly or implicitly in source code,
                              unless the emitted construct is a class initialization method
                              (JVMS &sect;2.9).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jls-13.1-120-L"></a>
                              A construct emitted by a Java compiler must be marked
                              as <span class="emphasis"><em>mandated</em></span> if it corresponds to a formal
                              parameter declared implicitly in source code
                              (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>, <a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>,
                              <a class="xref" href="jls-8.html#jls-8.9.3" title="8.9.3.&nbsp;Enum Members">&sect;8.9.3</a>,
                              <a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>).
                     </p>
                  </li>
               </ol>
            </div>
            <p class="note">The following formal parameters are declared
               implicitly in source code:
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">The first formal parameter of a constructor of a
                              non-<code class="literal">private</code> inner member class (<a class="xref" href="jls-8.html#jls-8.8.1" title="8.8.1.&nbsp;Formal Parameters">&sect;8.8.1</a>,
                              <a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The first formal parameter of an anonymous
                              constructor of an anonymous class whose superclass is inner or
                              local (not in a static context)
                              (<a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>).
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The formal parameter
                              <code class="literal">name</code> of the <code class="literal">valueOf</code> method
                              which is implicitly declared in an enum type
                              (<a class="xref" href="jls-8.html#jls-8.9.3" title="8.9.3.&nbsp;Enum Members">&sect;8.9.3</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">For reference, the following constructs are declared
               implicitly in source code, but are not marked as mandated because only
               formal parameters can be so marked in a <code class="literal">class</code> file (JVMS
               &sect;4.7.22):
            </p>
            <div class="note">
               <ul class="note" type="disc">
                  <li class="listitem">
                     <p class="note">Default constructors of classes and enum types
                             (<a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>, <a class="xref" href="jls-8.html#jls-8.9.2" title="8.9.2.&nbsp;Enum Body Declarations">&sect;8.9.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Anonymous constructors
                              (<a class="xref" href="jls-15.html#jls-15.9.5.1" title="15.9.5.1.&nbsp;Anonymous Constructors">&sect;15.9.5.1</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">The <code class="literal">values</code>
                              and <code class="literal">valueOf</code> methods of enum types
                              (<a class="xref" href="jls-8.html#jls-8.9.3" title="8.9.3.&nbsp;Enum Members">&sect;8.9.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Certain <code class="literal">public</code> fields of enum types
                              (<a class="xref" href="jls-8.html#jls-8.9.3" title="8.9.3.&nbsp;Enum Members">&sect;8.9.3</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Certain <code class="literal">public</code> methods of interfaces
                              (<a class="xref" href="jls-9.html#jls-9.2" title="9.2.&nbsp;Interface Members">&sect;9.2</a>)
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="note">Container annotations
                              (<a class="xref" href="jls-9.html#jls-9.7.5" title="9.7.5.&nbsp;Multiple Annotations of the Same Type">&sect;9.7.5</a>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jls-13.1-200"></a>The following sections discuss
               changes that may be made to class and interface type declarations
               without breaking compatibility with pre-existing binaries. Under the
               translation requirements given above, the Java Virtual Machine and its <code class="literal">class</code> file
               format support these changes. Any other valid binary format, such as a
               compressed or encrypted representation that is mapped back into
               <code class="literal">class</code> files by a class loader under the above requirements, will
               necessarily support these changes as well.
            </p>
         </div>
         <div class="section" title="13.2.&nbsp;What Binary Compatibility Is and Is Not">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.2"></a>13.2.&nbsp;What Binary Compatibility Is and Is Not
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.2-100"></a>A change to a type
               is <span class="emphasis"><em>binary compatible with</em></span> (equivalently, does
               not <span class="emphasis"><em>break binary compatibility</em></span> with) pre-existing
               binaries if pre-existing binaries that previously linked without error
               will continue to link without error.
            </p>
            <p class="norm"><a name="jls-13.2-110"></a>Binaries are compiled to rely
               on the accessible members and constructors of other classes and
               interfaces. To preserve binary compatibility, a class or interface
               should treat its accessible members and constructors, their existence
               and behavior, as a <span class="emphasis"><em>contract</em></span> with its
               users.
            </p>
            <p class="norm"><a name="jls-13.2-120"></a>The Java programming language is designed to
               prevent additions to contracts and accidental name collisions from
               breaking binary compatibility. Specifically, addition of more methods
               overloading a particular method name does not break compatibility with
               pre-existing binaries. The method signature that the pre-existing
               binary will use for method lookup is chosen by the overload resolution
               algorithm at compile time (<a class="xref" href="jls-15.html#jls-15.12.2" title="15.12.2.&nbsp;Compile-Time Step 2: Determine Method Signature">&sect;15.12.2</a>).
            </p>
            <p class="note">If the Java programming language had been designed so that the
               particular method to be executed was chosen at run time, then such an
               ambiguity might be detected at run time. Such a rule would imply that
               adding an additional overloaded method so as to make ambiguity
               possible at a call site could break compatibility with an unknown
               number of pre-existing binaries. See <a class="xref" href="jls-13.html#jls-13.4.23" title="13.4.23.&nbsp;Method and Constructor Overloading">&sect;13.4.23</a> for
               more discussion.
            </p>
            <p class="norm"><a name="jls-13.2-200"></a>Binary compatibility is not
               the same as source compatibility. In particular, the example in
               <a class="xref" href="jls-13.html#jls-13.4.6" title="13.4.6.&nbsp;Class Body and Member Declarations">&sect;13.4.6</a> shows that a set of compatible binaries
               can be produced from sources that will not compile all together. This
               example is typical: a new declaration is added, changing the meaning
               of a name in an unchanged part of the source code, while the
               pre-existing binary for that unchanged part of the source code retains
               the fully-qualified, previous meaning of the name. Producing a
               consistent set of source code requires providing a qualified name or
               field access expression corresponding to the previous meaning.
            </p>
         </div>
         <div class="section" title="13.3.&nbsp;Evolution of Packages">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.3"></a>13.3.&nbsp;Evolution of Packages
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.3-100"></a>A new top level class or
               interface type may be added to a package without breaking
               compatibility with pre-existing binaries, provided the new type does
               not reuse a name previously given to an unrelated type.
            </p>
            <p class="norm"><a name="jls-13.3-110"></a>If a new type reuses a name
               previously given to an unrelated type, then a conflict may result,
               since binaries for both types could not be loaded by the same class
               loader.
            </p>
            <p class="norm"><a name="jls-13.3-200"></a>Changes in top level class and
               interface types that are not <code class="literal">public</code> and that are not a superclass or
               superinterface, respectively, of a <code class="literal">public</code> type, affect only types
               within the package in which they are declared. Such types may be
               deleted or otherwise changed, even if incompatibilities are otherwise
               described here, provided that the affected binaries of that package
               are updated together.
            </p>
         </div>
         <div class="section" title="13.4.&nbsp;Evolution of Classes">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.4"></a>13.4.&nbsp;Evolution of Classes
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.4-100"></a>This section describes the
               effects of changes to the declaration of a class and its members and
               constructors on pre-existing binaries.
            </p>
            <div class="section" title="13.4.1.&nbsp;abstract Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.1"></a>13.4.1.&nbsp;<code class="literal">abstract</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.1-100"></a>If a class that was not
                  declared <code class="literal">abstract</code> is changed to be declared <code class="literal">abstract</code>, then
                  pre-existing binaries that attempt to create new instances of that
                  class will throw either an <code class="literal">InstantiationError</code> at link time, or (if a
                  reflective method is used) an <code class="literal">InstantiationException</code> at run time;
                  such a change is therefore not recommended for widely distributed
                  classes.
               </p>
               <p class="norm"><a name="jls-13.4.1-110"></a>Changing a class that is
                  declared <code class="literal">abstract</code> to no longer be declared <code class="literal">abstract</code> does not break
                  compatibility with pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.2.&nbsp;final Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.2"></a>13.4.2.&nbsp;<code class="literal">final</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.2-100"></a>If a class that was not
                  declared <code class="literal">final</code> is changed to be declared <code class="literal">final</code>, then a <code class="literal">VerifyError</code> is
                  thrown if a binary of a pre-existing subclass of this class is loaded,
                  because <code class="literal">final</code> classes can have no subclasses; such a change is not
                  recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.2-110"></a>Changing a class that is
                  declared <code class="literal">final</code> to no longer be declared <code class="literal">final</code> does not break
                  compatibility with pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.3.&nbsp;public Classes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.3"></a>13.4.3.&nbsp;<code class="literal">public</code> Classes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.3-100"></a>Changing a class that is not
                  declared <code class="literal">public</code> to be declared <code class="literal">public</code> does not break compatibility
                  with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.3-110"></a>If a class that was declared
                  <code class="literal">public</code> is changed to not be declared <code class="literal">public</code>, then an <code class="literal">IllegalAccessError</code> is
                  thrown if a pre-existing binary is linked that needs but no longer has
                  access to the class type; such a change is not recommended for widely
                  distributed classes.
               </p>
            </div>
            <div class="section" title="13.4.4.&nbsp;Superclasses and Superinterfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.4"></a>13.4.4.&nbsp;Superclasses and Superinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.4-100"></a>A <code class="literal">ClassCircularityError</code> is
                  thrown at load time if a class would be a superclass of
                  itself. Changes to the class hierarchy that could result in such a
                  circularity when newly compiled binaries are loaded with pre-existing
                  binaries are not recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.4-110"></a>Changing the direct
                  superclass or the set of direct superinterfaces of a class type will
                  not break compatibility with pre-existing binaries, provided that the
                  total set of superclasses or superinterfaces, respectively, of the
                  class type loses no members.
               </p>
               <p class="norm"><a name="jls-13.4.4-120"></a>If a change to the direct
                  superclass or the set of direct superinterfaces results in any class
                  or interface no longer being a superclass or superinterface,
                  respectively, then linkage errors may result if pre-existing binaries
                  are loaded with the binary of the modified class. Such changes are not
                  recommended for widely distributed classes.
               </p>
               <div class="example"><a name="d5e19319"></a><p class="title"><b>Example&nbsp;13.4.4-1.&nbsp;Changing A Superclass</b></p>
                  <div class="example-contents">
                     <p class="note">Suppose that the following test program:</p><pre class="programlisting">
class Hyper { char h = 'h'; } 
class Super extends Hyper { char s = 's'; }
class Test extends Super {
    public static void printH(Hyper h) {
        System.out.println(h.h);
    }
    public static void main(String[] args) {
        printH(new Super());
    }
}
</pre><p class="note">is compiled and executed, producing the
                        output:
                     </p><pre class="screen">
h
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is then compiled:
                     </p><pre class="programlisting">
class Super { char s = 's'; }
</pre><p class="note">This version of class <code class="literal">Super</code> is
                        not a subclass of <code class="literal">Hyper</code>. If we then run the
                        existing binaries of <code class="literal">Hyper</code>
                        and <code class="literal">Test</code> with the new version
                        of <code class="literal">Super</code>, then a <code class="literal">VerifyError</code> is
                        thrown at link time. The verifier objects because the result
                        of <code class="literal">new Super()</code> cannot be passed as an argument in
                        place of a formal parameter of type <code class="literal">Hyper</code>,
                        because <code class="literal">Super</code> is not a subclass
                        of <code class="literal">Hyper</code>.
                     </p>
                     <p class="note">It is instructive to consider what might happen
                        without the verification step: the program might run and print:
                     </p><pre class="screen">
s
</pre><p class="note">This demonstrates that without the verifier, the
                        Java type system could be defeated by linking inconsistent binary
                        files, even though each was produced by a correct Java
                        compiler.
                     </p>
                     <p class="note">The lesson is that an implementation that lacks a
                        verifier or fails to use it will not maintain type safety and is,
                        therefore, not a valid implementation.
                     </p>
                  </div>
               </div><br class="example-break"><div class="informalexample">
                  <p class="note">The requirement that alternatives in a multi-<code class="literal">catch</code>
                     clause (<a class="xref" href="jls-14.html#jls-14.20" title="14.20.&nbsp;The try statement">&sect;14.20</a>) not be subclasses or superclasses
                     of each other is only a source restriction. Assuming the following
                     client code is legal:
                  </p><pre class="screen">
try {
    throwAorB();
} catch(ExceptionA | ExceptionB e) {
    ...
}
</pre><p class="note">where <code class="literal">ExceptionA</code>
                     and <code class="literal">ExceptionB</code> do not have a subclass/superclass
                     relationship when the client is compiled, it is binary compatible with
                     respect to the client for <code class="literal">ExceptionA</code>
                     and <code class="literal">ExceptionB</code> to have such a relationship when the
                     client is executed.
                  </p>
                  <p class="note">This is analogous to other situations where a class
                     transformation that is binary compatible for a client might not be
                     source compatible for the same client.
                  </p>
               </div>
            </div>
            <div class="section" title="13.4.5.&nbsp;Class Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.5"></a>13.4.5.&nbsp;Class Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.5-100"></a>Adding or removing a type
                  parameter of a class does not, in itself, have any implications for
                  binary compatibility.
               </p>
               <p class="norm"><a name="jls-13.4.5-110"></a>If such a type parameter is
                  used in the type of a field or method, that may have the normal
                  implications of changing the aforementioned type.
               </p>
               <p class="norm"><a name="jls-13.4.5-120"></a>Renaming a type parameter of
                  a class has no effect with respect to pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.5-130"></a>Changing the first bound of
                  a type parameter of a class may change the erasure
                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of any member that uses that type
                  parameter in its own type, and this may affect binary
                  compatibility. The change of such a bound is analogous to the change
                  of the first bound of a type parameter of a method or constructor
                  (<a class="xref" href="jls-13.html#jls-13.4.13" title="13.4.13.&nbsp;Method and Constructor Type Parameters">&sect;13.4.13</a>).
               </p>
               <p class="norm"><a name="jls-13.4.5-140"></a>Changing any other bound has
                  no effect on binary compatibility.
               </p>
            </div>
            <div class="section" title="13.4.6.&nbsp;Class Body and Member Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.6"></a>13.4.6.&nbsp;Class Body and Member Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.6-100"></a>No incompatibility with
                  pre-existing binaries is caused by adding an instance (respectively
                  <code class="literal">static</code>) member that has the same name and accessibility (for
                  fields), or same name and accessibility and signature and return type
                  (for methods), as an instance (respectively <code class="literal">static</code>) member of a
                  superclass or subclass. No error occurs even if the set of classes
                  being linked would encounter a compile-time error.
               </p>
               <p class="norm"><a name="jls-13.4.6-200"></a>Deleting a class member or
                  constructor that is not declared <code class="literal">private</code> may cause a linkage error
                  if the member or constructor is used by a pre-existing binary.
               </p>
               <div class="example"><a name="d5e19370"></a><p class="title"><b>Example&nbsp;13.4.6-1.&nbsp;Changing A Class Body</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}
class Test {
    public static void main(String[] args) {
        new Super().hello();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello from Super
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {}
</pre><p class="note">Then, recompiling <code class="literal">Super</code> and
                        executing this new binary with the original binaries
                        for <code class="literal">Test</code> and <code class="literal">Hyper</code> produces the
                        output:
                     </p><pre class="screen">
hello from Hyper
</pre><p class="note">as expected.</p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.6-300"></a>The <code class="literal">super</code> keyword can be
                  used to access a method declared in a superclass, bypassing any
                  methods declared in the current class. The expression
                  <code class="literal">super</code><code class="literal">.</code><span class="emphasis"><em>Identifier</em></span> is resolved, at compile time, to a method <code class="varname">m</code>
                  in the superclass <span class="type">S</span>. If the method <code class="varname">m</code> is an instance method, then
                  the method which is invoked at run time is the method with the same
                  signature as <code class="varname">m</code> that is a member of the direct superclass of the
                  class containing the expression involving <code class="literal">super</code>.
               </p>
               <div class="example"><a name="d5e19394"></a><p class="title"><b>Example&nbsp;13.4.6-2.&nbsp;Changing A Superclass</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper {
    void hello() { System.out.println("hello from Hyper"); }
}
class Super extends Hyper { }
class Test extends Super {
    public static void main(String[] args) {
        new Test().hello();
    }
    void hello() {
        super.hello();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello from Hyper
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {
    void hello() { System.out.println("hello from Super"); }
}
</pre><p class="note">Then, if <code class="literal">Super</code>
                        and <code class="literal">Hyper</code> are recompiled but
                        not <code class="literal">Test</code>, then running the new binaries with the
                        existing binary of <code class="literal">Test</code> produces the output:
                     </p><pre class="screen">
hello from Super
</pre><p class="note">as you might expect.</p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.7.&nbsp;Access to Members and Constructors">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.7"></a>13.4.7.&nbsp;Access to Members and Constructors
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.7-100"></a>Changing the declared access
                  of a member or constructor to permit less access may break
                  compatibility with pre-existing binaries, causing a linkage error to
                  be thrown when these binaries are resolved. Less access is permitted
                  if the access modifier is changed from package access to <code class="literal">private</code>
                  access; from <code class="literal">protected</code> access to package or <code class="literal">private</code> access; or
                  from <code class="literal">public</code> access to <code class="literal">protected</code>, package, or <code class="literal">private</code>
                  access. Changing a member or constructor to permit less access is
                  therefore not recommended for widely distributed classes.
               </p>
               <p class="norm"><a name="jls-13.4.7-110"></a>Perhaps surprisingly, the
                  binary format is defined so that changing a member or constructor to
                  be more accessible does not cause a linkage error when a subclass
                  (already) defines a method to have less access.
               </p>
               <div class="example"><a name="d5e19419"></a><p class="title"><b>Example&nbsp;13.4.7-1.&nbsp;Changing Accessibility</b></p>
                  <div class="example-contents">
                     <p class="note">If the package <code class="literal">points</code> defines the
                        class <code class="literal">Point</code>:
                     </p><pre class="programlisting">
package points;
public class Point {
    public int x, y;
    protected void print() {
        System.out.println("(" + x + "," + y + ")");
    }
}
</pre><p class="note">used by the program:</p><pre class="programlisting">
class Test extends points.Point {
    public static void main(String[] args) {
        Test t = new Test();
        t.print();
    }
    protected void print() { 
        System.out.println("Test"); 
    }
}
</pre><p class="note">then these classes compile
                        and <code class="literal">Test</code> executes to produce the output:
                     </p><pre class="screen">
Test
</pre><p class="note">If the method <code class="literal">print</code> in
                        class <code class="literal">Point</code> is changed to be <code class="literal">public</code>, and then
                        only the <code class="literal">Point</code> class is recompiled, and then
                        executed with the previously existing binary
                        for <code class="literal">Test</code>, then no linkage error occurs. This
                        happens even though it is improper, at compile time, for a <code class="literal">public</code>
                        method to be overridden by a <code class="literal">protected</code> method (as shown by the fact
                        that the class <code class="literal">Test</code> could not be recompiled using
                        this new <code class="literal">Point</code> class
                        unless <code class="literal">print</code> in <code class="literal">Test</code> were
                        changed to be <code class="literal">public</code>.)
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.7-200"></a>Allowing superclasses to
                  change <code class="literal">protected</code> methods to be <code class="literal">public</code> without breaking binaries of
                  pre-existing subclasses helps make binaries less fragile. The
                  alternative, where such a change would cause a linkage error, would
                  create additional binary incompatibilities.
               </p>
            </div>
            <div class="section" title="13.4.8.&nbsp;Field Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.8"></a>13.4.8.&nbsp;Field Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.8-100"></a>Widely distributed programs
                  should not expose any fields to their clients. Apart from the binary
                  compatibility issues discussed below, this is generally good software
                  engineering practice. Adding a field to a class may break
                  compatibility with pre-existing binaries that are not
                  recompiled.
               </p>
               <p class="norm"><a name="jls-13.4.8-110"></a>Assume a reference to a
                  field <code class="varname">f</code> with qualifying type <span class="type">T</span>. Assume further that <code class="varname">f</code> is in fact
                  an instance (respectively <code class="literal">static</code>) field declared in a superclass of
                  <span class="type">T</span>, <span class="type">S</span>, and that the type of <code class="varname">f</code> is <span class="type">X</span>.
               </p>
               <p class="norm"><a name="jls-13.4.8-120"></a>If a new field of type <span class="type">X</span>
                  with the same name as <code class="varname">f</code> is added to a subclass of <span class="type">S</span> that is a
                  superclass of <span class="type">T</span> or <span class="type">T</span> itself, then a linkage error may occur. Such
                  a linkage error will occur only if, in addition to the above, either
                  one of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.8-120-A"></a>
                                 The new field is less accessible than the old one.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.8-120-B"></a>
                                 The new field is a <code class="literal">static</code> (respectively instance)
                                 field.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.8-200"></a>In particular, no linkage
                  error will occur in the case where a class could no longer be
                  recompiled because a field access previously referenced a field of a
                  superclass with an incompatible type. The previously compiled class
                  with such a reference will continue to reference the field declared in
                  a superclass.
               </p>
               <div class="example"><a name="d5e19471"></a><p class="title"><b>Example&nbsp;13.4.8-1.&nbsp;Adding A Field Declaration</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Hyper { String h = "hyper"; }
class Super extends Hyper { String s = "super"; }
class Test {
    public static void main(String[] args) {
        System.out.println(new Super().h);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hyper
</pre><p class="note">Suppose a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super extends Hyper {
    String s = "super";
    int h = 0;
}
</pre><p class="note">Then, recompiling <code class="literal">Hyper</code>
                        and <code class="literal">Super</code>, and executing the resulting new binaries
                        with the old binary of <code class="literal">Test</code> produces the
                        output:
                     </p><pre class="screen">
hyper
</pre><p class="note">The field <code class="literal">h</code>
                        of <code class="literal">Hyper</code> is output by the original binary
                        of <code class="literal">Test</code>. While this may seem surprising at first,
                        it serves to reduce the number of incompatibilities that occur at run
                        time. (In an ideal world, all source files that needed recompilation
                        would be recompiled whenever any one of them changed, eliminating such
                        surprises. But such a mass recompilation is often impractical or
                        impossible, especially in the Internet. And, as was previously noted,
                        such recompilation would sometimes require further changes to the
                        source code.)
                     </p>
                     <p class="note">As another example, if the program:</p><pre class="programlisting">
class Hyper { String h = "Hyper"; }
class Super extends Hyper { }
class Test extends Super {
    public static void main(String[] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}
</pre><p class="note">is compiled and executed, it produces the
                        output:
                     </p><pre class="screen">
Hyper
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is then compiled:
                     </p><pre class="programlisting">
class Super extends Hyper { char h = 'h'; }
</pre><p class="note">If the resulting binary is used with the existing
                        binaries for <code class="literal">Hyper</code> and <code class="literal">Test</code>,
                        then the output is still:
                     </p><pre class="screen">
Hyper
</pre><p class="note">even though compiling the source for these
                        binaries:
                     </p><pre class="programlisting">
class Hyper { String h = "Hyper"; }
class Super extends Hyper { char h = 'h'; }
class Test extends Super {
    public static void main(String[] args) {
        String s = new Test().h;
        System.out.println(s);
    }
}
</pre><p class="note">would result in a compile-time error, because
                        the <code class="literal">h</code> in the source code
                        for <code class="literal">main</code> would now be construed as referring to the
                        <code class="literal">char</code> field declared in <code class="literal">Super</code>, and a <code class="literal">char</code> value
                        can't be assigned to a <code class="literal">String</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.8-300"></a>Deleting a field from a
                  class will break compatibility with any pre-existing binaries that
                  reference this field, and a <code class="literal">NoSuchFieldError</code> will be thrown when such a
                  reference from a pre-existing binary is linked. Only <code class="literal">private</code> fields
                  may be safely deleted from a widely distributed class.
               </p>
               <p class="norm"><a name="jls-13.4.8-400"></a>For purposes of binary
                  compatibility, adding or removing a field <code class="varname">f</code> whose type involves type
                  variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or parameterized types
                  (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the addition
                  (respectively, removal) of a field of the same name whose type is the
                  erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the type of <code class="varname">f</code>.
               </p>
            </div>
            <div class="section" title="13.4.9.&nbsp;final Fields and static Constant Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.9"></a>13.4.9.&nbsp;<code class="literal">final</code> Fields and <code class="literal">static</code> Constant Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.9-100"></a>If a field that was not
                  declared <code class="literal">final</code> is changed to be declared <code class="literal">final</code>, then it can break
                  compatibility with pre-existing binaries that attempt to assign new
                  values to the field.
               </p>
               <div class="example"><a name="d5e19524"></a><p class="title"><b>Example&nbsp;13.4.9-1.&nbsp;Changing A Variable To Be <code class="literal">final</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { char s; }
class Test extends Super {
    public static void main(String[] args) {
        Super x = new Super();
        x.s = 'a';
        System.out.println(x.s);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
a
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super { final char s = 'b'; }
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in
                        a <code class="literal">IllegalAccessError</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.9-200"></a>Deleting the keyword <code class="literal">final</code>
                  or changing the value to which a field is initialized does not break
                  compatibility with existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.9-300"></a>If a field is a constant variable
                  (<a class="xref" href="jls-4.html#jls-4.12.4" title="4.12.4.&nbsp;final Variables">&sect;4.12.4</a>), and moreover is
                  <code class="literal">static</code>, then deleting the keyword <code class="literal">final</code> or changing its
                  value will not break compatibility with pre-existing binaries by
                  causing them not to run, but they will not see any new value for a
                  usage of the field unless they are recompiled. This result is a
                  side-effect of the decision to support conditional compilation
                  (<a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>). (One might suppose that the new value
                  is not seen if the usage occurs in a constant expression
                  (<a class="xref" href="jls-15.html#jls-15.28" title="15.28.&nbsp;Constant Expressions">&sect;15.28</a>) but is seen otherwise. This is not so;
                  pre-existing binaries do not see the new value at all.)
               </p>
               <p class="note">Another reason for requiring inlining of values of
                  <code class="literal">static</code> constant variables is because of <code class="literal">switch</code> statements. They
                  are the only kind of statement that relies on constant expressions,
                  namely that each <code class="literal">case</code> label of a <code class="literal">switch</code> statement must be a
                  constant expression whose value is different than every other <code class="literal">case</code>
                  label. <code class="literal">case</code> labels are often references to <code class="literal">static</code> constant
                  variables so it may not be immediately obvious that all the labels
                  have different values. If it is proven that there are no duplicate
                  labels at compile time, then inlining the values into the <code class="literal">class</code> file
                  ensures there are no duplicate labels at run time either - a very
                  desirable property.
               </p>
               <div class="example"><a name="d5e19555"></a><p class="title"><b>Example&nbsp;13.4.9-2.&nbsp;Conditional Compilation</b></p>
                  <div class="example-contents">
                     <p class="note">If the example:</p><pre class="programlisting">
class Flags { static final boolean debug = true; }
class Test {
    public static void main(String[] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}
</pre><p class="note">is compiled and executed, it produces the
                        output:
                     </p><pre class="screen">
debug is true
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Flags</code> is produced:
                     </p><pre class="programlisting">
class Flags { static final boolean debug = false; }
</pre><p class="note">If <code class="literal">Flags</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> produces the output:
                     </p><pre class="screen">
debug is true
</pre><p class="note">because the value of <code class="literal">debug</code> was a
                        constant expression, and could have been used in
                        compiling <code class="literal">Test</code> without making a reference to the
                        class <code class="literal">Flags</code>.
                     </p>
                     <p class="note">This behavior would not change
                        if <code class="literal">Flags</code> were changed to be an interface, as in the
                        modified example:
                     </p><pre class="programlisting">
interface Flags { boolean debug = true; }
class Test {
    public static void main(String[] args) {
        if (Flags.debug)
            System.out.println("debug is true");
    }
}
</pre><p class="note">Conditional compilation is discussed further at the
                        end of <a class="xref" href="jls-14.html#jls-14.21" title="14.21.&nbsp;Unreachable Statements">&sect;14.21</a>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.9-400"></a>The best way to avoid
                  problems with "inconstant constants" in widely-distributed code is to
                  use <code class="literal">static</code> constant
                  variables only for values which truly are unlikely ever to
                  change. Other than for true mathematical constants, we recommend that
                  source code make very sparing use of <code class="literal">static</code> constant variables.
               </p>
               <div class="informalexample">
                  <p class="note">If the read-only nature of <code class="literal">final</code> is required, a
                     better choice is to declare a <code class="literal">private</code> <code class="literal">static</code> variable and a
                     suitable accessor method to get its value. Thus we recommend:
                  </p><pre class="programlisting">

private static int N;
public static int getN() { return N; }

</pre><p class="note">rather than:</p><pre class="programlisting">

public static final int N = ...;

</pre><p class="note">There is no problem with:</p><pre class="programlisting">

public static int N = ...;

</pre><p class="note">if <code class="literal">N</code> need not be read-only.
                  </p>
               </div>
               <p class="norm"><a name="jls-13.4.9-410"></a>We recommend, as a general
                  rule, that only 
                  constant expressions be assigned to fields of interfaces.
               </p>
               <p class="norm"><a name="jls-13.4.9-420"></a>We note, but do not
                  recommend, that if a field of primitive type of an interface may
                  change, its value may be expressed idiomatically as in:
               </p><pre class="programlisting">

interface Flags {
    boolean debug = new Boolean(true).booleanValue();
}

</pre><p class="norm"><a name="jls-13.4.9-430"></a>ensuring that this value is
                  not a constant. Similar idioms exist for the other primitive
                  types.
               </p>
               <p class="norm"><a name="jls-13.4.9-500"></a>One other thing to note is
                  that <code class="literal">static</code> constant variables must never appear to
                  have the default initial value for their type
                  (<a class="xref" href="jls-4.html#jls-4.12.5" title="4.12.5.&nbsp;Initial Values of Variables">&sect;4.12.5</a>). This means that all such fields appear
                  to be initialized first during class initialization
                  (<a class="xref" href="jls-8.html#jls-8.3.2" title="8.3.2.&nbsp;Field Initialization">&sect;8.3.2</a>, <a class="xref" href="jls-9.html#jls-9.3.1" title="9.3.1.&nbsp;Initialization of Fields in Interfaces">&sect;9.3.1</a>,
                  <a class="xref" href="jls-12.html#jls-12.4.2" title="12.4.2.&nbsp;Detailed Initialization Procedure">&sect;12.4.2</a>).
               </p>
            </div>
            <div class="section" title="13.4.10.&nbsp;static Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.10"></a>13.4.10.&nbsp;<code class="literal">static</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.10-100"></a>If a field that is not
                  declared <code class="literal">private</code> was not declared <code class="literal">static</code> and is changed to be
                  declared <code class="literal">static</code>, or vice versa, then a linkage error, specifically
                  an <code class="literal">IncompatibleClassChangeError</code>, will result if the field is used by a pre-existing binary
                  which expected a field of the other kind. Such changes are not
                  recommended in code that has been widely distributed.
               </p>
            </div>
            <div class="section" title="13.4.11.&nbsp;transient Fields">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.11"></a>13.4.11.&nbsp;<code class="literal">transient</code> Fields
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.11-100"></a>Adding or deleting a
                  <code class="literal">transient</code> modifier of a field does not break compatibility with
                  pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.12.&nbsp;Method and Constructor Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.12"></a>13.4.12.&nbsp;Method and Constructor Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.12-100"></a>Adding a method or
                  constructor declaration to a class will not break compatibility with
                  any pre-existing binaries, even in the case where a type could no
                  longer be recompiled because an invocation previously referenced a
                  method or constructor of a superclass with an incompatible type. The
                  previously compiled class with such a reference will continue to
                  reference the method or constructor declared in a superclass.
               </p>
               <p class="norm"><a name="jls-13.4.12-110"></a>Assume a reference to a
                  method <code class="varname">m</code> with qualifying type <span class="type">T</span>. Assume further that <code class="varname">m</code> is in
                  fact an instance (respectively <code class="literal">static</code>) method declared in a
                  superclass of <span class="type">T</span>, <span class="type">S</span>.
               </p>
               <p class="norm"><a name="jls-13.4.12-120"></a>If a new method of type <span class="type">X</span>
                  with the same signature and return type as <code class="varname">m</code> is added to a subclass
                  of <span class="type">S</span> that is a superclass of <span class="type">T</span> or <span class="type">T</span> itself, then a linkage error
                  may occur. Such a linkage error will occur only if, in addition to the
                  above, either one of the following is true:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.12-120-A"></a>
                                 The new method is less accessible than the old one.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.12-120-B"></a>
                                 The new method is a <code class="literal">static</code> (respectively instance)
                                 method.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.12-200"></a>Deleting a method or
                  constructor from a class may break compatibility with any pre-existing
                  binary that referenced this method or constructor; a <code class="literal">NoSuchMethodError</code> may be
                  thrown when such a reference from a pre-existing binary is
                  linked. Such an error will occur only if no method with a matching
                  signature and return type is declared in a superclass.
               </p>
               <p class="norm"><a name="jls-13.4.12-300"></a>If the source code for
                  a non-inner class contains no declared
                  constructors, then a default constructor with no parameters is
                  implicitly declared (<a class="xref" href="jls-8.html#jls-8.8.9" title="8.8.9.&nbsp;Default Constructor">&sect;8.8.9</a>). Adding one or more
                  constructor declarations to the source code of such a class will
                  prevent this default constructor from being implicitly declared,
                  effectively deleting a constructor, unless one of the new constructors
                  also has no parameters, thus replacing the default constructor. The
                  default constructor with no parameters is given the same access
                  modifier as the class of its declaration, so any replacement should
                  have as much or more access if compatibility with pre-existing
                  binaries is to be preserved.
               </p>
            </div>
            <div class="section" title="13.4.13.&nbsp;Method and Constructor Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.13"></a>13.4.13.&nbsp;Method and Constructor Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.13-100"></a>Adding or removing a type
                  parameter of a method or constructor does not, in itself, have any
                  implications for binary compatibility.
               </p>
               <p class="norm"><a name="jls-13.4.13-110"></a>If such a type parameter is
                  used in the type of the method or constructor, that may have the
                  normal implications of changing the aforementioned type.
               </p>
               <p class="norm"><a name="jls-13.4.13-120"></a>Renaming a type parameter
                  of a method or constructor has no effect with respect to pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.4.13-130"></a>Changing the first bound of
                  a type parameter of a method or constructor may change the erasure
                  (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of any member that uses that type
                  parameter in its own type, and this may affect binary
                  compatibility. Specifically:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-A"></a>If the type parameter
                                 is used as the type of a field, the effect is as if the field
                                 was removed and a field with the same name, whose type is the
                                 new erasure of the type variable, was added.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-B"></a>If the type parameter
                                 is used as the type of any formal parameter of a method, but not
                                 as the return type, the effect is as if that method were
                                 removed, and replaced with a new method that is identical except
                                 for the types of the aforementioned formal parameters, which now
                                 have the new erasure of the type parameter as their type.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-C"></a>If the type parameter
                                 is used as a return type of a method, but not as the type of any
                                 formal parameter of the method, the effect is as if that method
                                 were removed, and replaced with a new method that is identical
                                 except for the return type, which is now the new erasure of the
                                 type parameter.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jls-13.4.13-130-D"></a>If the type parameter
                                 is used as a return type of a method and as the type of one or
                                 more formal parameters of the method, the effect is as if that
                                 method were removed, and replaced with a new method that is
                                 identical except for the return type, which is now the new
                                 erasure of the type parameter, and except for the types of the
                                 aforementioned formal parameters, which now have the new erasure
                                 of the type parameter as their types.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jls-13.4.13-200"></a>Changing any other bound
                  has no effect on binary compatibility.
               </p>
            </div>
            <div class="section" title="13.4.14.&nbsp;Method and Constructor Formal Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.14"></a>13.4.14.&nbsp;Method and Constructor Formal Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.14-100"></a>Changing the name of a
                  formal parameter of a method or constructor does not impact
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.14-110"></a>Changing the name of a
                  method, or the type of a formal parameter to a method or constructor,
                  or adding a parameter to or deleting a parameter from a method or
                  constructor declaration creates a method or constructor with a new
                  signature, and has the combined effect of deleting the method or
                  constructor with the old signature and adding a method or constructor
                  with the new signature (<a class="xref" href="jls-13.html#jls-13.4.12" title="13.4.12.&nbsp;Method and Constructor Declarations">&sect;13.4.12</a>).
               </p>
               <p class="norm"><a name="jls-13.4.14-120"></a>Changing the type of the last formal parameter of a
                  method from <span class="type">T</span><code class="literal">[]</code> to a variable arity parameter
                  (<a class="xref" href="jls-8.html#jls-8.4.1" title="8.4.1.&nbsp;Formal Parameters">&sect;8.4.1</a>) of type <span class="type">T</span> (i.e. to <span class="type">T</span><code class="literal">...</code>), and
                  vice versa, does not impact pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.14-130"></a>For purposes of binary
                  compatibility, adding or removing a method or constructor <code class="varname">m</code> whose
                  signature involves type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or
                  parameterized types (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the
                  addition (respectively, removal) of an otherwise equivalent method
                  whose signature is the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                  signature of <code class="varname">m</code>.
               </p>
            </div>
            <div class="section" title="13.4.15.&nbsp;Method Result Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.15"></a>13.4.15.&nbsp;Method Result Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.15-100"></a>Changing the result type of
                  a method, or replacing a result type with <code class="literal">void</code>, or replacing <code class="literal">void</code>
                  with a result type, has the combined effect of deleting the old method
                  and adding a new method with the new result type or newly <code class="literal">void</code>
                  result (see <a class="xref" href="jls-13.html#jls-13.4.12" title="13.4.12.&nbsp;Method and Constructor Declarations">&sect;13.4.12</a>).
               </p>
               <p class="norm"><a name="jls-13.4.15-110"></a>For purposes of binary
                  compatibility, adding or removing a method or constructor <code class="varname">m</code> whose
                  return type involves type variables (<a class="xref" href="jls-4.html#jls-4.4" title="4.4.&nbsp;Type Variables">&sect;4.4</a>) or
                  parameterized types (<a class="xref" href="jls-4.html#jls-4.5" title="4.5.&nbsp;Parameterized Types">&sect;4.5</a>) is equivalent to the
                  addition (respectively, removal) of the an otherwise equivalent method
                  whose return type is the erasure (<a class="xref" href="jls-4.html#jls-4.6" title="4.6.&nbsp;Type Erasure">&sect;4.6</a>) of the
                  return type of <code class="varname">m</code>.
               </p>
            </div>
            <div class="section" title="13.4.16.&nbsp;abstract Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.16"></a>13.4.16.&nbsp;<code class="literal">abstract</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.16-100"></a>Changing a method that is
                  declared <code class="literal">abstract</code> to no longer be declared <code class="literal">abstract</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.16-110"></a>Changing a method that is
                  not declared <code class="literal">abstract</code> to be declared <code class="literal">abstract</code> will break
                  compatibility with pre-existing binaries that previously invoked the
                  method, causing an <code class="literal">AbstractMethodError</code>.
               </p>
               <div class="example"><a name="d5e19700"></a><p class="title"><b>Example&nbsp;13.4.16-1.&nbsp;Changing A Method To Be <code class="literal">abstract</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { void out() { System.out.println("Out"); } }
class Test extends Super {
    public static void main(String[] args) {
        Test t = new Test();
        System.out.println("Way ");
        t.out();
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
Way
Out
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
abstract class Super {
    abstract void out();
}
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in an <code class="literal">AbstractMethodError</code>,
                        because class <code class="literal">Test</code> has no implementation of the
                        method <code class="literal">out</code>, and is therefore is (or should be)
                        <code class="literal">abstract</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.17.&nbsp;final Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.17"></a>13.4.17.&nbsp;<code class="literal">final</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.17-100"></a>Changing a method that is
                  declared <code class="literal">final</code> to no longer be declared <code class="literal">final</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.17-110"></a>Changing an instance method
                  that is not declared <code class="literal">final</code> to be declared <code class="literal">final</code> may break
                  compatibility with existing binaries that depend on the ability to
                  override the method.
               </p>
               <div class="example"><a name="d5e19726"></a><p class="title"><b>Example&nbsp;13.4.17-1.&nbsp;Changing A Method To Be <code class="literal">final</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super { void out() { System.out.println("out"); } }
class Test extends Super {
    public static void main(String[] args) {
        Test t = new Test();
        t.out();
    }
    void out() { super.out(); }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
out
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super { final void out() { System.out.println("!"); } }
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of <code class="literal">Test</code> results in a <code class="literal">VerifyError</code> because
                        the class <code class="literal">Test</code> improperly tries to override the
                        instance method <code class="literal">out</code>.
                     </p>
                  </div>
               </div><br class="example-break"><p class="norm"><a name="jls-13.4.17-120"></a>Changing a class (<code class="literal">static</code>)
                  method that is not declared <code class="literal">final</code> to be declared <code class="literal">final</code> does not
                  break compatibility with existing binaries, because the method could
                  not have been overridden.
               </p>
            </div>
            <div class="section" title="13.4.18.&nbsp;native Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.18"></a>13.4.18.&nbsp;<code class="literal">native</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.18-100"></a>Adding or deleting a
                  <code class="literal">native</code> modifier of a method does not break compatibility with
                  pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.4.18-110"></a>The impact of changes to
                  types on pre-existing <code class="literal">native</code> methods that are not recompiled is
                  beyond the scope of this specification and should be provided with the
                  description of an implementation. Implementations are encouraged, but
                  not required, to implement <code class="literal">native</code> methods in a way that limits such
                  impact.
               </p>
            </div>
            <div class="section" title="13.4.19.&nbsp;static Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.19"></a>13.4.19.&nbsp;<code class="literal">static</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.19-100"></a>If a method that is not
                  declared <code class="literal">private</code> is also declared <code class="literal">static</code> (that is, a class method)
                  and is changed to not be declared <code class="literal">static</code> (that is, to an instance
                  method), or vice versa, then compatibility with pre-existing binaries
                  may be broken, resulting in a linkage time error, namely an <code class="literal">IncompatibleClassChangeError</code>, if
                  these methods are used by the pre-existing binaries. Such changes are
                  not recommended in code that has been widely distributed.
               </p>
            </div>
            <div class="section" title="13.4.20.&nbsp;synchronized Methods">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.20"></a>13.4.20.&nbsp;<code class="literal">synchronized</code> Methods
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.20-100"></a>Adding or deleting a
                  <code class="literal">synchronized</code> modifier of a method does not break compatibility with
                  pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.21.&nbsp;Method and Constructor Throws">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.21"></a>13.4.21.&nbsp;Method and Constructor Throws
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.21-100"></a>Changes to the <code class="literal">throws</code>
                  clause of methods or constructors do not break compatibility with
                  pre-existing binaries; these clauses are checked only at compile
                  time.
               </p>
            </div>
            <div class="section" title="13.4.22.&nbsp;Method and Constructor Body">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.22"></a>13.4.22.&nbsp;Method and Constructor Body
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.22-100"></a>Changes to the body of a
                  method or constructor do not break compatibility with pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.4.22-110"></a>The keyword <code class="literal">final</code> on a
                  method does not mean that the method can be safely inlined; it means
                  only that the method cannot be overridden. It is still possible that a
                  new version of that method will be provided at link-time. Furthermore,
                  the structure of the original program must be preserved for purposes
                  of reflection.
               </p>
               <p class="norm"><a name="jls-13.4.22-120"></a>Therefore, we note that a
                  Java compiler cannot expand a method inline at compile time. In
                  general we suggest that implementations use late-bound (run-time) code
                  generation and optimization.
               </p>
            </div>
            <div class="section" title="13.4.23.&nbsp;Method and Constructor Overloading">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.23"></a>13.4.23.&nbsp;Method and Constructor Overloading
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.23-100"></a>Adding new methods or
                  constructors that overload existing methods or constructors does not
                  break compatibility with pre-existing binaries. The signature to be
                  used for each invocation was determined when these existing binaries
                  were compiled; therefore newly added methods or constructors will not
                  be used, even if their signatures are both applicable and more
                  specific than the signature originally chosen.
               </p>
               <p class="norm"><a name="jls-13.4.23-110"></a>While adding a new
                  overloaded method or constructor may cause a compile-time error the
                  next time a class or interface is compiled because there is no method
                  or constructor that is most specific
                  (<a class="xref" href="jls-15.html#jls-15.12.2.5" title="15.12.2.5.&nbsp;Choosing the Most Specific Method">&sect;15.12.2.5</a>), no such error occurs when a program
                  is executed, because no overload resolution is done at execution
                  time.
               </p>
               <div class="example"><a name="d5e19782"></a><p class="title"><b>Example&nbsp;13.4.23-1.&nbsp;Adding An Overloaded Method</b></p>
                  <div class="example-contents"><pre class="programlisting">
class Super {
    static void out(float f) {
        System.out.println("float");
    }
}
class Test {
    public static void main(String[] args) {
        Super.out(2);
    }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
float
</pre><p class="note">Suppose that a new version of
                        class <code class="literal">Super</code> is produced:
                     </p><pre class="programlisting">
class Super {
    static void out(float f) { System.out.println("float"); }
    static void out(int i)   { System.out.println("int");   }
}
</pre><p class="note">If <code class="literal">Super</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary of Test still produces the output:
                     </p><pre class="screen">
float
</pre><p class="note">However, if <code class="literal">Test</code> is then
                        recompiled, using this new <code class="literal">Super</code>, the output is
                        then:
                     </p><pre class="screen">
int
</pre><p class="note">as might have been naively expected in the previous
                        case.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.4.24.&nbsp;Method Overriding">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.24"></a>13.4.24.&nbsp;Method Overriding
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.24-100"></a>If an instance method is
                  added to a subclass and it overrides a method in a superclass, then
                  the subclass method will be found by method invocations in
                  pre-existing binaries, and these binaries are not impacted.
               </p>
               <p class="norm"><a name="jls-13.4.24-110"></a>If a class method is added
                  to a class, then this method will not be found unless the qualifying
                  type of the reference is the subclass type.
               </p>
            </div>
            <div class="section" title="13.4.25.&nbsp;Static Initializers">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.25"></a>13.4.25.&nbsp;Static Initializers
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.25-100"></a>Adding, deleting, or
                  changing a static initializer (<a class="xref" href="jls-8.html#jls-8.7" title="8.7.&nbsp;Static Initializers">&sect;8.7</a>) of a class
                  does not impact pre-existing binaries.
               </p>
            </div>
            <div class="section" title="13.4.26.&nbsp;Evolution of Enums">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.4.26"></a>13.4.26.&nbsp;Evolution of Enums
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.4.26-100"></a>Adding or reordering
                  constants in an enum will not break compatibility with pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.4.26-110"></a>If a pre-existing binary
                  attempts to access an enum constant that no longer exists, the client
                  will fail at run time with a <code class="literal">NoSuchFieldError</code>. Therefore such a change is not
                  recommended for widely distributed enums.
               </p>
               <p class="norm"><a name="jls-13.4.26-120"></a>In all other respects, the
                  binary compatibility rules for enums are identical to those for
                  classes.
               </p>
            </div>
         </div>
         <div class="section" title="13.5.&nbsp;Evolution of Interfaces">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jls-13.5"></a>13.5.&nbsp;Evolution of Interfaces
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jls-13.5-100"></a>This section describes the
               impact of changes to the declaration of an interface and its members
               on pre-existing binaries.
            </p>
            <div class="section" title="13.5.1.&nbsp;public Interfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.1"></a>13.5.1.&nbsp;<code class="literal">public</code> Interfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.1-100"></a>Changing an interface that
                  is not declared <code class="literal">public</code> to be declared <code class="literal">public</code> does not break
                  compatibility with pre-existing binaries.
               </p>
               <p class="norm"><a name="jls-13.5.1-110"></a>If an interface that is
                  declared <code class="literal">public</code> is changed to not be declared <code class="literal">public</code>, then an
                  <code class="literal">IllegalAccessError</code> is thrown if a pre-existing binary is linked that needs but no
                  longer has access to the interface type, so such a change is not
                  recommended for widely distributed interfaces.
               </p>
            </div>
            <div class="section" title="13.5.2.&nbsp;Superinterfaces">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.2"></a>13.5.2.&nbsp;Superinterfaces
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.2-100"></a>Changes to the interface
                  hierarchy cause errors in the same way that changes to the class
                  hierarchy do, as described in <a class="xref" href="jls-13.html#jls-13.4.4" title="13.4.4.&nbsp;Superclasses and Superinterfaces">&sect;13.4.4</a>. In
                  particular, changes that result in any previous superinterface of a
                  class no longer being a superinterface can break compatibility with
                  pre-existing binaries, resulting in a <code class="literal">VerifyError</code>.
               </p>
            </div>
            <div class="section" title="13.5.3.&nbsp;Interface Members">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.3"></a>13.5.3.&nbsp;Interface Members
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.3-100"></a>Adding an <code class="literal">abstract</code> method to an
                  interface does not break compatibility with pre-existing
                  binaries.
               </p>
               <p class="norm"><a name="jls-13.5.3-110"></a>A field added to a
                  superinterface of <span class="type">C</span> may hide a field inherited from a superclass of
                  <span class="type">C</span>. If the original reference was to an instance field, an <code class="literal">IncompatibleClassChangeError</code>
                  will result. If the original reference was an assignment, an <code class="literal">IllegalAccessError</code>
                  will result.
               </p>
               <p class="norm"><a name="jls-13.5.3-120"></a>Deleting a member from an
                  interface may cause linkage errors in pre-existing binaries.
               </p>
               <div class="example"><a name="d5e19841"></a><p class="title"><b>Example&nbsp;13.5.3-1.&nbsp;Deleting An Interface Member</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface I { void hello(); }
class Test implements I {
    public static void main(String[] args) {
        I anI = new Test();
        anI.hello();
    }
    public void hello() { System.out.println("hello"); }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
hello
</pre><p class="note">Suppose that a new version of
                        interface <code class="literal">I</code> is compiled:
                     </p><pre class="programlisting">
interface I {}
</pre><p class="note">If <code class="literal">I</code> is recompiled but
                        not <code class="literal">Test</code>, then running the new binary with the
                        existing binary for <code class="literal">Test</code> will result in a
                        <code class="literal">NoSuchMethodError</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.5.4.&nbsp;Interface Type Parameters">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.4"></a>13.5.4.&nbsp;Interface Type Parameters
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.4-100"></a>The effects of changes to
                  the type parameters of an interface are the same as those of analogous
                  changes to the type parameters of a class.
               </p>
            </div>
            <div class="section" title="13.5.5.&nbsp;Field Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.5"></a>13.5.5.&nbsp;Field Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.5-100"></a>The considerations for
                  changing field declarations in interfaces are the same as those
                  for <code class="literal">static final</code> fields in classes, as described in
                  <a class="xref" href="jls-13.html#jls-13.4.8" title="13.4.8.&nbsp;Field Declarations">&sect;13.4.8</a> and <a class="xref" href="jls-13.html#jls-13.4.9" title="13.4.9.&nbsp;final Fields and static Constant Variables">&sect;13.4.9</a>.
               </p>
            </div>
            <div class="section" title="13.5.6.&nbsp;Interface Method Declarations">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.6"></a>13.5.6.&nbsp;Interface Method Declarations
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.6-100"></a>The considerations for
                  changing <code class="literal">abstract</code> method declarations in interfaces include those
                  for <code class="literal">abstract</code> methods in classes, as described in
                  <a class="xref" href="jls-13.html#jls-13.4.14" title="13.4.14.&nbsp;Method and Constructor Formal Parameters">&sect;13.4.14</a>, <a class="xref" href="jls-13.html#jls-13.4.15" title="13.4.15.&nbsp;Method Result Type">&sect;13.4.15</a>,
                  <a class="xref" href="jls-13.html#jls-13.4.19" title="13.4.19.&nbsp;static Methods">&sect;13.4.19</a>, <a class="xref" href="jls-13.html#jls-13.4.21" title="13.4.21.&nbsp;Method and Constructor Throws">&sect;13.4.21</a>, and
                  <a class="xref" href="jls-13.html#jls-13.4.23" title="13.4.23.&nbsp;Method and Constructor Overloading">&sect;13.4.23</a>.
               </p>
               <p class="norm"><a name="jls-13.5.6-110"></a>Adding a <code class="literal">default</code> method,
                  or changing a method from <code class="literal">abstract</code> to <code class="literal">default</code>, does not break
                  compatibility with pre-existing binaries, but may cause an <code class="literal">IncompatibleClassChangeError</code> if a
                  pre-existing binary attempts to invoke the method. This error occurs
                  if the qualifying type, <span class="type">T</span>, is a subtype of two interfaces, <span class="type">I</span> and
                  <span class="type">J</span>, where both <span class="type">I</span> and <span class="type">J</span> declare a <code class="literal">default</code> method with the same
                  signature and result, and neither <span class="type">I</span> nor <span class="type">J</span> is a subinterface of the
                  other.
               </p>
               <p class="norm"><a name="jls-13.5.6-120"></a>In other words, adding a
                  default method is a binary-compatible change because it does not
                  introduce errors at link time, even if it introduces errors at compile
                  time or invocation time. In practice, the risk of accidental clashes
                  occurring by introducing a default method are similar to those
                  associated with adding a new method to a non-<code class="literal">final</code> class. In the
                  event of a clash, adding a method to a class is unlikely to trigger a
                  <code class="literal">LinkageError</code>, but an accidental override of the method in a child can lead to
                  unpredictable method behavior. Both changes can cause errors at
                  compile time.
               </p>
               <div class="example"><a name="d5e19889"></a><p class="title"><b>Example&nbsp;13.5.6-1.&nbsp;Adding A Default Method</b></p>
                  <div class="example-contents"><pre class="programlisting">
interface Painter {
    default void draw() {
        System.out.println("Here's a picture...");
    }
}

interface Cowboy {}

public class CowboyArtist implements Cowboy, Painter {
    public static void main(String... args) {
        new CowboyArtist().draw();
   }
}
</pre><p class="note">This program produces the output:</p><pre class="screen">
Here's a picture...
</pre><p class="note">Suppose that a default method is added
                        to <code class="literal">Cowboy</code>:
                     </p><pre class="programlisting">
interface Cowboy {
    default void draw() {
        System.out.println("Bang!");
    }
}
</pre><p class="note">If <code class="literal">Cowboy</code> is recompiled but
                        not <code class="literal">CowboyArtist</code>, then running the new binary with
                        the existing binary for <code class="literal">CowboyArtist</code> will link
                        without error but cause an <code class="literal">IncompatibleClassChangeError</code> when <code class="literal">main</code>
                        attempts to invoke <code class="literal">draw()</code>.
                     </p>
                  </div>
               </div><br class="example-break"></div>
            <div class="section" title="13.5.7.&nbsp;Evolution of Annotation Types">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jls-13.5.7"></a>13.5.7.&nbsp;Evolution of Annotation Types
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jls-13.5.7-100"></a>Annotation types behave
                  exactly like any other interface. Adding or removing an element from
                  an annotation type is analogous to adding or removing a method. There
                  are important considerations governing other changes to annotation
                  types, such as making an annotation type repeatable
                  (<a class="xref" href="jls-9.html#jls-9.6.3" title="9.6.3.&nbsp;Repeatable Annotation Types">&sect;9.6.3</a>), but these have no effect on the linkage
                  of binaries by the Java Virtual Machine. Rather, such changes affect the behavior of
                  reflective APIs that manipulate annotations. The documentation of
                  these APIs specifies their behavior when various changes are made to
                  the underlying annotation types.
               </p>
               <p class="norm"><a name="jls-13.5.7-110"></a>Adding or removing
                  annotations has no effect on the correct linkage of the binary
                  representations of programs in the Java programming language.
               </p>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jls-12.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jls-14.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;12.&nbsp;Execution&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;14.&nbsp;Blocks and Statements</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jls-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>